<!DOCTYPE html>
<html>
	<head>
		<title>SHACL 1.2 SPARQL Extensions</title>
		<meta charset="utf-8">
		<script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove" defer></script>
		<script class="remove">
		
			function prepareSyntaxRules() {
				document.querySelectorAll("[data-syntax-rule]").forEach(element => {
					let ruleId = element.getAttribute("data-syntax-rule");
					let tr = document.createElement("tr");
					tr.classList.add("syntax-rule-tr");
					let td1 = document.createElement("td");
					td1.classList.add("syntax-rule-id");
					let a = document.createElement("a");
					a.classList.add("syntax-rule-id-a");
					a.href = "#syntax-rule-" + ruleId;
					a.textContent = ruleId;
					td1.appendChild(a);
					let td2 = document.createElement("td");
					td2.innerHTML = element.innerHTML;
					tr.appendChild(td1);
					tr.appendChild(td2);

					// Replace <dfn> elements inside `tr` with <a> elements
					tr.querySelectorAll("dfn").forEach(dfn => {
    					let a = document.createElement("a");
    					a.textContent = dfn.textContent;
    					dfn.replaceWith(a);
					});

					document.getElementById("syntax-rules-table").appendChild(tr);
					element.setAttribute("id", "syntax-rule-" + ruleId);
				});
			}
		
			function prepareValidators() {
				document.querySelectorAll("[data-validator]").forEach(element => {
					let validatorId = element.getAttribute("data-validator") + "ConstraintComponent";
					let tr = document.createElement("tr");
					tr.classList.add("validator-tr");
					let td = document.createElement("td");
					tr.appendChild(td);
					let a = document.createElement("a");
					a.classList.add("validator-id-a");
					a.href = `#validator-${validatorId}`;
					a.textContent = `sh:${validatorId}`;
					td.appendChild(a);
					td.innerHTML += ": " + element.innerHTML;
					document.getElementById("validators-table").appendChild(tr);
					element.id = "validator-" + validatorId;
				});
			}

			document.addEventListener("DOMContentLoaded", () => {
				// Replace code div blocks in shapes, data, and results graph with tabs
				for (const graph of document.querySelectorAll(".shapes-graph, .data-graph, .results-graph")) {
					const tabs = document.createElement("aside");
					tabs.classList.add("ds-selector-tabs");
					graph.firstElementChild.classList.add("selected");

					for (const child of graph.children) {
						child.classList.add("tab");
					}

					tabs.append(...graph.children);
					graph.append(tabs)
				}

				// Generate buttons for the selection logic
				for (const tabs of document.querySelectorAll(".ds-selector-tabs")) {
					const selectors = document.createElement("div");
					selectors.classList.add("selectors");
					selectors.innerHTML = `
						<button class="selected" data-selects="turtle">Turtle</button>
						<button data-selects="jsonld">JSON-LD</button>
					`

					tabs.prepend(selectors);
				}

				// Add example button selection logic
				for (const button of document.querySelectorAll(".ds-selector-tabs .selectors button")) {
					button.onclick = () => {
						const ex = button.closest(".ds-selector-tabs");
						ex.querySelector("button.selected").classList.remove("selected");
						ex.querySelector(".selected").classList.remove("selected");
						button.classList.add('selected');
						ex.querySelector("." + button.dataset.selects).classList.add("selected");
					}
				}
			});

			var respecConfig = {
				group: "wg/data-shapes",
				github: "w3c/data-shapes",
				edDraftURI: "https://w3c.github.io/data-shapes/shacl12-sparql/",
				specStatus: "ED",
				preProcess : [ prepareSyntaxRules, prepareValidators ],
				shortName:  "shacl12-sparql",
				subjectPrefix: "[shacl12-sparql]",
				editors: [
					{
						name:       "Holger Knublauch",
						company:    "TopQuadrant, Inc.",
						companyURL: "http://topquadrant.com/",
						mailto:     "holger@topquadrant.com",
						w3cid:      46500
					},
					{
						name:       "Ashley Sommer",
						company:    "CSIRO",
						companyURL: "https://csiro.au",
						mailto:     "ashley.sommer@csiro.au",
						w3cid:      155924
					}
				],
				formerEditors: [
					{
						name:       "Dimitris Kontokostas",
						w3cid:      58399
					}
				],
				testSuiteURI: "https://w3c.github.io/data-shapes/data-shapes-test-suite/",

				previousPublishDate: "2017-07-20",
				previousMaturity: "REC",
				prevRecShortname: "shacl",
				prevRecURI: "https://www.w3.org/TR/2017/REC-shacl-20170720/#part2",
				lint: {
					"no-unused-dfns": false,  // This should be removed near the end of the process
  				},
				wgPublicList: "public-shacl"
			};
		</script>
		<style>

			pre {
				tab-size: 3;
				-moz-tab-size: 3; /* Code for Firefox */
				-o-tab-size: 3; /* Code for Opera */
			}

			th {
				text-align: left;
			}
			table.rule { background-color: #EBEBE0; }
			table.rule td { text-align: center; }
			td.up { border-bottom:1px solid black; }
			
			td {
				vertical-align: top;
			}
			
			.algorithm {
				background: #fafafc;
				border-left-style: solid;
				border-left-width: .5em;
				border-color: #c0c0c0;
				margin-bottom: 16px;
				padding: 8px;
			}
			
			.arg {
				font-weight: bold;
				color: #000080;
			}

			.def {
				background: #fcfcfc;
				border-left-style: solid;
				border-left-width: .5em;
				border-color: #c0c0c0;
				margin-bottom: 16px;
			}
			
			.def-sparql {
			}
			
			.def-sparql-body {
				margin-top: 0px;
				margin-bottom: 0px;
			}
			
			.def-text {
			}
			
			.def-text-body {
			}
			
			.def-header {
				color: #a0a0a0;
				font-size: 16px;
				padding-bottom: 8px;
			}
			
			.diagram-class {
				border: 1px solid black; 
				border-radius: 4px; 
				width: 360px;
			}
			
			.diagram-class-name {
				font-size: 16px; 
				font-weight: bold; 
				text-align: center;
			}
			
			.diagram-class-properties {
				border-top: 1px solid black; 
			}
			
			.diagram-class-properties-start {
				padding: 8px;
			}
			
			.diagram-class-properties-section {
				border-top: 1px dashed #808080;
				padding: 8px;
			}
			
			.example {
				overflow-y: hidden !important;
			}

			.focus-node-selected {
				color: blue;
			}
			.focus-node-error {
				color: red;
			}

			.triple-can-be-skipped {
				color: grey;
			}
			.focus-node-error {
				color: red;
			}

			.target-can-be-skipped {
				color: darkslategray;
				font-style: italic;
			}
			
			.component-class {
				font-weight: bold;
				font-size: 16px;
			}
			
			.parameter-context {
				font-weight: bold;
				font-size: 16px;
			}
			
			.parameters {
				font-weight: bold;
				font-size: 16px;
			}

			.part-header {
				font-weight: bold;
			}
			
			.syntax {
				border-left-style: solid;
				border-left-width: .5em;
				border-color: #d0d0d0;
				margin-bottom: 16px;
				padding: .5em 1em;
				background-color: #f6f6f6;
			}
			
			.syntax-rule-id {
				padding-right: 10px;
			}
			
			.syntax-rule-id-a {
				white-space: nowrap;
			}
			
			.validator-id-a {
				font-weight: bold;
				white-space: nowrap;
			}
		
			.term {
				font-style: italic;
			}
			
			.term-def-header {
				font-style: italic;
				font-weight: bold;
			}
		
			.term-table {
				border-collapse: collapse;
				border-color: #000000;
				margin: 16px;
			}

			.term-table td, th {
				border-width: 1px;
				border-style: solid;
				padding: 5px;
			}
		
			.todo {
				color: red;
			}

			.turtle {
				font-family: Menlo, Consolas, "DejaVu Sans Mono", Monaco, monospace;
				font-size: 14.4px;
				hyphens: none;
				overflow-x: auto;
				padding: .5em;
				tab-size: 3;
				-moz-tab-size: 3; /* Code for Firefox */
				-o-tab-size: 3; /* Code for Opera */
				text-align: start;
				margin-bottom: -1.5em;
				margin-top: -1.5em;
				white-space: pre;
			}
			
			.data-graph { 
				background: #eeb; 
				border: 1px solid #cc9;
				margin-top: 0.3em;
			}
			.data-graph:before { 
				color: #996; 
				content: "Data graph"; 
				padding-left: 0.4em;
			}
			
			.results-graph { 
				background: #edb; 
				border: 1px solid #bbb;
				margin-top: 0.3em;
			}
			.results-graph:before { 
				color: #997; 
				content: "Validation results"; 
				padding-left: 0.4em;
			}
			
			.shapes-graph { 
				background: #deb; 
				border: 1px solid #bbb;
				margin-top: 0.3em;
			}
			.shapes-graph:before { 
				color: #888; 
				content: "Shapes graph"; 
				padding-left: 0.4em;
			}

			/* no dark mode, keep colors for shapes-graph, data-graph, and results graph background */
			code.hljs {
				--base: transparent;
				--mono-1: #383a42;
			}

			/* example tab selection */
			.ds-selector-tabs .selectors {
				padding: 0;
				border-bottom: 1px solid #ccc;
				height: 28px;
			}
			.ds-selector-tabs .selectors button {
				display: inline-block;
				min-width: 54px;
				text-align: center;
				font-size: 11px;
				font-weight: bold;
				height: 27px;
				padding: 0 8px;
				line-height: 27px;
				transition: all,0.218s;
				border-top-right-radius: 2px;
				border-top-left-radius: 2px;
				color: #666;
				border: 1px solid transparent;
			}
			.ds-selector-tabs .selectors button:first-child {
				margin-left: 2px;
			}
			.ds-selector-tabs .selectors button.selected {
				color: #202020 !important;
				border: 1px solid #ccc;
				border-bottom: 1px solid #fff !important;
			}
			.ds-selector-tabs .selectors button:hover {
				background-color: transparent;
				color: #202020;
				cursor: pointer;
			}
			.ds-selector-tabs .tab {
				display: none;
			}
			.ds-selector-tabs .selected {
				display: block;
			}
		</style>
	</head>
	<body>

		<section id="abstract">
			<p>
				This document defines SPARQL-related extensions of the SHACL Shapes Constraint Language.
				SHACL is a language for validating RDF graphs against a set of conditions.
				These conditions are provided as shapes and other constructs expressed in the form of an RDF graph.
				While the Core part of SHACL defines the basic syntax of shapes and the most common constraint components
				supported by SHACL, the SPARQL-related extensions cover features that extend the expressiveness of Core
				by means of SPARQL.
				In particular, this document defines how constraints and constraint components can be defined using SPARQL.
			</p>
			<p class="todo">
				TODO: More will be added on Node Expressions/targets once that part is ready.
				Other features from SHACL-AF such as user-defined functions may get added.
			</p>
		</section>

		<section id="sotd">
		</section>

		<section id="introduction">
			<h2>Introduction</h2>
			<p>
				This document specifies the SPARQL-related features of the SHACL (Shapes Constraint Language).
			</p>
			<section id="terminology">
				<h3>Terminology</h3>
				<p>
					Throughout this document, the following terminology is used.
				</p>
				<p>
					The SHACL SPARQL Extensions defined in this document are sometimes called SHACL-SPARQL.
				</p>
				<p>
					Terminology that is linked to portions of RDF 1.2 Concepts and Abstract Syntax is used in SHACL-SPARQL as defined there.
					Terminology that is linked to portions of SPARQL 1.2 Query Language is used in SHACL-SPARQL as defined there. 
					Terminology that is linked to portions of SHACL 1.2 Core is used in SHACL-SPARQL as defined there. 
					A single linkage is sufficient to provide a definition for all occurences of a particular term in this document.
				</p>
				<p>
					Definitions are complete within this document, i.e., if there is no rule to
					make some situation true in this document then the situation is false.
				</p>
				<div class="def" id="rdf-terminology">
					<div class="term-def-header">Basic RDF Terminology</div>
					<div>
						This document uses the terms 
						<dfn data-cite="rdf12-concepts#dfn-rdf-graph" data-lt="graph|graphs|RDF graphs">RDF graph</dfn>,
						<dfn data-cite="rdf12-concepts#dfn-rdf-triple" data-lt="triple|triples">RDF triple</dfn>,
						<dfn data-cite="rdf12-concepts#dfn-iri" data-lt="IRI|IRIs">IRI</dfn>,
						<dfn data-cite="rdf12-concepts#dfn-rdf-literal" data-lt="literal|literals">literal</dfn>,
						<dfn data-cite="rdf12-concepts#dfn-blank-node" data-lt="blank node|blank nodes">blank node</dfn>,
						<dfn data-cite="rdf12-concepts#dfn-rdf-node" data-lt="node|nodes">node</dfn> of an RDF graph,
						<dfn data-cite="rdf12-concepts#dfn-datatype" data-lt="datatype|datatypes">datatype</dfn>,
						<dfn data-cite="rdf12-concepts#dfn-rdf-term" data-lt="term|terms">RDF term</dfn>, and
						<dfn data-cite="rdf12-concepts#dfn-subject" data-lt="subject|subjects">subject</dfn>,
						<dfn data-cite="rdf12-concepts#dfn-predicate" data-lt="predicate|predicates">predicate</dfn>, and
						<dfn data-cite="rdf12-concepts#dfn-object" data-lt="object|objects">object</dfn> of RDF triples
						as defined in RDF 1.2 Concepts and Abstract Syntax [[!rdf12-concepts]].
					</div>
				</div>
				<div class="def" id="shacl-terminology">
					<div class="term-def-header">Basic SHACL Terminology</div>
					<div>
						This document uses the terms
						<dfn data-cite="shacl12-core#dfn-focus-node" data-lt="focus node|focus nodes">focus node</dfn>,
						<dfn data-cite="shacl12-core#dfn-value" data-lt="value">value</dfn>,
						<dfn data-cite="shacl12-core#dfn-value-node" data-lt="value node|value nodes">value node</dfn>,
						<dfn data-cite="shacl12-core#dfn-constraint" data-lt="constraint|constraints">constraint</dfn>,
						<dfn data-cite="shacl12-core#dfn-constraint-component" data-lt="constraint component|constraint components">constraint component</dfn>,
						<dfn data-cite="shacl12-core#dfn-parameter" data-lt="parameter|parameters">parameter</dfn>,
						<dfn data-cite="shacl12-core#dfn-mandatory-parameter" data-lt="mandatory parameter|mandatory parameters">mandatory parameter</dfn>,
						<dfn data-cite="shacl12-core#dfn-optional-parameter" data-lt="optional parameter|optional parameters">optional parameter</dfn>,
						<dfn data-cite="shacl12-core#dfn-parameter-value" data-lt="parameter value">parameter value</dfn>,
						<dfn data-cite="shacl12-core#dfn-shape" data-lt="shape|shapes">shape</dfn>,
						<dfn data-cite="shacl12-core#dfn-node-shape" data-lt="node shape|node shapes">node shape</dfn>,
						<dfn data-cite="shacl12-core#dfn-property-shape" data-lt="property shape|property shapes">property shape</dfn>,
						<dfn data-cite="shacl12-core#dfn-shacl-property-path" data-lt="shacl property path|shacl property paths">SHACL property path</dfn>,
						<dfn data-cite="shacl12-core#dfn-sparql-property-path" data-lt="sparql property path|sparql property paths">SPARQL property path</dfn>,
						<dfn data-cite="shacl12-core#dfn-shapes-graph" data-lt="shapes graph">shapes graph</dfn>,
						<dfn data-cite="shacl12-core#dfn-target" data-lt="target|targets">target</dfn>,
						<dfn data-cite="shacl12-core#dfn-validators" data-lt="validator|validators">validator</dfn>,
						<dfn data-cite="shacl12-core#dfn-node-expression" data-lt="node expression|node expresssions">node expression</dfn>,
						<dfn data-cite="shacl12-core#dfn-node-expression-function" data-lt="node expression function|node expresssion functions">node expression function</dfn>,
						<dfn data-cite="shacl12-core#dfn-function-name" data-lt="node expression function name">function name</dfn>,
						<dfn data-cite="shacl12-core#dfn-key-parameter" data-lt="key parameter">key parameter</dfn>,
						<dfn data-cite="shacl12-core#dfn-output-nodes" data-lt="output nodes">output nodes</dfn>,
						<dfn data-cite="shacl12-core#dfn-focus-graph" data-lt="focus graph">focus graph</dfn>,
						<dfn data-cite="shacl12-core#dfn-conform" data-lt="conform|conforms">conform</dfn>,
						<dfn data-cite="shacl12-core#dfn-failure" data-lt="failure|failures">failure</dfn>,
						<dfn data-cite="shacl12-core#dfn-shacl-instance" data-lt="shacl instance">SHACL instance</dfn>,
						<dfn data-cite="shacl12-core#dfn-shacl-subclass" data-lt="shacl subclass">SHACL subclass</dfn>,
						<dfn data-cite="shacl12-core#dfn-shacl-type" data-lt="shacl type">SHACL type</dfn>,
						as defined in the SHACL 1.2 Core specification [[!shacl12-core]].
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">Binding, Solution</div>
					<div>
						A <dfn data-lt="bindings">binding</dfn> is a pair (<a data-cite="sparql12-query/#defn_QueryVariable">variable</a>, <a>RDF term</a>), consistent with the term's use in [[!sparql12-query]].
					    A <dfn data-lt="solutions">solution</dfn> is a set of bindings, informally often understood as one row in the body of the result table of a SPARQL query.
					    Variables are not required to be bound in a solution.
					</div>
				</div>

			</section>

			<section id="conventions">
				<h3>Document Conventions</h3>
				<p>
					The syntax of SHACL is RDF.
					The examples in this document use Turtle [[rdf12-turtle]].
					Other RDF serializations such as RDF/XML may be used in practice.
					The reader should be familiar with basic RDF concepts [[rdf12-concepts]] such as triples and with SPARQL [[sparql12-query]].
				</p>
				<p>
					Within this document, the following namespace prefix bindings are used:
				</p>
				<table class="term-table">
					<tr>
						<th>Prefix</th>
						<th>Namespace</th>
					</tr>
					<tr>
						<td><code>owl:</code></td>
						<td><code>http://www.w3.org/2002/07/owl#</code></td>
					</tr>
					<tr>
						<td><code>rdf:</code></td>
						<td><code>http://www.w3.org/1999/02/22-rdf-syntax-ns#</code></td>
					</tr>
					<tr>
						<td><code>rdfs:</code></td>
						<td><code>http://www.w3.org/2000/01/rdf-schema#</code></td>
					</tr>
					<tr>
						<td><code>sh:</code></td>
						<td><code><a href="http://www.w3.org/ns/shacl">http://www.w3.org/ns/shacl#</a></code></td>
					</tr>
					<tr>
						<td><code>xsd:</code></td>
						<td><code>http://www.w3.org/2001/XMLSchema#</code></td>
					</tr>
					<tr>
						<td><code>ex:</code></td>
						<td><code>http://example.com/ns#</code></td>
					</tr>
				</table>

				<p>
					Within this document, the following JSON-LD context is used:
				</p>
				<pre class="jsonld">{
  "@context": {
    "owl": "http://www.w3.org/2002/07/owl#",
    "rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
    "rdfs": "http://www.w3.org/2000/01/rdf-schema#",
    "sh": "http://www.w3.org/ns/shacl#",
    "xsd": "http://www.w3.org/2001/XMLSchema#",
    "ex": "http://example.com/ns#"
  }
}</pre>
				<p>
					Note that the URI of the graph defining the SHACL vocabulary itself is equivalent to
					the namespace above, i.e. it includes the <code>#</code>.
					References to the SHACL vocabulary, e.g. via <code>owl:imports</code> should include the <code>#</code>.
				</p>
				<p>
					Throughout the document, color-coded boxes containing RDF graphs in Turtle will appear.
					These fragments of Turtle documents use the prefix bindings given above.
				</p>
				<div class="shapes-graph">
					<div class="turtle">
# This box represents an input shapes graph

# Triples that can be omitted are marked as grey e.g.
<span class="triple-can-be-skipped">&lt;s&gt; ex:p &lt;o&gt; .</span>
					</div>
					<div class="jsonld">
						<pre class="text">// This box represents an input shapes graph</pre>
						<pre class="jsonld">{
	"@id": "s",
	"ex:p": {
		"@id": "o"
	}
}</pre>
					</div>
				</div>

				<div class="data-graph">
					<div class="turtle">
# This box represents an input data graph.
# When highlighting is used in the examples:

# Elements highlighted in blue are <a>focus nodes</a>
<span class="focus-node-selected">ex:Bob</span> a ex:Person .

# Elements highlighted in red are focus nodes that fail validation
<span class="focus-node-error">ex:Alice</span> a ex:Person .
					</div>
					<div class="jsonld">
						<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:Alice",
			"@type": "ex:Person"
		},
		{
			"@id": "ex:Bob",
			"@type": "ex:Person"
		}
	]
}</pre>
					</div>
				</div>

				<div class="results-graph">
					<div class="turtle">
# This box represents an output results graph
					</div>
					<div class="jsonld">
						<pre class="text">// This box represents an output results graph</pre>
						<pre class="jsonld">{}</pre>
					</div>
				</div>

				<p>
					SHACL Definitions appear in blue boxes:
				</p>
				<div class="def def-sparql">
					<div class="def-header">SPARQL or TEXTUAL DEFINITIONS</div>
<pre class="def-sparql-body">
# This box contains SPARQL or textual definitions. </pre>
				</div>
				
				<p class="syntax">
					Grey boxes such as this include syntax rules that apply to the <a>shapes graph</a>.
				</p>

				<p>
					SPARQL variables using the <code>$</code> marker represent external <a>bindings</a> that are <a>pre-bound</a> or, in the case of <code>$PATH</code>, <a>substituted</a> in the SPARQL query before execution (as explained in <a href="#constraint-components-validation"></a>).
				</p>
				
				<p>
					<code>true</code> denotes the RDF term <code>"true"^^xsd:boolean</code>.
					<code>false</code> denotes the RDF term <code>"false"^^xsd:boolean</code>.
				</p>

			</section>

			<section id="conformance">
				<p>
					This document defines the <strong>SHACL-SPARQL</strong> language that extends SHACL Core.
					This specification describes conformance criteria for:
				</p>
				<ul>
					<li><strong>SHACL-SPARQL processors</strong> as processors that support validation with the SHACL-SPARQL Language</li>
				</ul>
				<p>
					This document includes syntactic rules that shapes and other nodes need to fulfill in the <a>shapes graph</a>.
					These rules are typically of the form <em>A shape must have...</em> or <em>The values of X are literals</em> or <em>All objects of triples with predicate P must be IRIs</em>.
					The complete list of these rules can be found in the <a href="#syntax-rules">appendix</a>.
					Nodes that violate any of these rules are called <dfn>ill-formed</dfn>.
					Nodes that violate none of these rules are called <dfn>well-formed</dfn>.
					A <a>shapes graph</a> is ill-formed if it contains at least one ill-formed node.
				</p>
			</section>
			
		</section>
		
		<section id="sparql-constraints">
			<h2>SPARQL-based Constraints</h2>
			<p>
				SHACL-SPARQL supports a <a>constraint component</a> that can be used to express restrictions based on a SPARQL SELECT query.
			</p>
			<p>
				<span class="component-class">Constraint Component IRI</span>: <code>sh:SPARQLConstraintComponent</code>
			</p>

			<div class="parameters">Parameters:</div>
			<table class="term-table">
				<tr>
					<th>Property</th>
					<th>Summary</th>
				</tr>
				<tr>
					<td><code>sh:sparql</code></td>
					<td>A <a>SPARQL-based constraint</a> declaring the SPARQL query to evaluate.</td>
				</tr>
			</table>
			<p>
				The <a href="#sparql-constraints-syntax">syntax rules</a> and <a href="#sparql-constraints-validation">validation process</a> for SPARQL-based constraints are defined in the rest of this section.
			</p>

			<section id="sparql-constraints-example" class="informative">
				<h3>An Example SPARQL-based Constraint</h3>
				<p>
					The following example illustrates the syntax of a <a>SPARQL-based constraint</a>.
				</p>

				<aside class="example" id="example-sparql-constraint" title="A SPARQL-based constraint">
					<div class="shapes-graph">
						<div class="turtle">
ex:LanguageExampleShape
	a sh:NodeShape ;
	<span class="target-can-be-skipped">sh:targetClass ex:Country ;</span>
	sh:sparql [
		a sh:SPARQLConstraint ;   # This triple is optional
		sh:message "Values are literals with German language tag." ;
		sh:prefixes ex: ;
		sh:select """
			SELECT $this (ex:germanLabel AS ?path) ?value
			WHERE {
				$this ex:germanLabel ?value .
				FILTER (!isLiteral(?value) || !langMatches(lang(?value), "de"))
			}
			""" ;
	] .

ex:
	sh:declare [] .   # See <a href="#prefixes-example">prefix declarations</a>
						</div>
						<div class="jsonld">
							<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:LanguageExampleShape",
			"@type": "sh:NodeShape",
			"sh:sparql": {
				"@type": "sh:SPARQLConstraint",
				"sh:message": "Values are literals with German language tag.",
				"sh:prefixes": {
					"@id": "http://example.com/ns#"
				},
				"sh:select": "\n\t\t\tSELECT $this (ex:germanLabel AS ?path) ?value\n\t\t\tWHERE {\n\t\t\t\t$this ex:germanLabel ?value .\n\t\t\t\tFILTER (!isLiteral(?value) || !langMatches(lang(?value), \"de\"))\n\t\t\t}\n\t\t\t"
			},
			"sh:targetClass": {
				"@id": "ex:Country"
			}
		},
		{
			"@id": "http://example.com/ns#",
			"sh:declare": {
				"@id": "_:b1"
			}
		}
	]
}</pre>
						</div>
					</div>
					<p>
						The target of the shape above includes all <a>SHACL instances</a> of <code>ex:Country</code>.
						For those nodes (represented by the variable <code>this</code>), the SPARQL query walks through the values of <code>ex:germanLabel</code>
						and verifies that they are literals with a German language code.
					</p>
					<div class="data-graph">
						<div class="turtle">
ex:ValidCountry a ex:Country ;
	ex:germanLabel "Spanien"@de .
	  
<span class="focus-node-error">ex:InvalidCountry</span> a ex:Country ;
	ex:germanLabel "Spain"@en .
						</div>
						<div class="jsonld">
							<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:InvalidCountry",
			"@type": "ex:Country",
			"ex:germanLabel": {
				"@language": "en",
				"@value": "Spain"
			}
		},
		{
			"@id": "ex:ValidCountry",
			"@type": "ex:Country",
			"ex:germanLabel": {
				"@language": "de",
				"@value": "Spanien"
			}
		}
	]
}</pre>
						</div>
					</div>
	
					<div class="results-graph">
						<div class="turtle">
[	a sh:ValidationReport ;
	sh:conforms false ;
	sh:result [
		a sh:ValidationResult ;
		sh:resultSeverity sh:Violation ;
		sh:focusNode ex:InvalidCountry ;
		sh:resultPath ex:germanLabel ;
		sh:value "Spain"@en ;
		sh:sourceConstraintComponent sh:SPARQLConstraintComponent ;
		sh:sourceShape ex:LanguageExampleShape ;
		# ...
	]
] .
						</div>
						<div class="jsonld">
							<pre class="jsonld">{
	"@type": "sh:ValidationReport",
	"sh:conforms": {
		"@type": "xsd:boolean",
		"@value": "false"
	},
	"sh:result": {
		"@type": "sh:ValidationResult",
		"sh:focusNode": {
			"@id": "ex:InvalidCountry"
		},
		"sh:resultPath": {
			"@id": "ex:germanLabel"
		},
		"sh:resultSeverity": {
			"@id": "sh:Violation"
		},
		"sh:sourceConstraintComponent": {
			"@id": "sh:SPARQLConstraintComponent"
		},
		"sh:sourceShape": {
			"@id": "ex:LanguageExampleShape"
		},
		"sh:value": {
			"@language": "en",
			"@value": "Spain"
		}
	}
}</pre>
						</div>
					</div>
				</aside>
				<p>
					The SPARQL query returns result set <a>solutions</a> for all bindings of the variable <code>value</code> that violate the constraint.
					There is a validation result for each <a>solution</a> in that result set, applying the <a href="#sparql-constraints-validation">mapping rules</a> explained later.
					In this example, each validation result will have the <a>binding</a> for the variable <code>this</code> as the <code>sh:focusNode</code>,
					<code>ex:germanLabel</code> as <code>sh:resultPath</code> and the violating value as <code>sh:value</code>.
				</p>
				<p>
					The following example illustrates a similar scenario as above, but with a <a>property shape</a>.
				</p>
				<aside class="example" id="example-sparql-constraint-in-property-shape">
					<div class="shapes-graph">
						<div class="turtle">
ex:LanguageExamplePropertyShape
	a sh:PropertyShape ;
	<span class="target-can-be-skipped">sh:targetClass ex:Country ;</span>
	sh:path ex:germanLabel ;
	sh:sparql [
		a sh:SPARQLConstraint ;   # This triple is optional
		sh:message "Values are literals with German language tag." ;
		sh:prefixes ex: ;
		sh:select """
			SELECT $this ?value
			WHERE {
				$this $PATH ?value .
				FILTER (!isLiteral(?value) || !langMatches(lang(?value), "de"))
			}
			""" ;
	] .

ex:
	sh:declare [] .   # See <a href="#prefixes-example">prefix declarations</a>
						</div>
						<div class="jsonld">
							<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:LanguageExamplePropertyShape",
			"@type": "sh:PropertyShape",
			"sh:path": {
				"@id": "ex:germanLabel"
			},
			"sh:sparql": {
				"@type": "sh:SPARQLConstraint",
				"sh:message": "Values are literals with German language tag.",
				"sh:prefixes": {
					"@id": "http://example.com/ns#"
				},
				"sh:select": "\n\t\t\tSELECT $this ?value\n\t\t\tWHERE {\n\t\t\t\t$this $PATH ?value .\n\t\t\t\tFILTER (!isLiteral(?value) || !langMatches(lang(?value), \"de\"))\n\t\t\t}\n\t\t\t"
			},
			"sh:targetClass": {
				"@id": "ex:Country"
			}
		},
		{
			"@id": "http://example.com/ns#",
			"sh:declare": {
				"@id": "_:b1"
			}
		}
	]
}</pre>
						</div>
					</div>
				</aside>
			</section>
			
			<section id="sparql-constraints-syntax">
				<h3>Syntax of SPARQL-based Constraints</h3>
				<p class="syntax">
					<span data-syntax-rule="sparql-nodeKind">Shapes may have values for the property <code>sh:sparql</code>, and these values are either <a>IRIs</a> or <a>blank nodes</a>.</span>
					These values are called <dfn data-lt="SPARQL-based constraint">SPARQL-based constraints</dfn>.
				</p>
				<p class="syntax">
					<span data-syntax-rule="SPARQLConstraint-select-count"><a>SPARQL-based constraints</a> have exactly one <a>value</a> for the property <code>sh:select</code></span>.
					<span data-syntax-rule="SPARQLConstraint-select-datatype">The value of <code>sh:select</code> is a <a>literal</a> of datatype <code>xsd:string</code>.</span>
					The class <code>sh:SPARQLConstraint</code> is defined in the SHACL vocabulary and may be used as the <a>type</a> of these constraints (although no type is required).
					<span data-syntax-rule="select-query-valid">Using the <a href="#sparql-prefixes">prefix handling rules</a>, the value of <code>sh:select</code> is a valid SPARQL 1.2 SELECT query.</span>
					<span data-syntax-rule="select-query-this">The SPARQL query derived from the value of <code>sh:select</code> <a data-cite="sparql12-query/#selectproject">projects</a> the variable <code>this</code> in the SELECT clause.</span>
				</p>
				<p>
					The following two properties are similar to their use in <a>shapes</a>:
				</p>
				<p class="syntax">
					<span data-syntax-rule="SPARQLConstraint-message-datatype"><a>SPARQL-based constraints</a> may have values for the property <code>sh:message</code> and these are either <code>xsd:string</code> literals or literals with a language tag.</span>
					<span data-syntax-rule="SPARQLConstraint-deactivated-maxCount"><a>SPARQL-based constraints</a> may have at most one value for the property <code>sh:deactivated</code></span>
					and this value is either <code>true</code> or <code>false</code>.
				</p>
				<p>
					SELECT queries used in the context of <a>property shapes</a> use a special variable named <code>PATH</code> as a placeholder for the path used by the shape.
				</p>
				<p class="syntax">
					<span data-syntax-rule="PATH-position">The only legal use of the variable <code>PATH</code> in the SPARQL queries of <a>SPARQL-based constraints</a>
					and <a>SELECT-based validators</a> is in the
					<a>predicate</a> position of a <a data-cite="sparql12-query/#QSynTriples">triple pattern</a>.</span>
					A query that uses the variable <code>PATH</code> in any other position is <a>ill-formed</a>.
				</p>
				<section id="sparql-prefixes">
					<h4>Prefix Declarations for SPARQL Queries</h4>
					<p>
						A <a>shapes graph</a> may include declarations of namespace prefixes so that these prefixes can be used to abbreviate the SPARQL queries derived from the same shapes graph.
						The syntax of such prefix declarations is illustrated by the following example.
					</p>
					<aside class="example" id="prefixes-example">
						<div class="shapes-graph">
							<div class="turtle">
ex:
	sh:declare [
		sh:prefix "ex" ;
		sh:namespace "http://example.com/ns#"^^xsd:anyURI ;
	] ;
	sh:declare [
		sh:prefix "schema" ;
		sh:namespace "http://schema.org/"^^xsd:anyURI ;
	] ;
	a owl:Ontology ;    # Optional
	owl:imports sh: .   # Optional
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@id": "http://example.com/ns#",
	"@type": "owl:Ontology",
	"owl:imports": {
		"@id": "http://www.w3.org/ns/shacl#"
	},
	"sh:declare": [
		{
			"sh:namespace": {
				"@type": "xsd:anyURI",
				"@value": "http://example.com/ns#"
			},
			"sh:prefix": "ex"
		},
		{
			"sh:namespace": {
				"@type": "xsd:anyURI",
				"@value": "http://schema.org/"
			},
			"sh:prefix": "schema"
		}
	]
}</pre>
							</div>
						</div>
					</aside>
					<p class="syntax">
						<span data-syntax-rule="declare-nodeKind">The <a>values</a> of the property <code>sh:declare</code> are <a>IRIs</a> or <a>blank nodes</a></span>,
						and these values are called <dfn data-lt="prefix declaration">prefix declarations</dfn>.
						The SHACL vocabulary includes the class <code>sh:PrefixDeclaration</code> as type for such <a>prefix declarations</a>
						although no <code>rdf:type</code> triple is required for them.
						<span data-syntax-rule="prefix-count"><a>Prefix declarations</a> have exactly one value for the property <code>sh:prefix</code></span>.
						<span data-syntax-rule="prefix-datatype">The values of <code>sh:prefix</code> are <a>literals</a> of datatype <code>xsd:string</code>.</span>
						<span data-syntax-rule="namespace-count"><a>Prefix declarations</a> have exactly one value for the property <code>sh:namespace</code>.</span>
						<span data-syntax-rule="namespace-datatype">The values of <code>sh:namespace</code> are <a>literals</a> of datatype <code>xsd:anyURI</code>.</span>
						Such a pair of values specifies a single mapping of a prefix to a namespace.
					</p>
					<p>
						The recommended <a>subject</a> for values of <code>sh:declare</code> is the IRI of the named graph containing the shapes that use the prefixes.
						These IRIs are often declared as an instance of <code>owl:Ontology</code>, but this is not required.
					</p>
					<p>
						<a>Prefix declarations</a> can be used by <a>SPARQL-based constraints</a>,
						the <a>validators</a> of <a href="#sparql-constraint-components">SPARQL-based constraint components</a>,
						and by similar features defined by SHACL extensions.
						These nodes can use the property <code>sh:prefixes</code> to specify a set of prefix mappings.
						An example use of the <code>sh:prefixes</code> property can be found in the
						<a href="#sparql-constraints-example">example</a> above.
					</p>
					<p class="syntax">
						<span data-syntax-rule="prefixes-nodeKind">The values of <code>sh:prefixes</code> are either <a>IRIs</a> or <a>blank nodes</a>.</span>
						<span data-syntax-rule="prefixes-duplicates">A SHACL processor collects a set of prefix mappings as the union of all
						individual prefix mappings that are <a>values</a> of the <a>SPARQL property path</a> <code>sh:prefixes/owl:imports*/sh:declare</code>
						of the <a>SPARQL-based constraint</a> or <a>validator</a>.
						If such a collection of prefix declarations contains multiple different namespaces for the same <a>value</a> of <code>sh:prefix</code>,
						then the <a>shapes graph</a> is <a>ill-formed</a>.</span>
						(Note that SHACL processors MAY ignore prefix declarations that are never reached).
					</p>
					<p>
						A SHACL processor transforms the values of <code>sh:select</code> (and similar properties such as <code>sh:ask</code>)
						into SPARQL by prepending <a data-cite="sparql12-query/#rPrefixDecl"><code>PREFIX</code></a> declarations
						for all prefix mappings.
						Each value of <code>sh:prefix</code> is turned into the <code>PNAME_NS</code>, while each value of <code>sh:namespace</code> is turned
						into the <code>IRIREF</code> in the <code>PREFIX</code> declaration.
						For the example shapes graph above, a SHACL-SPARQL processor would produce lines such as <code>PREFIX ex: &lt;http://example.com/ns#&gt;</code>.
						The SHACL-SPARQL processor MUST produce a <a>failure</a> if the resulting query string cannot be parsed into a valid SPARQL 1.2 query.
					</p>
					<p>
						In the rest of this document, the <code>sh:prefixes</code> statements may have been omitted for brevity.
					</p>
				</section>
			</section>
			<section id="sparql-constraints-validation">
				<h3>Validation with SPARQL-based Constraints</h3>
				<p>
					This section explains the <a>validator</a> of <code>sh:SPARQLConstraintComponent</code>.
					Note that this validator only explains one possible implementation strategy, and
					SHACL processors may choose alternative approaches as long as the outcome is equivalent.
				</p>
				<div class="def def-text">
					<div class="def-header">TEXTUAL DEFINITION</div>
					<div class="def-text-body">
						Let <code>$sparql</code> be a <a>value</a> of <code>sh:sparql</code>.
						There are no validation results if the <a>SPARQL-based constraint</a> has <code>true</code>
						as a <a>value</a> for the property <code>sh:deactivated</code>.
						Otherwise, execute the SPARQL query specified by the <a>SPARQL-based constraint</a> <code>$sparql</code>
						<a>pre-binding</a> the variable <code>this</code> as described in <a href="#sparql-constraints-prebound"></a>.
						If the <a>shape</a> is a <a>property shape</a>, then prior to execution
						<dfn data-lt="substituted">substitute</dfn> the variable <code>PATH</code> where it appears in the <a>predicate</a>
						position of a <a data-cite="sparql12-query/#QSynTriples">triple pattern</a>
						with a valid SPARQL surface syntax string of the <a>SHACL property path</a>
						specified via <code>sh:path</code> at the <a>property shape</a>.
						<span id="sparql-constraints-validation-rule">There is one validation result for each <a>solution</a> that does not have <code>true</code> as the <a>binding</a> for the variable <code>failure</code>.
						These validation results MUST have the property values explained in <a href="#sparql-constraints-variables"></a>.
						A <a>failure</a> MUST be produced if and only if one of the <a>solutions</a> has <code>true</code> as the <a>binding</a> for <code>failure</code>.</span>
					</div>
				</div>
				<section id="sparql-constraints-prebound">
					<h4>Pre-bound variable $this in SPARQL Constraints</h4>
					<p>
						When the SPARQL queries of <a>SPARQL-based constraints</a> and the <a>validators</a>
						of <a>SPARQL-based constraint components</a> are <a data-cite="shacl12-core/#validation-definition">processed</a>,
						the SHACL-SPARQL processor <a>pre-binds</a> values for the variable <code>$this</code>
						to the current <a>focus node</a>.
					</p>
				</section>
				<section id="sparql-constraints-variables">
					<h4>Mapping of Solution Bindings to Result Properties</h4>
					<p>
						The property <a>values</a> of the validation result nodes are derived by the following rules, through a combination of result solutions and the values of the constraint itself.
						The rules are meant to be executed from top to bottom, so that the first bound value will be used.
					</p>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Production Rules</th>
						</tr>
						<tr>
							<td><code>sh:focusNode</code></td>
							<td>
								<ol>
									<li>The binding for the variable <code>this</code></li>
								</ol>
							</td>
						</tr>
						<tr>
							<td><code>sh:resultPath</code></td>
							<td>
								<ol>
									<li>The binding for the variable <code>path</code>, if that is a <a>IRI</a></li>
									<li>For results produced by a <a>property shape</a>, a <a>SHACL property path</a> that is equivalent to the <a>value</a> of <code>sh:path</code> of the shape</li>
								</ol>
							</td>
						</tr>
						<tr>
							<td><code>sh:value</code></td>
							<td>
								<ol>
									<li>The binding for the variable <code>value</code></li>
									<li>The <a>value node</a></li>
								</ol>
							</td>
						</tr>
						<tr>
							<td><code>sh:resultMessage</code></td>
							<td>
								<ol>
									<li>The binding for the variable <code>message</code></li>
									<li>
										For SPARQL-based constraints: The values of <code>sh:message</code> of the <a>SPARQL-based constraint</a>.
										For SPARQL-based constraint components: The values of <code>sh:message</code> of the <a>validator</a> of the <a>SPARQL-based constraint component</a>.
									</li>
									<li>
										For SPARQL-based constraint components: The values of <code>sh:message</code> of the <a>SPARQL-based constraint component</a>.
									</li>
								</ol>
								<div>
									These message literals may include the names of any SELECT result variables via <code>{?varName}</code> or <code>{$varName}</code>.
									If the constraint is based on a <a href="#sparql-constraint-components">SPARQL-based constraint component</a>, then the component's <a>parameter names</a> can also be used.
									These <code>{?varName}</code> and <code>{$varName}</code> blocks SHOULD be replaced with suitable string representations of the values of said variables.
								</div>
							</td>
						</tr>
						<tr>
							<td><code>sh:sourceConstraint</code></td>
							<td>
								<ol>
									<li>The <a>SPARQL-based constraint</a>, i.e. the value of <code>sh:sparql</code></li>
								</ol>
							</td>
						</tr>
					</table>
				</section>
			</section>
		</section>
		
		<section id="sparql-constraint-components">
			<h2>SPARQL-based Constraint Components</h2>
			<p>
				<a>SPARQL-based constraints</a> provide a lot of flexibility
				but may be hard to understand for some people or lead to repetition.
				This section introduces <a>SPARQL-based constraint components</a> as a way to abstract the complexity of SPARQL
				and to declare high-level reusable components similar to the <a data-cite="shacl12-core/#core-components">Core constraint components</a>.
				Such constraint components can be declared using the SHACL RDF vocabulary and thus shared and reused.
			</p>

			<section class="informative">
				<h3>An Example SPARQL-based Constraint Component</h3>
				<p>
					The following example demonstrates how SPARQL can be used to specify new constraint components using the SHACL-SPARQL language.
					The example implements <a data-cite="shacl12-core/#PatternConstraintComponent"><code>sh:pattern</code> and <code>sh:flags</code></a> using a
					<a href="#SPARQLAskValidator">SPARQL ASK</a> query to validate that each <a>value node</a> matches a given regular expression.
					Note that this is only an example implementation and should not be considered normative.
				</p>
				<aside class="example" title="Constraint component based on SPARQL">
					<div class="shapes-graph">
						<div class="turtle">
sh:PatternConstraintComponent
	a sh:ConstraintComponent ;
	sh:parameter [
		sh:path sh:pattern ;
	] ;
	sh:parameter [
		sh:path sh:flags ;
		sh:optional true ;
	] ;
	sh:validator ex:hasPattern .

ex:hasPattern
	a sh:SPARQLAskValidator ;
	sh:message "Value does not match pattern {$pattern}" ;
	sh:ask """
		ASK { 
			FILTER (!isBlank($value) &amp;&amp; 
				IF(bound($flags), regex(str($value), $pattern, $flags), regex(str($value), $pattern)))
		}""" .
						</div>
						<div class="jsonld">
							<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:hasPattern",
			"@type": "sh:SPARQLAskValidator",
			"sh:ask": "\n\t\tASK { \n\t\t\tFILTER (!isBlank($value) && \n\t\t\t\tIF(bound($flags), regex(str($value), $pattern, $flags), regex(str($value), $pattern)))\n\t\t}",
			"sh:message": "Value does not match pattern {$pattern}"
		},
		{
			"@id": "sh:PatternConstraintComponent",
			"@type": "sh:ConstraintComponent",
			"sh:parameter": [
				{
					"sh:path": {
						"@id": "sh:pattern"
					}
				},
				{
					"sh:optional": {
						"@type": "xsd:boolean",
						"@value": "true"
					},
					"sh:path": {
						"@id": "sh:flags"
					}
				}
			],
			"sh:validator": {
				"@id": "ex:hasPattern"
			}
		}
	]
}</pre>
						</div>
					</div>
				</aside>
				<p>
					Constraint components provide instructions to validation engines on how to identify and validate <a>constraints</a> within a <a>shape</a>.
					In general, if a <a>shape</a> <code>S</code> has a <a>value</a> for a property <code>p</code>, and there is a <a>constraint component</a>
					<code>C</code> that specifies <code>p</code> as a parameter, and <code>S</code> has values for all <a>mandatory parameters</a> of <code>C</code>,
					then the set of these parameter values (including the <a>optional parameters</a>) declare a <a>constraint</a> and the validation engine uses a suitable <a>validator</a> from <code>C</code>
					to perform the validation of this constraint.
					In the example above, <code>sh:PatternConstraintComponent</code> declares the mandatory parameter <code>sh:pattern</code>,
					the optional parameter <code>sh:flags</code>,
					and a <a>validator</a> that can be used to perform validation against either <a>node shapes</a> or <a>property shapes</a>.
				</p>
			</section>
			
			<section id="constraint-components-syntax">
				<h3>Syntax of SPARQL-based Constraint Components</h3>
				<p class="syntax">
					<span data-syntax-rule="ConstraintComponent">A <dfn data-lt="SPARQL-based constraint components">SPARQL-based constraint component</dfn> is an <a>IRI</a> that has <a>SHACL type</a>
					<code>sh:ConstraintComponent</code> in the <a>shapes graph</a>.</span>
				</p>
				<p>
					The mechanism to declare new <a>constraint components</a> in this document is limited to those based on SPARQL.
					However, then general syntax of declaring parameters and validators has been designed to also work for other extension languages such as JavaScript.
				</p>
			
				<section id="constraint-components-parameters">
					<h4>Parameter Declarations (sh:parameter)</h4>
					<p class="syntax">
						The <a>parameters</a> of a <a>constraint component</a> are declared via the property <code>sh:parameter</code>.
						The values of <code>sh:parameter</code> are called <dfn data-lt="parameter declaration">parameter declarations</dfn>.
						The class <code>sh:Parameter</code> may be used as <a>type</a> of <a>parameter declarations</a> but no such triple is required.
						<span data-syntax-rule="Parameter-predicate-count">Each <a>parameter declaration</a> has exactly one value for the property <code>sh:path</code></span>.
						<span data-syntax-rule="Parameter">At <a>parameter declarations</a>, the <a>value</a> of <code>sh:path</code> is an <a>IRI</a>.</span>
					</p>
					<p>
						The <dfn data-lt="local names">local name</dfn> of an <a>IRI</a> is defined as the longest <a data-cite="REC-xml-names/#NT-NCName">NCNAME</a>
						at the end of the <a>IRI</a>, not immediately preceded by the first colon in the <a>IRI</a>.
						The <dfn data-lt="parameter names">parameter name</dfn> of a <a>parameter declaration</a> is defined as the <a>local name</a> of the <a>value</a> of <code>sh:path</code>.
						To ensure that a correct mapping from parameters into SPARQL variables is possible, the following syntax rules apply:
					</p>
					<p class="syntax">
						<span data-syntax-rule="parameter-name-VARNAME">Every <a>parameter name</a> is a valid <a data-cite="sparql12-query/#rVARNAME">SPARQL VARNAME</a>.</span>
						<span data-syntax-rule="parameter-name-not-in"><a>Parameter names</a> must not be one of the following: <code>this</code>, <code>path</code>, <code>PATH</code>, <code>value</code>.</span>
						<span data-syntax-rule="parameter-name-unique">A constraint component where two or more <a>parameter declarations</a> use the same <a>parameter names</a> is <a>ill-formed</a>.</span>
					</p>
					<p class="syntax">
						<span data-syntax-rule="optional-datatype">The values of <code>sh:optional</code> must be literals with datatype <code>xsd:boolean</code>.</span>
						<span data-syntax-rule="optional-maxCount">A <a>parameter declaration</a> can have at most one value for the property <code>sh:optional</code>.</span>
						If set to <code>true</code> then the parameter declaration declares an <a>optional parameter</a>.
						<span data-syntax-rule="ConstraintComponent-parameter">Every <a>constraint component</a> has at least one non-optional parameter.</span>
					</p>
					<p class="syntax">
						The class <code>sh:Parameter</code> is defined as a <a>SHACL subclass</a> of <code>sh:PropertyShape</code>,
						and all properties that are applicable to property shapes may also be used for parameters.
						This includes descriptive properties such as <code>sh:name</code> and <code>sh:description</code>
						but also constraint parameters such as <code>sh:class</code>.
						<span data-syntax-rule="Parameter-conformance">Shapes that do not <a>conform</a> with the constraints declared for the parameters are <a>ill-formed</a>.</span>
						Some implementations MAY use these constraint parameters to prevent the execution of constraint components with invalid parameter values.
					</p>
				</section>
				<section id="labelTemplate">
					<h4>Label Templates (sh:labelTemplate)</h4>
					<p class="syntax">
						The property <code>sh:labelTemplate</code> can be used at any <a>constraint component</a> to suggest how <a>constraints</a> could be rendered to humans.
						<span data-syntax-rule="labelTemplate-datatype">The values of <code>sh:labelTemplate</code> are strings (possibly with language tag)</span> and
						are called <dfn data-lt="label template">label templates</dfn>.
					</p>
					<p><em>The remainder of this section is informative.</em></p>
					<p>
					 	<a>Label templates</a> can include the names of the parameters that are declared for the constraint component
					 	using the syntaxes <code>{?varName}</code> or <code>{$varName}</code>,
						where <code>varName</code> is the name of the <a>parameter name</a>.
						At display time, these <code>{?varName}</code> and <code>{$varName}</code> blocks SHOULD be replaced with the actual parameter values.
						There may be multiple label templates for the same subject, but they should not have the same language tags.
					</p>
				</section>
				
				<section id="constraint-components-validators">
					<h4>Validators</h4>
					<p>
						For every supported shape type (i.e., <a>property shape</a> or <a>node shape</a>)
						the constraint component declares a suitable <a>validator</a>.
						For a given constraint, a validator is selected from the constraint component using the following rules, in order:
					</p>
					<ol>
						<li>For <a>node shapes</a>, use one of the values of <code>sh:nodeValidator</code>, if present.</li>
						<li>For <a>property shapes</a>, use one of the values of <code>sh:propertyValidator</code>, if present.</li>
						<li>Otherwise, use one of the values of <code>sh:validator</code>.
					</ol>
					<p>
						If no suitable validator can be found, a SHACL-SPARQL processor ignores the constraint.
					</p>
					<p>
						SHACL-SPARQL includes two types of validators, based on <a href="#SPARQLSelectValidator">SPARQL SELECT</a> (for <code>sh:nodeValidator</code> and <code>sh:propertyValidator</code>)
						or <a href="#SPARQLAskValidator">SPARQL ASK</a> queries (for <code>sh:validator</code>).
					</p>
					<section id="SPARQLSelectValidator">
						<h5>SELECT-based Validators</h5>
						<p class="syntax">
							<a>Validators</a> with <a>SHACL type</a> <code>sh:SPARQLSelectValidator</code> are called <dfn>SELECT-based validators</dfn>.
							<span data-syntax-rule="nodeValidator-class">The values of <code>sh:nodeValidator</code> must be <a>SELECT-based validators</a>.</span>
							<span data-syntax-rule="propertyValidator-class">The values of <code>sh:propertyValidator</code> must be <a>SELECT-based validators</a>.</span>
							<span data-syntax-rule="SPARQLSelectValidator-select-count"><a>SELECT-based validators</a> have exactly one <a>value</a> for the property <code>sh:select</code>.</span>
							The value of <code>sh:select</code> is a valid SPARQL SELECT query using the aforementioned <a href="#sparql-prefixes">prefix handling rules</a>.
							The SPARQL query derived from the value of <code>sh:select</code> <a data-cite="sparql12-query/#selectproject">projects</a> the variable <code>this</code> in its SELECT clause.
						</p>
						<p><em>The remainder of this section is informative.</em></p>
						<p>
							The following example illustrates the declaration of a constraint component based on a SPARQL SELECT query.
							It is a generalized variation of the example from <a href="#sparql-constraints-example"></a>.
							That SPARQL query included two constants: the specific property <code>ex:germanLabel</code> and the language tag <code>de</code>.
							Constraint components make it possible to generalize such scenarios, so that constants get <a>pre-bound</a> with <a>parameters</a>.
							This allows the query logic to be reused in multiple places, without having to write any new SPARQL.
						</p>
						<aside class="example" title="Constraint component based on SPARQL">
							<div class="shapes-graph">
								<div class="turtle">
ex:LanguageConstraintComponentUsingSELECT
	a sh:ConstraintComponent ;
	rdfs:label "Language constraint component" ;
	sh:parameter [
		sh:path ex:lang ;
		sh:datatype xsd:string ;
		sh:minLength 2 ;
		sh:name "language" ;
		sh:description "The language tag, e.g. \"de\"." ;
	] ;
	sh:labelTemplate "Values are literals with language \"{$lang}\"" ;
	sh:propertyValidator [
		a sh:SPARQLSelectValidator ;
		sh:message "Values are literals with language \"{?lang}\"" ;
		sh:select """
			SELECT DISTINCT $this ?value
			WHERE {
				$this $PATH ?value .
				FILTER (!isLiteral(?value) || !langMatches(lang(?value), $lang))
			}
			"""
	] .
								</div>
								<div class="jsonld">
									<pre class="jsonld">{
	"@id": "ex:LanguageConstraintComponentUsingSELECT",
	"@type": "sh:ConstraintComponent",
	"rdfs:label": "Language constraint component",
	"sh:labelTemplate": "Values are literals with language \"{$lang}\"",
	"sh:parameter": {
		"sh:datatype": {
			"@id": "xsd:string"
		},
		"sh:description": "The language tag, e.g. \"de\".",
		"sh:minLength": {
			"@type": "xsd:integer",
			"@value": "2"
		},
		"sh:name": "language",
		"sh:path": {
			"@id": "ex:lang"
		}
	},
	"sh:propertyValidator": {
		"@type": "sh:SPARQLSelectValidator",
		"sh:message": "Values are literals with language \"{?lang}\"",
		"sh:select": "\n\t\t\tSELECT DISTINCT $this ?value\n\t\t\tWHERE {\n\t\t\t\t$this $PATH ?value .\n\t\t\t\tFILTER (!isLiteral(?value) || !langMatches(lang(?value), $lang))\n\t\t\t}\n\t\t\t"
	}
}</pre>
								</div>
							</div>
						</aside>
						<p>
							Once a constraint component has been declared (in a <a>shapes graph</a>), its parameters can be used as illustrated in the following example.
						</p>
						<aside class="example" title="Shape declaration using ex:LanguageConstraintComponent">
							<div class="shapes-graph">
								<div class="turtle">
ex:LanguageExampleShape
	a sh:NodeShape ;
	<span class="target-can-be-skipped">sh:targetClass ex:Country ;</span>
	sh:property [
		sh:path ex:germanLabel ;
		ex:lang "de" ;
	] ;
	sh:property [
		sh:path ex:englishLabel ;
		ex:lang "en" ;
	] .
								</div>
								<div class="jsonld">
									<pre class="jsonld">{
	"@id": "ex:LanguageExampleShape",
	"@type": "sh:NodeShape",
	"sh:property": [
		{
			"ex:lang": "de",
			"sh:path": {
				"@id": "ex:germanLabel"
			}
		},
		{
			"ex:lang": "en",
			"sh:path": {
				"@id": "ex:englishLabel"
			}
		}
	],
	"sh:targetClass": {
		"@id": "ex:Country"
	}
}</pre>
								</div>
							</div>
						</aside>
						<p>
							The example shape above specifies the condition that all values of <code>ex:germanLabel</code> carry the language tag <code>de</code>
							while all values of <code>ex:englishLabel</code> have <code>en</code> as their language.
							These details are specified via two property shapes that have values for the <code>ex:lang</code> parameter required by the constraint component.
						</p>
					</section>
					<section id="SPARQLAskValidator">
						<h5>ASK-based Validators</h5>
						<p>
							Many constraint components are of the form in which all <a>value nodes</a> are tested individually against some boolean condition.
							Writing SELECT queries for these becomes burdensome, especially if a constraint component can be
							used for both <a>property shapes</a> and <a>node shapes</a>.
							SHACL-SPARQL provides an alternative, more compact syntax for validators based on ASK queries.
						</p>
						<p class="syntax">
							<a>Validators</a> with <a>SHACL type</a> <code>sh:SPARQLAskValidator</code> are called <dfn>ASK-based validators</dfn>.
							<span data-syntax-rule="validator-class">The values of <code>sh:validator</code> must be <a>ASK-based validators</a>.</span>
							<span data-syntax-rule="ask-count"><a>ASK-based validators</a> have exactly one value for the property <code>sh:ask</code></span>.
							<span data-syntax-rule="ask-datatype">The value of <code>sh:ask</code> must be a literal with datatype <code>xsd:string</code>.</span>
							<span data-syntax-rule="ask-sparql">The value of <code>sh:ask</code> must be a valid SPARQL ASK query using the aforementioned <a href="#sparql-prefixes">prefix handling rules</a>.</span>
						</p>
						<p><em>The remainder of this section is informative.</em></p>
						<p>
							The ASK queries return <code>true</code> if and only if a given <a>value node</a>
							(represented by the pre-bound variable <code>value</code>) conforms to the constraint.
						</p>
						<p>
							The following example declares a constraint component using an ASK query.
						</p>
						<aside class="example" title="Constraint component based on SPARQL">
							<div class="shapes-graph">
								<div class="turtle">
ex:LanguageConstraintComponentUsingASK
	a sh:ConstraintComponent ;
	rdfs:label "Language constraint component" ;
	sh:parameter [
		sh:path ex:lang ;
		sh:datatype xsd:string ;
		sh:minLength 2 ;
		sh:name "language" ;
		sh:description "The language tag, e.g. \"de\"." ;
	] ;
	sh:labelTemplate "Values are literals with language \"{$lang}\"" ;
	sh:validator ex:hasLang .
	
ex:hasLang
	a sh:SPARQLAskValidator ;
	sh:message "Values are literals with language \"{$lang}\"" ;
	sh:ask """
		ASK {
			FILTER (isLiteral($value) &amp;&amp; langMatches(lang($value), $lang))
		}
		""" .
								</div>
								<div class="jsonld">
									<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:hasLang",
			"@type": "sh:SPARQLAskValidator",
			"sh:ask": "\n\t\tASK {\n\t\t\tFILTER (isLiteral($value) && langMatches(lang($value), $lang))\n\t\t}\n\t\t",
			"sh:message": "Values are literals with language \"{$lang}\""
		},
		{
			"@id": "ex:LanguageConstraintComponentUsingASK",
			"@type": "sh:ConstraintComponent",
			"rdfs:label": "Language constraint component",
			"sh:labelTemplate": "Values are literals with language \"{$lang}\"",
			"sh:parameter": {
				"sh:datatype": {
					"@id": "xsd:string"
				},
				"sh:description": "The language tag, e.g. \"de\".",
				"sh:minLength": {
					"@type": "xsd:integer",
					"@value": "2"
				},
				"sh:name": "language",
				"sh:path": {
					"@id": "ex:lang"
				}
			},
			"sh:validator": {
				"@id": "ex:hasLang"
			}
		}
	]
}</pre>
								</div>
							</div>
						</aside>
						<p>
							Note that the validation condition implemented by an ASK query is "in the inverse direction" from its SELECT counterpart:
							ASK queries return <code>true</code> for value nodes that conform to the constraint, while SELECT queries return those value nodes that do not conform.
						</p>
					</section>
				</section>
			</section>
			<section id="constraint-components-validation">
				<h3>Validation with SPARQL-based Constraint Components</h3>
				<p>
					This section defines the <a>validator</a> of <a>SPARQL-based constraint components</a>.
					Note that this validator only explains one possible implementation strategy, and
					SHACL processors may choose alternative approaches as long as the outcome is equivalent.
				</p>
				<p>
					As the first step, a <a>validator</a> MUST be selected based on the rules outlined
					in <a href="#constraint-components-validators"></a>.
					Then the following rules apply, producing a set of <a>solutions</a> of SPARQL queries:
				</p>
				<ul>
					<li>
						For <a>ASK-based validators</a>: 
						For each <a>value node</a> <code>v</code> where the SPARQL ASK query returns <code>false</code>
						with <code>v</code> <a>pre-bound</a> to the variable <code>value</code>,
						create one <a>solution</a> consisting of the bindings
						(<code>$this</code>, <a>focus node</a>) and (<code>$value</code>, <code>v</code>).
						Let <code>QS</code> be a list of these <a>solutions</a>.
					</li>
					<li>
						For <a>SELECT-based validators</a>:
						If the <a>shape</a> is a <a>property shape</a>, then prior to execution
						<a>substitute</a> the variable <code>PATH</code> where it appears in the <a>predicate</a>
						position of a <a data-cite="sparql12-query/#QSynTriples">triple pattern</a>
						with a valid SPARQL surface syntax string of the <a>SHACL property path</a>
						specified via <code>sh:path</code> at the <a>property shape</a>.
						Let <code>QS</code> be the <a>solutions</a> produced by executing the SPARQL query.
					</li>
				</ul>
				<p>
					The SPARQL query executions above MUST <a>pre-bind</a> the variable
					<code>this</code> as described in <a href="#sparql-constraints-prebound"></a>.
					In addition, each <a>value</a> of a <a>parameter</a> of the <a>constraint component</a> in the <a>constraint</a>
					MUST be <a>pre-bound</a> as a variable that has the <a>parameter name</a> as its name.
				</p>
				<p>
					The production rules for the validation results are identical to those for <a href="#sparql-constraints-validation-rule">SPARQL-based constraints</a>,
					using the <a>solutions</a> <code>QS</code> as produced above.
				</p>
			</section>
		</section>
				
		<section id="sparql-constraints-annotations">
			<h2>Annotation Properties</h2>
			<p>
				This section extends the general <a href="#sparql-constraints-variables">mechanism</a>
				to produce validation results using <a href="sparql-constraints">SPARQL-based constraints</a> or
				<a href="sparql-constraint-components">constraint components</a>.
			</p>
			<p>
				Implementations that support this feature make it possible to inject <dfn>annotation properties</dfn>
				into the validation result nodes created for each <a>solution</a> produced by the <code>SELECT</code> queries of a
				SPARQL-based <a>constraint</a> or <a>constraint component</a>.
				Any such annotation property needs to be declared via a <a>value</a> of <code>sh:resultAnnotation</code> at
				the <a>subject</a> of the <code>sh:select</code> or <code>sh:ask</code> <a>triple</a>.
			</p>
			<p class="syntax">
				<span data-syntax-rule="resultAnnotation-nodeKind">The <a>values</a> of <code>sh:resultAnnotation</code> are
				called <dfn data-lt="result annotation">result annotations</dfn> and are either <a>IRIs</a> or <a>blank nodes</a></span>.
			</p>
			<p>
				<a>Result annotations</a> have the following properties:
			</p>
			<table class="term-table">
				<tr>
					<th>Property</th>
					<th>Summary and Syntax Rules</th>
				</tr>
				<tr>
					<td><code>sh:annotationProperty</code></td>
					<td>
						The property that shall be set.
						<span data-syntax-rule="annotationProperty">Each <a>result annotation</a> has exactly one <a>value</a>
						for the property <code>sh:annotationProperty</code> and this value is an <a>IRI</a>.</span>
					</td>
				</tr>
				<tr>
					<td><code>sh:annotationVarName</code></td>
					<td>
						The name of the SPARQL variable to take the annotation values from.
						<span data-syntax-rule="annotationVarName">Each <a>result annotation</a> has at most 1 <a>value</a>
						for the property <code>sh:annotationVarName</code> and this <a>value</a> is <a>literal</a> with
						<a>datatype</a> <code>xsd:string</code>.</span>
					</td>
				</tr>
				<tr>
					<td><code>sh:annotationValue</code></td>
					<td>
						Constant <a>RDF terms</a> that shall be used as default values.
					</td>
				</tr>
			</table>
			<p>
				For each <a>solution</a> of a <code>SELECT</code> result set, a SHACL processor that supports annotations
				walks through the declared result annotations.
				The mapping from result annotations to SPARQL variables uses the following rules:
			</p>
			<ol>
				<li>Use the <a>value</a> of the property <code>sh:annotationVarName</code></li>
				<li>If no such <a>value</a> exists, use the <a>local name</a> of the <a>value</a> of <code>sh:annotationProperty</code> 
				as the variable name.</li>
			</ol>
			<p>
				If a variable name could be determined, then the SHACL processor copies the <a>binding</a> for the given variable
				as a value for the property specified using <code>sh:annotationProperty</code> 
				into the validation result that is being produced for the current <a>solution</a>.
				If the variable has no <a>binding</a> in the result set <a>solution</a>,
				then the <a>values</a> of <code>sh:annotationValue</code> are used, if present.
			</p>
			<p>
				Here is an example illustrating the use of result annotations.
			</p>
			<pre class="example-shapes">
ex:AnnotationExample
	a sh:NodeShape ;
	sh:targetNode ex:ExampleResource ;
	sh:sparql [   # _:b1
		sh:resultAnnotation [
			sh:annotationProperty ex:time ;
			sh:annotationVarName "time" ;
		] ;
		sh:select """
			SELECT $this ?message ?time
			WHERE {
				BIND (CONCAT("The ", "message.") AS ?message) .
				BIND (NOW() AS ?time) .
			}
			""" ;
	] .</pre>
			<p>
				Validation produces the following validation report:
			</p>
			<pre class="example-results">
[	a sh:ValidationReport ;
	sh:conforms false ;
	sh:result [
		a sh:ValidationResult ;
		sh:focusNode ex:ExampleResource ;
		sh:resultMessage "The message." ;
		sh:resultSeverity sh:Violation ;
		sh:sourceConstraint _:b1 ;
		sh:sourceConstraintComponent sh:SPARQLConstraintComponent ;
		sh:sourceShape ex:AnnotationExample ;
		ex:time "2015-03-27T10:58:00"^^xsd:dateTime ;  # Example
	]
] .</pre>
		</section>

		<section id="sparql-node-expressions">
			<h2>SPARQL-based Node Expressions</h2>
			<p>
				This section introduces <a>node expression functions</a> based on SPARQL.
			</p>

			<section id="SelectExpression">
				<h3>Select Expressions</h3>
				<p>
					A <a>node expression</a> that has a <a>value</a> for <code>sh:select</code> is called a <dfn>select expression</dfn> with the <a>function name</a>
					<code>sh:SelectExpression</code>.
				</p>
				<p class="syntax">
					<span data-syntax-rule="SelectExpression-syntax">A node in an RDF graph is a <a>well-formed</a> <a>select expression</a> if it is a <a>blank node</a>
					that has exactly one <a>value</a> for the <a>predicate</a> <code>sh:select</code>
					and this <a>value</a> is a <a>literal</a> with <a>datatype</a> <code>xsd:string</code>.</span>
					<span data-syntax-rule="SelectExpression-syntax-prefixes">A <a>well-formed</a> <a>select expression</a> can have at most one <a>value</a> for the property
					<code>sh:prefixes</code> and this value can only be an <a>IRI</a> or a <a>blank node</a>.</span><br/><br/>
					<span data-syntax-rule="SelectExpression-query-valid">Using the <a href="#sparql-prefixes">prefix handling rules</a>, the value of <code>sh:select</code> is a valid SPARQL 1.2 SELECT query.</span>
					<span data-syntax-rule="SelectExpression-query-output-nodes">The SPARQL query derived from the value of <code>sh:select</code> <a data-cite="sparql12-query/#selectproject">projects</a> exactly one variable in the SELECT clause.</span>
				</p>
				<div class="def" id="SelectExpression-evaluation">
					<div class="def-header">EVALUATION OF SELECT EXPRESSIONS</div>
					<p>
						The <a>output nodes</a> of a <a>select expression</a> are the list <code>resultNodes</code> consisting of exactly the bindings of the (only)
						variable that is projected from the <code>SELECT</code> clause when the query is evaluated against the <a>focus graph</a>.
						The value of <code>focusNode</code> is <a>pre-bound</a> as the value of the SPARQL variable <code>this</code>.
						The value of each scope variable is <a>pre-bound</a> as a SPARQL variable with the same name and value.
						A <a>failure</a> is produced when one of the scope variables is called <code>this</code>.
						<br/>
						<br/>
						<code>evalExpr(expr, focusGraph, focusNode, scope) -> resultNodes</code>
					</p>
				</div>
				<p><em>The remainder of this section is informative.</em></p>
				<aside class="example" title="A dynamically computed property using a node expression based on a SPARQL query">
					<p>
						Here is an example use of a <a>select expression</a>, computing the values of a property shape for the property 
						"full name" as the concatenation of the <code>ex:firstName</code>, a space, and the <code>ex:lastName</code>.
					</p>
					<div class="shapes-graph">
						<div class="turtle">
ex:Person-fullName
	a sh:PropertyShape ;
	sh:name "full name" ;
	sh:path ex:fullName ;
	sh:values <b>[
		sh:prefixes &lt;http://example.org/ns&gt; ;
		sh:select """
			SELECT ?fullName
			WHERE {
				$this ex:firstName ?firstName .
				$this ex:lastName ?lastName .
				BIND (CONCAT(?firstName, " ", ?lastName) AS ?fullName) .
			}
		"""
	]</b> ;
	sh:datatype xsd:string .

&lt;http://example.org/ns&gt;
	a owl:Ontology ;
	sh:declare [
		sh:prefix "ex" ;
		sh:namespace "http://example.org/ns#"^^xsd:anyURI ;
	] .
						</div>
						<div class="jsonld">
							<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:Person-fullName",
			"@type": "sh:PropertyShape",
			"sh:datatype": {
				"@id": "xsd:string"
			},
			"sh:name": "full name",
			"sh:path": {
				"@id": "ex:fullName"
			},
			"sh:values": {
				"sh:prefixes": {
					"@id": "http://example.org/ns"
				},
				"sh:select": "\n\t\t\tSELECT ?fullName\n\t\t\tWHERE {\n\t\t\t\t$this ex:firstName ?firstName .\n\t\t\t\t$this ex:lastName ?lastName .\n\t\t\t\tBIND (CONCAT(?firstName, \" \", ?lastName) AS ?fullName) .\n\t\t\t}\n\t\t"
			}
		},
		{
			"@id": "http://example.org/ns",
			"@type": "owl:Ontology",
			"sh:declare": {
				"sh:namespace": {
					"@type": "xsd:anyURI",
					"@value": "http://example.org/ns#"
				},
				"sh:prefix": "ex"
			}
		}
	]
}</pre>
						</div>
					</div>
					<p>
						This example also illustrates the use of <code>sh:prefixes</code> to insert PREFIX declarations into the beginning of the query before parsing.
						Note that the query is executed with the current <a>focus node</a> <a>pre-bound</a> to the variable <code>this</code>.
					</p>
				</aside>
				<aside class="example" title="Dynamically computed target nodes using a node expression based on a SPARQL query">
					<p>
						Here is an example use of a <a>select expression</a>, computing the target nodes of a shape to consist of all instances of
						<code>ex:Person</code> where the <code>ex:age</code> is less than <code>18</code>.
					</p>
					<div class="shapes-graph">
						<div class="turtle">
ex:ChildShape
	a sh:NodeShape ;
	rdfs:label "Child shape" ;
	rdfs:comment "This shape applies to all persons under 18 years of age." ;
	sh:targetNode <b>[
		sh:select """
			PREFIX ex: &lt;http://example.org/ns#&gt;
			SELECT ?person
			WHERE {
				?person a/rdfs:subClassOf* ex:Person .
				?person ex:age ?age .
				FILTER (?age &lt; 18) .
			}
		"""
	]</b> .
						</div>
						<div class="jsonld">
							<pre class="jsonld">{
	"@id": "ex:ChildShape",
	"@type": "sh:NodeShape",
	"rdfs:comment": "This shape applies to all persons under 18 years of age.",
	"rdfs:label": "Child shape",
	"sh:targetNode": {
		"sh:select": "\n\t\t\tPREFIX ex: &lt;http://example.org/ns#&gt;\n\t\t\tSELECT ?person\n\t\t\tWHERE {\n\t\t\t\t?person a/rdfs:subClassOf* ex:Person .\n\t\t\t\t?person ex:age ?age .\n\t\t\t\tFILTER (?age &lt; 18) .\n\t\t\t}\n\t\t"
	}
}</pre>
						</div>
					</div>
					<p>
						From the following data graph, only <code>ex:Benjamin</code> is a target node.
					</p>
					<div class="data-graph">
						<div class="turtle">
<span class="focus-node-selected">ex:Benjamin</span>
	a ex:Person ;
	ex:age 17 .

ex:Klaus
	a ex:Person ;
	ex:age 48 .

ex:Bernd
	a ex:Person .
						</div>
						<div class="jsonld">
							<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:Benjamin",
			"@type": "ex:Person",
			"ex:age": {
				"@type": "xsd:integer",
				"@value": "17"
			}
		},
		{
			"@id": "ex:Bernd",
			"@type": "ex:Person"
		},
		{
			"@id": "ex:Klaus",
			"@type": "ex:Person",
			"ex:age": {
				"@type": "xsd:integer",
				"@value": "48"
			}
		}
	]
}</pre>
						</div>
					</div>
				</aside>
			</section>

			<section id="SPARQLExprExpression">
				<h3>SPARQL Expr Expressions</h3>
				<p>
					A <a>node expression</a> that has a <a>value</a> for <code>sh:sparqlExpr</code> is called a <dfn>SPARQL expr expression</dfn> with the <a>function name</a>
					<code>sh:SPARQLExprExpression</code>.
				</p>
				<p class="syntax">
					<span data-syntax-rule="SPARQLExprExpression-syntax-eval">A node in an RDF graph
					is a <a>well-formed</a> <a>SPARQL expr expression</a> if it is a <a>blank node</a>
					that has exactly one <a>value</a> for the <a>predicate</a> <code>sh:sparqlExpr</code>
					and that <a>value</a> is a <a>literal</a> with <a>datatype</a> <code>xsd:string</code>.</span>
					<span data-syntax-rule="SPARQLExprExpression-syntax-prefixes">A <a>well-formed</a> <a>SPARQL expr expression</a> can have at most one <a>value</a> for the property
					<code>sh:prefixes</code> and this value is an <a>IRI</a> or a <a>blank node</a>.</span><br/><br/>
					<span data-syntax-rule="SPARQLExprExpression-template">Let <code>$EXPR$</code> be the <a>value</a> of <code>sh:eval</code> and <code>$PREFIXES$</code>
					be the SPARQL prefixes block resulting from the <a href="#sparql-prefixes">prefix handling rules</a> using the value of <code>sh:prefixes</code>;
					then <code>select</code> is defined as the string where <code>$EXPR$</code> and <code>$PREFIXES$</code> are inserted as into <br/><br/><code>$PREFIXES$ SELECT ($EXPR$ AS ?result) WHERE {}</code><br/><br/></span>
					<span data-syntax-rule="SPARQLExprExpression-query-valid"><code>select</code> is a valid SPARQL 1.2 SELECT query.</span>
				</p>
				<div class="def" id="SPARQLExprExpression-evaluation">
					<div class="def-header">EVALUATION OF SPARQL EXPR EXPRESSIONS</div>
					<p>
						The <a>output nodes</a> of an <a>SPARQL expr expression</a> are the list <code>resultNodes</code> consisting of exactly the bindings of the (only)
						variable that is projected from the <code>SELECT</code> clause of the <code>select</code> query as defined <a href="#syntax-rule-SPARQLExprExpression-template">above</a>
						when the query is evaluated against the <a>focus graph</a>.
						The value of <code>focusNode</code> is <a>pre-bound</a> as the value of the SPARQL variable <code>this</code>.
						The value of each scope variable is <a>pre-bound</a> as a SPARQL variable with the same name and value.
						A <a>failure</a> is produced when one of the scope variables is called <code>this</code>.
						<br/>
						<br/>
						<code>evalExpr(expr, focusGraph, focusNode, scope) -> resultNodes</code>
					</p>
				</div>
				<p><em>The remainder of this section is informative.</em></p>
				<aside class="example" title="A dynamically computed property using a SPARQL expr expression">
					<p>
						Here is an example use of an <a>SPARQL expr expression</a>, computing the values of a property shape for the property 
						"uri length" as the length of the IRI of the focus node.
					</p>
					<div class="shapes-graph">
						<div class="turtle">
ex:Resource-uriLength
	a sh:PropertyShape ;
	sh:name "uri length" ;
	sh:path ex:uriLength ;
	sh:values <b>[
		sh:sparqlExpr "STRLEN(STR($this))" ;
	]</b> ;
	sh:datatype xsd:integer .
						</div>
						<div class="jsonld">
							<pre class="jsonld">{
	"@id": "ex:Resource-uriLength",
	"@type": "sh:PropertyShape",
	"sh:datatype": {
		"@id": "xsd:integer"
	},
	"sh:name": "uri length",
	"sh:path": {
		"@id": "ex:uriLength"
	},
	"sh:values": {
		"sh:sparqlExpr": "STRLEN(STR($this))"
	}
}</pre>
						</div>
					</div>
					<p>
						When applied to a focus node with URI <code>http://example.org/ns#Test</code> the result will be <code>26</code>.
						This produces the same results as this variation:
					</p>
					<div class="shapes-graph">
						<div class="turtle">
ex:Resource-uriLength
	a sh:PropertyShape ;
	sh:name "uri length" ;
	sh:path ex:uriLength ;
	sh:values <b>[
		sh:select """
			SELECT (STRLEN(STR($this)) AS ?result)
			WHERE {
			}
		""" ;
	]</b> ;
	sh:datatype xsd:integer .
						</div>
						<div class="jsonld">
							<pre class="jsonld">{
	"@id": "ex:Resource-uriLength",
	"@type": "sh:PropertyShape",
	"sh:datatype": {
		"@id": "xsd:integer"
	},
	"sh:name": "uri length",
	"sh:path": {
		"@id": "ex:uriLength"
	},
	"sh:values": {
		"sh:select": "\n\t\t\tSELECT (STRLEN(STR($this)) AS ?result)\n\t\t\tWHERE {\n\t\t\t}\n\t\t"
	}
}</pre>
						</div>
					</div>
					<p>
						Note that the query is executed with the current <a>focus node</a> <a>pre-bound</a> to the variable <code>this</code>.
					</p>
				</aside>
			</section>
		</section>
		
		<div style="padding-top: 30px">
			<h1 id="appendix" style="font-size: 160%; font-weight: bold">Appendix</h1>
		</div>

		<section id="pre-binding" class="appendix">
			<h2>Pre-binding of Variables in SPARQL Queries</h2>
			<p>
				Some features of SHACL-SPARQL rely on the concept of <a>pre-binding of variables</a> as defined in this section.
			</p>
			<div class="syntax" data-syntax-rule="pre-binding-limitations">
				<p>
					The definition of pre-binding used by SHACL requires the following restrictions on SPARQL queries.
					SHACL-SPARQL processors MUST report a <a>failure</a> when it is operating on a <a>shapes graph</a>
					that contains SHACL-SPARQL queries (via <code>sh:select</code> and <code>sh:ask</code>) that violate any of these restrictions.
					Note that the term <em>potentially pre-bound variables</em> includes the variables <code>this</code>,
					<code>value</code> (for ASK queries),
					and any variables that represent the <a>parameters</a> of the <a>constraint component</a> that uses the query.
					<!-- This is so that the checking can be performed once, not required each time. -->
				</p>
				<ul>
					<li>SPARQL queries must not contain a <code>MINUS</code> clause</li>
					<li>SPARQL queries must not contain a federated query (<code>SERVICE</code>)</li>
					<li>SPARQL queries must not contain a <code>VALUES</code> clause that mentions any potentially pre-bound variable</li>
					<li>SPARQL queries must not use the syntax form ​​<code>AS ?var</code> for any potentially pre-bound variable</li>
				</ul>
			</div>

			<div class="def def-text">
				<div class="def-header">DEFINITION: <dfn>Values Insertion</dfn></div>
				<div class="def-text-body">
					<p>
						For solution mapping <code>μ</code>, define <code>Table(μ)</code> to be the multiset formed from <code>μ</code>.
					</p>
					<p>
						&nbsp;&nbsp;&nbsp;<code>Table(μ) = { μ }</code><br/>
						&nbsp;&nbsp;&nbsp;<code>Card[μ] = 1</code>
					</p>
					<p>
						Define the <em>Values Insertion</em> function <code>Replace(X, μ)</code> to
						replace each occurence <code>Y</code> of a 
						<a data-cite="sparql12-query/#sparqlTranslateBasicGraphPatterns">Basic Graph Pattern</a>,
						<a data-cite="sparql12-query/#sparqlTranslatePathExpressions">Property Path Expression</a>,
						<a data-cite="sparql12-query/#sparqlTranslateGraphPatterns"><code>Graph(Var, pattern)</code></a>
						in <code>X</code> with <code>join(Y, Table(μ))</code>.
					</p>
				</div>
			</div>

			<div class="def def-text">
				<div class="def-header">DEFINITION: <dfn data-lt="pre-binding|pre-bind|pre-bound|pre-bound variables|pre-binds">Pre-binding of variables</dfn></div>
				<div class="def-text-body">
					<p>
						The evaluation of the <a data-cite="sparql12-query/#idp2427544">SPARQL Query</a>
						<code>Q = (E, DS, QF)</code> with <em>pre-bound</em> variables <code>μ</code>
						is defined as the evaluation of SPARQL query <code>Q' = (Replace(E, μ), DS, QF)</code>.
					</p>
				</div>
			</div>

		</section>
		
		<section id="syntax-rules" class="appendix">
			<h2>Summary of SHACL Syntax Rules</h2>
			<p>
				This section enumerates all normative syntax rules of SHACL.
				This section is automatically generated from other parts of this spec and hyperlinks are provided back
				into the prose if the context of the rule in unclear. 
				Nodes that violate these rules in a <a>shapes graph</a> are <a>ill-formed</a>.
			</p>
			<table class="term-table" id="syntax-rules-table">
				<tr>
					<th>Syntax Rule Id</th>
					<th>Syntax Rule Text</th>
				</tr>
			</table>
		</section>
		
		<section id="sparql-definitions-core" class="appendix informative">
			<h2>Potential SPARQL Definitions of SHACL Core Constraint Validators</h2>
			<p>
				This appendix uses parts of SPARQL 1.2 in non-normative alternative definitions of the semantics of <a>constraint components</a> and <a>targets</a>
				from [[shacl12-core]].
				While these may help some implementers, SPARQL is not required for the implementation of the SHACL Core language.
			</p>
			<p>
				SPARQL variables using the <code>$</code> marker represent external <a>bindings</a> that are <a>pre-bound</a> or, in the case of <code>$PATH</code>, <a>substituted</a> in the SPARQL query before execution (as explained in <a href="#constraint-components-validation"></a>).
				<span class="todo">TODO: Assuming SHACL Core 1.2 allows node expressions as constraint parameters, explain that they are evaluated prior to substitution.</span>
			</p>
			<section id="sparql-definition-targetClass">
				<h3>sh:targetClass</h3>
				<p class="def-sparql">
					The following query expresses a potential definition of <a data-cite="shacl12-core#targetClass">class targets</a> in SPARQL.
					The variable <code>targetClass</code> will be <a>pre-bound</a> to the given value of <code>sh:targetClass</code>.
					All <a>bindings</a> of the variable <code>this</code> from the <a>solutions</a> become focus nodes.
				</p>
				<div class="def def-sparql">
					<div class="def-header">POTENTIAL DEFINITION IN SPARQL</div>
<pre class="def-sparql-body">
SELECT DISTINCT ?this    <span class="triple-can-be-skipped"># ?this is the focus node</span>
WHERE {
	?this rdf:type/rdfs:subClassOf* $targetClass .
}</pre>
				</div>
			</section>
			<section id="sparql-definition-targetSubjectsOf">
				<h3>sh:targetSubjectsOf</h3>
				<p class="def-sparql">
					The following query expresses a potential definition of <a data-cite="shacl12-core#targetSubjectsOf">subjects-of targets</a> in SPARQL.
					The variable <code>targetSubjectsOf</code> will be <a>pre-bound</a> to the given value of <code>sh:targetSubjectsOf</code>.
					All <a>bindings</a> of the variable <code>this</code> from the <a>solutions</a> become focus nodes.
				</p>
				<div class="def def-sparql">
					<div class="def-header">POTENTIAL DEFINITION IN SPARQL</div>
<pre class="def-sparql-body">
SELECT DISTINCT ?this    <span class="triple-can-be-skipped"># ?this is the focus node</span>
WHERE {
	?this $targetSubjectsOf ?any .
}</pre>
				</div>
			</section>
			<section id="sparql-definition-targetObjectsOf">
				<h3>sh:targetObjectsOf</h3>	
				<p class="def-sparql">
					The following query expresses a potential definition of <a data-cite="shacl12-core#targetObjectsOf">objects-of targets</a> in SPARQL.
					The variable <code>targetObjectsOf</code> will be <a>pre-bound</a> to the given value of <code>sh:targetObjectsOf</code>.
					All <a>bindings</a> of the variable <code>this</code> from the <a>solutions</a> become focus nodes.
				</p>
				<div class="def def-sparql">
					<div class="def-header">POTENTIAL DEFINITION IN SPARQL</div>
<pre class="def-sparql-body">
SELECT DISTINCT ?this    <span class="triple-can-be-skipped"># ?this is the focus node</span>
WHERE {
	?any $targetObjectsOf ?this .
}</pre>
				</div>
			</section>
			<section id="sparql-definition-class">
				<h3>sh:class</h3>
				<p class="def-sparql">
					The following query expresses a potential SPARQL-based validator for <a data-cite="shacl12-core#ClassConstraintComponent">sh:class</a>.
				</p>
				<div class="def def-sparql">
					<div class="def-header">POTENTIAL DEFINITION IN SPARQL (Must evaluate to true for each value node $value)</div>
<pre class="def-sparql-body">
ASK {
	$value rdf:type/rdfs:subClassOf* $class .
}</pre>
				</div>
			</section>
			<section id="sparql-definition-nodeKind">
				<h3>sh:nodeKind</h3>
				<p class="def-sparql">
					The following query expresses a potential SPARQL-based validator for <a data-cite="shacl12-core#NodeKindConstraintComponent">sh:nodeKind</a>.
				</p>
				<div class="def def-sparql">
					<div class="def-header">POTENTIAL DEFINITION IN SPARQL (Must evaluate to true for each value node $value)</div>
<pre class="def-sparql-body">
ASK {
	FILTER ((isIRI($value) &amp;&amp; $nodeKind IN ( sh:IRI, sh:BlankNodeOrIRI, sh:IRIOrLiteral ) ) ||
		(isLiteral($value) &amp;&amp; $nodeKind IN ( sh:Literal, sh:BlankNodeOrLiteral, sh:IRIOrLiteral ) ) ||
		(isBlank($value)   &amp;&amp; $nodeKind IN ( sh:BlankNode, sh:BlankNodeOrIRI, sh:BlankNodeOrLiteral ) )) .
}</pre>
				</div>
			</section>
			<section id="sparql-definition-minExclusive">
				<h3>sh:minExclusive (etc)</h3>
				<p>
					The following query expresses a potential SPARQL-based validator for <a data-cite="shacl12-core#MinExclusiveConstraintComponent">sh:minExclusive</a>.
					The SPARQL expression produces an error if the value node cannot be compared to the specified range,
					for example when someone compares a string with an integer.
					If the comparison cannot be performed, then there is a validation result.
					This is different from, say, a plain SPARQL query, in which such errors would silently not lead to any results.
				</p>
				<div class="def def-sparql">
					<div class="def-header">POTENTIAL DEFINITION IN SPARQL (Must evaluate to true for each value node $value)</div>
<pre class="def-sparql-body">
ASK {
	FILTER ($minExclusive &lt; $value)
}</pre>
				</div>
				<p>
					Similar definitions are possible for:
				</p>
				<ul>
					<li><a data-cite="shacl12-core#MinInclusiveConstraintComponent">sh:minInclusive</a>: &lt;=</li>
					<li><a data-cite="shacl12-core#MaxExclusiveConstraintComponent">sh:maxExclusive</a>: &gt;</li>
					<li><a data-cite="shacl12-core#MaxInclusiveConstraintComponent">sh:maxInclusive</a>: &gt;=</li>
				</ul>
			</section>
			<section id="sparql-definition-minLength">
				<h3>sh:minLength</h3>
				<p>
					The following query expresses a potential SPARQL-based validator for <a data-cite="shacl12-core#MinLengthConstraintComponent">sh:minLength</a>.
				</p>
				<div class="def def-sparql">
					<div class="def-header">POTENTIAL DEFINITION IN SPARQL (Must evaluate to true for each value node $value)</div>
<pre class="def-sparql-body">
ASK {
	FILTER (STRLEN(str($value)) >= $minLength) .
}</pre>
				</div>
			</section>
			<section id="sparql-definition-maxLength">
				<h3>sh:maxLength</h3>
				<p>
					The following query expresses a potential SPARQL-based validator for <a data-cite="shacl12-core#MaxLengthConstraintComponent">sh:maxLength</a>.
				</p>
				<div class="def def-sparql">
					<div class="def-header">POTENTIAL DEFINITION IN SPARQL (Must evaluate to true for each value node $value)</div>
<pre class="def-sparql-body">
ASK {
	FILTER (STRLEN(str($value)) &lt;= $maxLength) .
}</pre>
				</div>
			</section>
			<section id="sparql-definition-pattern">
				<h3>sh:pattern</h3>
				<p>
					The following query expresses a potential SPARQL-based validator for <a data-cite="shacl12-core#PatternConstraintComponent">sh:pattern</a>.
				</p>
				<div class="def def-sparql">
					<div class="def-header">POTENTIAL DEFINITION IN SPARQL (Must evaluate to true for each value node $value)</div>
<pre class="def-sparql-body">
ASK {
	FILTER (!isBlank($value) &amp;&amp; IF(bound($flags), regex(str($value), $pattern, $flags), regex(str($value), $pattern)))
}</pre>
				</div>
			</section>
			<section id="sparql-definition-disjoint">
				<h3>sh:disjoint</h3>
				<p>
					The following query expresses a potential SPARQL-based validator for <a data-cite="shacl12-core#DisjointConstraintComponent">sh:disjoint</a>.
				</p>
				<div class="def def-sparql">
					<div class="def-header">POTENTIAL DEFINITION IN SPARQL (Must return no results for the given $PATH)</div>
<pre class="def-sparql-body">
SELECT DISTINCT $this ?value
WHERE {
	$this $PATH ?value .
	$this $disjoint ?value .
}</pre>
				</div>
			</section>
			<section id="sparql-definition-lessThan">
				<h3>sh:lessThan</h3>
				<p>
					The following query expresses a potential SPARQL-based validator for <a data-cite="shacl12-core#LessThanConstraintComponent">sh:lessThan</a>.
				</p>
				<div class="def def-sparql">
					<div class="def-header">POTENTIAL DEFINITION IN SPARQL (Must return no results for the given $PATH)</div>
<pre class="def-sparql-body">
SELECT $this ?value
WHERE {
	$this $PATH ?value .
	$this $lessThan ?otherValue .
	BIND (?value &lt; ?otherValue AS ?result) .
	FILTER (!bound(?result) || !(?result)) .
}</pre>
				</div>
			</section>
			<section id="sparql-definition-lessThanOrEquals">
				<h3>sh:lessThanOrEquals</h3>
				<p>
					The following query expresses a potential SPARQL-based validator for <a data-cite="shacl12-core#LessThanConstraintComponent">sh:lessThanOrEquals</a>.
				</p>
				<div class="def def-sparql">
					<div class="def-header">POTENTIAL DEFINITION IN SPARQL (Must return no results for the given $PATH)</div>
<pre class="def-sparql-body">
SELECT $this ?value
WHERE {
	$this $PATH ?value .
	$this $lessThanOrEquals ?otherValue .
	BIND (?value &lt;= ?otherValue AS ?result) .
	FILTER (!bound(?result) || !(?result)) .
}</pre>
				</div>
			</section>
		</section>
		
		<section id="security" class="appendix informative">
			<h2>Security and Privacy Considerations</h2>
			<p>
				Like most RDF-based technologies, SHACL processors may operate on graphs that are combined
				from various sources.  Some applications may have an open "linked data" architecture and dynamically
				assemble RDF triples from sources that are outside of an organization's network of trust.
				Since RDF allows anyone to add statements about any resource, triples may modify the originally
				intended semantics of shape definitions or nodes in a data graph and thus lead to misleading results.
				Protection against this (and the following) scenario can be achieved by only using trusted
				and verified RDF sources and eliminating the possibility that graphs are dynamically added via
				<code>owl:imports</code> and <code>sh:shapesGraph</code>.
			</p>
			<p>
				SHACL-SPARQL includes all the <a data-cite="sparql12-query/#security">security issues of SPARQL</a>.
			</p>
		</section>
		
		<section id="ack" class="appendix informative">
			<h2>Acknowledgements</h2>
			<p>
				The original 1.0 version of SHACL was produced by the RDF Data Shapes Working Group.
				See its <a href="https://www.w3.org/TR/shacl/#ack">SHACL 1.0 Acknowledgements section</a>.
			</p>
		</section>

		<section class="appendix informative">
			<h2>Revision History</h2>
			  <p>
				  The detailed list of changes and their diffs can be found in the Git repository.
			  </p>
			  <ul>
				  <li><b>2024-02-14</b>: New work started by cloning the main SHACL spec and splitting it into SHACL Core and SHACL-SPARQL</li>
			  </ul>
		</section>

		<section class="appendix informative" id="changes-12">
			<h2>Changes between SHACL 1.0 SPARQL and SHACL 1.2 SPARQL Extensions</h2>
			<ul>
				<li>Added the <a>node expression function</a> <a href="#SelectExpression"><code>sh:SelectExpression</code></a>, see <a href="https://github.com/w3c/data-shapes/issues/288">Issue 288</a></li>
				<li>Added support for <a>annotation properties</a>, see <a href="https://github.com/w3c/data-shapes/issues/327">Issue 327</a></li>
				<li>Added the <a>node expression function</a> <a href="#SPARQLExprExpression"><code>sh:SPARQLExprExpression</code></a>, see <a href="https://github.com/w3c/data-shapes/issues/315">Issue 315</a></li>
				<li>Clarified that VALUES clauses are only disallowed when they mention <a href="#pre-binding">pre-bound variables</a> and removed the restriction on sub-SELECTs, see <a href="https://github.com/w3c/data-shapes/issues/159">Issue 159</a></li>
				<li>Removed support for the optional pre-bound variables <code>shapesGraph</code> and <code>currentShape</code>, see <a href="https://github.com/w3c/data-shapes/issues/426">Issue 426</a></li>
			</ul>
		</section>		
		  
	</body>

</html>
