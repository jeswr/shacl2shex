<!DOCTYPE html><html><head>
		<title>SHACL 1.2 Core</title>
		<meta charset="utf-8">
		<script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove" defer=""></script>
		<script class="remove">
		
			function prepareSyntaxRules() {
				document.querySelectorAll("[data-syntax-rule]").forEach(element => {
					let ruleId = element.getAttribute("data-syntax-rule");
					let tr = document.createElement("tr");
					tr.classList.add("syntax-rule-tr");
					let td1 = document.createElement("td");
					td1.classList.add("syntax-rule-id");
					let a = document.createElement("a");
					a.classList.add("syntax-rule-id-a");
					a.href = "#syntax-rule-" + ruleId;
					a.textContent = ruleId;
					td1.appendChild(a);
					let td2 = document.createElement("td");
					td2.innerHTML = element.innerHTML;
					tr.appendChild(td1);
					tr.appendChild(td2);

					// Replace <dfn> elements inside `tr` with <a> elements
					tr.querySelectorAll("dfn").forEach(dfn => {
    					let a = document.createElement("a");
    					a.textContent = dfn.textContent;
    					dfn.replaceWith(a);
					});

					document.getElementById("syntax-rules-table").appendChild(tr);
					element.setAttribute("id", "syntax-rule-" + ruleId);
				});
			}
		
			function prepareValidators() {
				document.querySelectorAll("[data-validator]").forEach(element => {
					let validatorId = element.getAttribute("data-validator") + "ConstraintComponent";
					let tr = document.createElement("tr");
					tr.classList.add("validator-tr");
					let td = document.createElement("td");
					tr.appendChild(td);
					let a = document.createElement("a");
					a.classList.add("validator-id-a");
					a.href = `#validator-${validatorId}`;
					a.textContent = `sh:${validatorId}`;
					td.appendChild(a);
					td.innerHTML += ": " + element.innerHTML;
					document.getElementById("validators-table").appendChild(tr);
					element.id = "validator-" + validatorId;
				});
			}

			document.addEventListener("DOMContentLoaded", () => {
				// Replace code div blocks in shapes, data, and results graph with tabs
				for (const graph of document.querySelectorAll(".shapes-graph, .data-graph, .results-graph")) {
					const tabs = document.createElement("aside");
					tabs.classList.add("ds-selector-tabs");
					graph.firstElementChild.classList.add("selected");

					for (const child of graph.children) {
						child.classList.add("tab");
					}

					tabs.append(...graph.children);
					graph.append(tabs)
				}

				// Generate buttons for the selection logic
				for (const tabs of document.querySelectorAll(".ds-selector-tabs")) {
					const selectors = document.createElement("div");
					selectors.classList.add("selectors");
					
					// Check if shaclc div exists in this tab group
					const hasShaclc = tabs.querySelector(".shaclc");
					
					selectors.innerHTML = `
						<button class="selected" data-selects="turtle">Turtle</button>
						<button data-selects="jsonld">JSON-LD</button>
						${hasShaclc ? '<button data-selects="shaclc">SHACL-C</button>' : ''}
					`

					tabs.prepend(selectors);
				}

				// Add example button selection logic
				for (const button of document.querySelectorAll(".ds-selector-tabs .selectors button")) {
					button.onclick = () => {
						const ex = button.closest(".ds-selector-tabs");
						ex.querySelector("button.selected").classList.remove("selected");
						ex.querySelector(".selected").classList.remove("selected");
						button.classList.add('selected');
						ex.querySelector("." + button.dataset.selects).classList.add("selected");
					}
				}
			});

			var respecConfig = {
				group: "wg/data-shapes",
				github: "w3c/data-shapes",
				edDraftURI: "https://w3c.github.io/data-shapes/shacl12-core/",
				specStatus: "ED",
				preProcess : [ prepareSyntaxRules, prepareValidators ],
				shortName:  "shacl12-core",
				subjectPrefix: "[shacl12-core]",
				editors: [
					{
						name:       "Holger Knublauch",
						company:    "TopQuadrant, Inc.",
						companyURL: "https://topquadrant.com/",
						mailto:     "holger@topquadrant.com",
						w3cid:      46500
					},
					{
						name:       "Thomas Bergwinkl",
						company:    "TopQuadrant, Inc.",
						companyURL: "https://www.topquadrant.com/",
						mailto:     "tbergwinkl@topquadrant.com",
						w3cid:      47803
					},
					{
						name:       "Yousouf Taghzouti",
						company:    "Inria",
						companyURL: "https://www.inria.fr/",
						mailto:     "yousouf.taghzouti@inria.fr",
						w3cid:      143054
					},
					{
						name:       "Jesse Wright",
						company:    "University of Oxford",
						companyURL: "https://www.cs.ox.ac.uk",
						mailto:     "jesse@jeswr.org",
						w3cid:      132252
					},
				],
				formerEditors: [
					{
						name:       "Dimitris Kontokostas",
						w3cid:      58399
					}
				],
				testSuiteURI: "https://w3c.github.io/data-shapes/data-shapes-test-suite/",

				lint: {
					"no-unused-dfns": false,  // This should be removed near the end of the process
  				},

				previousPublishDate: "2017-07-20",
				previousMaturity: "REC",
				prevRecShortname: "shacl",
				prevRecURI: "https://www.w3.org/TR/2017/REC-shacl-20170720/",

				wgPublicList: "public-shacl",

				localBiblio: {
					"shacl12-shacl-shacl": {
						title: "SHACL 1.2 SHACL-SHACL",
						href: "https://w3c.github.io/data-shapes/shacl12-shacl-shacl/",
						status: "ED",
						publisher: "W3C",
					}
				}
			};
		</script>
		<style>

			pre {
				tab-size: 3;
				-moz-tab-size: 3; /* Code for Firefox */
				-o-tab-size: 3; /* Code for Opera */
			}

			th {
				text-align: left;
			}
			table.rule { background-color: #EBEBE0; }
			table.rule td { text-align: center; }
			td.up { border-bottom:1px solid black; }
			
			td {
				vertical-align: top;
			}
			
			.algorithm {
				background: #fafafc;
				border-left-style: solid;
				border-left-width: .5em;
				border-color: #c0c0c0;
				margin-bottom: 16px;
				padding: 8px;
			}
			
			.arg {
				font-weight: bold;
				color: #000080;
			}

			.def {
				background: #fcfcfc;
				border-left-style: solid;
				border-left-width: .5em;
				border-color: #c0c0c0;
				margin-bottom: 16px;
			}
			
			.def-text {
			}
			
			.def-text-body {
			}
			
			.def-header {
				color: #a0a0a0;
				font-size: 16px;
				padding-bottom: 8px;
			}
			
			.diagram-class {
				border: 1px solid black; 
				border-radius: 4px; 
				width: 360px;
			}
			
			.diagram-class-name {
				font-size: 16px; 
				font-weight: bold; 
				text-align: center;
			}
			
			.diagram-class-properties {
				border-top: 1px solid black; 
			}
			
			.diagram-class-properties-start {
				padding: 8px;
			}
			
			.diagram-class-properties-section {
				border-top: 1px dashed #808080;
				padding: 8px;
			}

			.example {
				overflow-y: hidden !important;
			}
			
			.focus-node-selected {
				color: blue;
			}
			.focus-node-error {
				color: red;
			}

			.triple-can-be-skipped {
				color: grey;
			}
			.focus-node-error {
				color: red;
			}

			.target-can-be-skipped {
				color: darkslategray;
				font-style: italic;
			}
			
			.component-class {
				font-weight: bold;
				font-size: 16px;
			}
			
			.parameter-context {
				font-weight: bold;
				font-size: 16px;
			}
			
			.parameters {
				font-weight: bold;
				font-size: 16px;
			}

			.part-header {
				font-weight: bold;
			}
			
			.syntax {
				border-left-style: solid;
				border-left-width: .5em;
				border-color: #d0d0d0;
				margin-bottom: 16px;
				padding: .5em 1em;
				background-color: #f6f6f6;
			}
			
			.syntax-rule-id {
				padding-right: 10px;
			}
			
			.syntax-rule-id-a {
				white-space: nowrap;
			}
			
			.validator-id-a {
				font-weight: bold;
				white-space: nowrap;
			}
		
			.term {
				font-style: italic;
			}
			
			.term-def-header {
				font-style: italic;
				font-weight: bold;
			}
		
			.term-table {
				border-collapse: collapse;
				border-color: #000000;
				margin: 16px;
			}

			.term-table td, th {
				border-width: 1px;
				border-style: solid;
				padding: 5px;
			}
		
			.todo {
				color: red;
			}
			
			pre {
				word-wrap: normal;
			}

			.turtle {
				font-family: Menlo, Consolas, "DejaVu Sans Mono", Monaco, monospace;
				font-size: 14.4px;
				hyphens: none;
				overflow-x: auto;
				padding: .5em;
				tab-size: 3;
				-moz-tab-size: 3; /* Code for Firefox */
				-o-tab-size: 3; /* Code for Opera */
				text-align: start;
				margin-bottom: -1.5em;
				margin-top: -1.5em;
				white-space: pre;
			}

			.data-graph { 
				background: #eeb; 
				border: 1px solid #cc9;
				margin-top: 0.3em;
			}
			.data-graph:before { 
				color: #996; 
				content: "Data graph"; 
				padding-left: 0.4em;
			}
			
			.results-graph { 
				background: #edb; 
				border: 1px solid #bbb;
				margin-top: 0.3em;
			}
			.results-graph:before { 
				color: #997; 
				content: "Validation results"; 
				padding-left: 0.4em;
			}
			
			.shapes-graph { 
				background: #deb; 
				border: 1px solid #bbb;
				margin-top: 0.3em;
			}
			.shapes-graph:before { 
				color: #888; 
				content: "Shapes graph"; 
				padding-left: 0.4em;
			}

			/* no dark mode, keep colors for shapes-graph, data-graph, and results graph background */
			code.hljs {
				--base: transparent;
				--mono-1: #383a42;
			}

			/* our syntax menu for switching */
			div.syntaxmenu {
				border: 1px dotted black;
				padding:0.5em;
				margin: 1em; 
			}

			@media print {
				div.syntaxmenu { display:none; }
			}

			/* example tab selection */
			.ds-selector-tabs .selectors {
				padding: 0;
				border-bottom: 1px solid #ccc;
				height: 28px;
			}
			.ds-selector-tabs .selectors button {
				display: inline-block;
				min-width: 54px;
				text-align: center;
				font-size: 11px;
				font-weight: bold;
				height: 27px;
				padding: 0 8px;
				line-height: 27px;
				transition: all,0.218s;
				border-top-right-radius: 2px;
				border-top-left-radius: 2px;
				color: #666;
				border: 1px solid transparent;
			}
			.ds-selector-tabs .selectors button:first-child {
				margin-left: 2px;
			}
			.ds-selector-tabs .selectors button.selected {
				color: #202020 !important;
				border: 1px solid #ccc;
				border-bottom: 1px solid #fff !important;
			}
			.ds-selector-tabs .selectors button:hover {
				background-color: transparent;
				color: #202020;
				cursor: pointer;
			}
			.ds-selector-tabs .tab {
				display: none;
			}
			.ds-selector-tabs .selected {
				display: block;
			}
		</style>
	</head>
	<body>

		<section id="abstract">
			<p>
				This document defines the Core of the SHACL Shapes Constraint Language.
				SHACL is a language for validating RDF graphs against a set of conditions.
				These conditions are provided as shapes and other constructs expressed in the form of an RDF graph.
				RDF graphs that are used in this manner are called "shapes graphs" in SHACL and
				the RDF graphs that are validated against a shapes graph are called "data graphs".
				As SHACL shape graphs are used to validate that data graphs satisfy a set of conditions
				they can also be viewed as a description of the data graphs that do satisfy these conditions.
				Such descriptions may be used for a variety of purposes beside validation, including
				user interface building, code generation and data integration.
			</p>
		</section>

		<section id="sotd">
		</section>

		<section class="introductory">
			<h2>Document Outline</h2>
			<p>
				The introduction includes a <a href="#terminology">Terminology</a> section.
			</p>
			<p>
				The syntax of SHACL is RDF.
				The examples in this document use Turtle [[rdf12-turtle]] and (in one instance) JSON-LD [[json-ld]].
				Other RDF serializations such as RDF/XML may be used in practice.
				The reader should be familiar with basic RDF concepts [[rdf12-concepts]] such as triples.
			</p>
		</section>
	
		<section id="introduction">
			<h2>Introduction</h2>
			<p>
				This document specifies the Core of SHACL (Shapes Constraint Language), a language for describing and validating RDF graphs.
				This section introduces SHACL with an overview of the key terminology and an example to illustrate basic concepts.
			</p>
			<section id="terminology">
				<h3>Terminology</h3>
				<p>
					Throughout this document, the following terminology is used.
				</p>
				<p>
					Terminology that is linked to portions of RDF 1.2 Concepts and Abstract
					Syntax is used in SHACL as defined there. Terminology that is linked to
					portions of SPARQL 1.2 Query Language is used in SHACL as defined there. A
					single linkage is sufficient to provide a definition for all occurences of a
					particular term in this document.
				</p>
				<p>
					Definitions are complete within this document, i.e., if there is no rule to
					make some situation true in this document then the situation is false.
				</p>
				<div class="def" id="rdf-terminology">
					<div class="term-def-header">Basic RDF Terminology</div>
					<div>
						This document uses the terms 
						<dfn data-cite="rdf12-concepts#dfn-rdf-graph" data-lt="graph|graphs|RDF graphs">RDF graph</dfn>,
						<dfn data-cite="rdf12-concepts#dfn-rdf-triple" data-lt="triple|triples">RDF triple</dfn>,
						<dfn data-cite="rdf12-concepts#dfn-iri" data-lt="IRI|IRIs">IRI</dfn>,
						<dfn data-cite="rdf12-concepts#dfn-rdf-literal" data-lt="literal|literals">literal</dfn>,
						<dfn data-cite="rdf12-concepts#dfn-datatype" data-lt="datatype">datatype</dfn>,
						<dfn data-cite="rdf12-concepts#dfn-blank-node" data-lt="blank node|blank nodes">blank node</dfn>,
						<dfn data-cite="rdf12-concepts#dfn-triple-term" data-lt="triple term|triple terms">triple term</dfn>,
						<dfn data-cite="rdf12-concepts#dfn-reifier" data-lt="reifier">reifier</dfn>,
						<dfn data-cite="rdf12-concepts#dfn-rdf-node" data-lt="node|nodes">node</dfn> of an RDF graph,
						<dfn data-cite="rdf12-concepts#dfn-rdf-term" data-lt="term|terms">RDF term</dfn>,
						<dfn data-cite="rdf12-concepts#dfn-subject" data-lt="subject|subjects">subject</dfn>,
						<dfn data-cite="rdf12-concepts#dfn-predicate" data-lt="predicate|predicates">predicate</dfn>, and
						<dfn data-cite="rdf12-concepts#dfn-object" data-lt="object|objects">object</dfn> of RDF triples
						as defined in RDF 1.2 Concepts and Abstract Syntax [[!rdf12-concepts]].
						<dfn data-lt="language tag">Language tags</dfn> are defined as in [[!BCP47]].
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">Property Value and Path</div>
					<div>
						A <dfn data-lt="properties">property</dfn> is an <a>IRI</a>.
						An <a>RDF term</a> <code>n</code> has a <dfn data-lt="values|property value|property values">value</dfn> <code>v</code>
						for property <code>p</code> in an <a>RDF graph</a> if there is an <a>RDF triple</a> in the graph
						with <a>subject</a> <code>n</code>, <a>predicate</a> <code>p</code>, and <a>object</a> <code>v</code>.
						The phrase "Every value of P in graph G ..." means "Every object of a triple in G with predicate P ...".
						(In this document, the verbs <em>specify</em> or <em>declare</em> are sometimes used to express the fact that an RDF term has values for a given predicate in a graph.)
						<br>
						<dfn data-lt="SPARQL property path">SPARQL property paths</dfn> are defined as in <a href="https://www.w3.org/TR/sparql12-query/#pp-language">SPARQL 1.2</a>.
						An RDF term <code>n</code> has value <code>v</code> for <a>SPARQL property path</a> expression
						<code>p</code> in an RDF graph <code>G</code> if there is a solution mapping in the result of the SPARQL query
						<code>SELECT ?s ?o WHERE { ?s p' ?o }</code> on <code>G</code> that binds <code>?s</code> to
						<code>n</code> and <code>?o</code> to <code>v</code>, where	<code>p'</code> is SPARQL surface syntax for <code>p</code>.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">SHACL Lists</div>
					<div>
						<span data-syntax-rule="SHACL-list">A <dfn data-lt="SHACL lists">SHACL list</dfn> in an RDF graph <code>G</code> is an <a>IRI</a> or a <a>blank node</a>
						that is either <code>rdf:nil</code>	(provided that <code>rdf:nil</code> has no <a>value</a>
						for either <code>rdf:first</code> or <code>rdf:rest</code>), or has exactly one <a>value</a>
						for the property <code>rdf:first</code> in <code>G</code> and exactly one <a>value</a>
						for the property <code>rdf:rest</code> in <code>G</code> that is also a SHACL list in <code>G</code>,
						and the list does not have itself as a value of the property path <code>rdf:rest+</code> in <code>G</code>.</span>
						<br>
						The  <dfn data-lt="member">members</dfn> of any SHACL list except <code>rdf:nil</code> in an RDF
						graph <code>G</code> consist of its value for <code>rdf:first</code> in <code>G</code> followed by
						the members in <code>G</code> of its value for <code>rdf:rest</code> in <code>G</code>.
						The SHACL list <code>rdf:nil</code> has no members in any RDF graph.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">Binding, Solution</div>
					<div>
						A <dfn data-lt="bindings">binding</dfn> is a pair (<a data-cite="sparql12-query/#defn_QueryVariable">variable</a>, <a>RDF term</a>), consistent with the term's use in [[!sparql12-query]].
					    A <dfn data-lt="solutions">solution</dfn> is a set of bindings, informally often understood as one row in the body of the result table of a SPARQL query.
					    Variables are not required to be bound in a solution.
					</div>
				</div>
				<div class="def">
				<div class="term-def-header">SHACL Subclass, SHACL superclass</div>
					<div>
						A <a>node</a> <code>Sub</code> in an <a>RDF graph</a> is a <dfn data-lt="subclasses|subclass|SHACL subclasses">SHACL subclass</dfn> of another <a>node</a> <code>Super</code>
						in the <a>graph</a> if there is a sequence of <a>triples</a> in the <a>graph</a> each with predicate <code>rdfs:subClassOf</code> such that the <a>subject</a> of the first <a>triple</a> is <code>Sub</code>,
						the <a>object</a> of the last triple is <code>Super</code>, and the <a>object</a> of each <a>triple</a> except the last is the <a>subject</a> of the next.
						If <code>Sub</code> is a <a>SHACL subclass</a> of <code>Super</code> in an <a>RDF graph</a> then <code>Super</code>
						is a <dfn data-lt="superclass|superclasses|SHACL superclasses|">SHACL superclass</dfn> of <code>Sub</code> in the <a>graph</a>.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">SHACL Type</div>
					<div>
						The <dfn data-lt="type|types|SHACL type">SHACL types</dfn> of an <a>RDF term</a> in an <a>RDF graph</a> is the set of its <a>values</a> for <code>rdf:type</code> in the
						<a>graph</a> as well as the <a>SHACL superclasses</a> of these <a>values</a> in the <a>graph</a>.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">SHACL Class</div>
					<div>
						<a>Nodes</a> in an <a>RDF graph</a> that are subclasses, superclasses, or types of <a>nodes</a> in the <a>graph</a> are referred to as <dfn data-lt="class|classes|SHACL classes">SHACL class</dfn>.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">SHACL Class Instance</div>
					<div>
						A <a>node</a> <code>n</code> in an <a>RDF graph</a> <code>G</code> is a <dfn data-lt="SHACL instance|SHACL instances">SHACL instance</dfn> of a <a>SHACL class</a> <code>C</code> in <code>G</code>
						if one of the <a>SHACL types</a> of <code>n</code> in <code>G</code> is <code>C</code>.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">Deep Copy</div>
					<div>
						For a <a>node</a> <code>n</code> in a <a>graph</a> <code>sourceGraph</code>,
						the <dfn data-lt="deep copy">deep copy</dfn> of <code>n</code> in a <a>graph</a> <code>targetGraph</code>
						is <code>n</code> in <code>targetGraph</code> plus, if <code>n</code> is a <a>blank node</a>,
						any <a>triples</a> from <code>sourceGraph</code> that can be reached by transitively traversing 
						the <a>blank nodes</a> that appear in the <a>object</a> position of a triple that can be reached
						starting with <code>n</code> as the <a>subject</a>. This is similar to
						the <a href="https://www.w3.org/submissions/CBD/">Concise Bounded Description</a>, but without reification.
					</div>
				</div>

			</section>

			<section id="conventions">
				<h3>Document Conventions</h3>
				<p>
					Within this document, the following namespace prefix definitions are used:
				</p>
				<table class="term-table">
					<thead>
						<tr>
						<th>Prefix</th>
						<th>Namespace</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td><code>owl:</code></td>
						<td><code>http://www.w3.org/2002/07/owl#</code></td>
					</tr>
					<tr>
						<td><code>rdf:</code></td>
						<td><code>http://www.w3.org/1999/02/22-rdf-syntax-ns#</code></td>
					</tr>
					<tr>
						<td><code>rdfs:</code></td>
						<td><code>http://www.w3.org/2000/01/rdf-schema#</code></td>
					</tr>
					<tr>
						<td><code>sh:</code></td>
						<td><code><a href="http://www.w3.org/ns/shacl">http://www.w3.org/ns/shacl#</a></code></td>
					</tr>
					<tr>
						<td><code>xsd:</code></td>
						<td><code>http://www.w3.org/2001/XMLSchema#</code></td>
					</tr>
					<tr>
						<td><code>ex:</code></td>
						<td><code>http://example.com/ns#</code></td>
					</tr>
				</tbody>
			</table>

				<p>
					Within this document, the following JSON-LD context is used:
				</p>
				<pre class="jsonld">{
  "@context": {
    "owl": "http://www.w3.org/2002/07/owl#",
    "rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
    "rdfs": "http://www.w3.org/2000/01/rdf-schema#",
    "sh": "http://www.w3.org/ns/shacl#",
    "xsd": "http://www.w3.org/2001/XMLSchema#",
    "ex": "http://example.com/ns#"
  }
}</pre>
				<p>
					Note that the URI of the graph defining the SHACL vocabulary itself is equivalent to
					the namespace above, i.e., it includes the <code>#</code>.
					References to the SHACL vocabulary, e.g., via <code>owl:imports</code> should include the <code>#</code>.
				</p>
				<p>
					Throughout the document, color-coded boxes containing RDF graphs in Turtle and JSON-LD will appear.
					These fragments of Turtle documents use the prefix bindings given above.
					The JSON-LD document fragments use the context given above.
					Only the Turtle documents may highlight certain parts.
				</p>

				<div class="shapes-graph">
					<div class="turtle">
# This box represents an input shapes graph

# Triples that can be omitted are marked as grey, e.g. --
<span class="triple-can-be-skipped">&lt;s&gt; ex:p &lt;o&gt; .</span>
						</div>
				  <div class="jsonld">
						<pre class="text">// This box represents an input shapes graph</pre>
					  <pre class="jsonld">{
	"@id": "s",
	"ex:p": {
		"@id": "o"
	}
}</pre>
				  </div>
				</div>

				<div class="data-graph">
					<div class="turtle">
# This box represents an input data graph.
# When highlighting is used in the examples:

# Elements highlighted in blue are <a>focus nodes</a>
<span class="focus-node-selected">ex:Bob</span> a ex:Person .

# Elements highlighted in red are focus nodes that fail validation
<span class="focus-node-error">ex:Alice</span> a ex:Person .
					</div>
					<div class="jsonld">
						<pre class="text">// This box represents an input data graph</pre>
						<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:Alice",
			"@type": "ex:Person"
		},
		{
			"@id": "ex:Bob",
			"@type": "ex:Person"
		}
	]
}</pre>
					</div>
				</div>

				<div class="results-graph">
					<div class="turtle">
# This box represents an output results graph
					</div>
					<div class="jsonld">
						<pre class="text">// This box represents an output results graph</pre>
						<pre class="jsonld">{}</pre>
					</div>
				</div>
				
				<p class="syntax">
					Grey boxes such as this include syntax rules that apply to the <a>shapes graph</a>.
				</p>
				
				<p>
					<code>true</code> denotes the RDF term <code>"true"^^xsd:boolean</code>.
					<code>false</code> denotes the RDF term <code>"false"^^xsd:boolean</code>.
				</p>

			</section>

			<section id="conformance">
				<p>
					This document defines the <strong>SHACL Core</strong> language, also referred to as just <strong>SHACL</strong>.
					This specification describes conformance criteria for:
				</p>
				<ul>
					<li><strong>SHACL Core processors</strong> as processors that support validation with the SHACL Core Language</li>
				</ul>
				<p>
					This document includes syntactic rules that shapes and other nodes need to fulfill in the <a>shapes graph</a>.
					These rules are typically of the form <em>A shape must have...</em> or <em>The values of X are literals</em> or <em>All objects of triples with predicate P must be IRIs</em>.
					The complete list of these rules can be found in the <a href="#syntax-rules">appendix</a>.
					Nodes that violate any of these rules are called <dfn>ill-formed</dfn>.
					Nodes that violate none of these rules are called <dfn>well-formed</dfn>.
					A <a>shapes graph</a> is ill-formed if it contains at least one ill-formed node.
				</p>
			</section>

			<section class="informative">
				<h3>SHACL Example</h3>
				<p>
					The following example <a>data graph</a> contains three <a>SHACL instances</a> of the <a>class</a> <code>ex:Person</code>.
				</p>
				<aside class="example">
					<div class="data-graph">
						<div class="turtle">
ex:Alice
	a ex:Person ;
	ex:ssn "987-65-432A" .
  
ex:Bob
	a ex:Person ;
	ex:ssn "123-45-6789" ;
	ex:ssn "124-35-6789" .
  
ex:Calvin
	a ex:Person ;
	ex:birthDate "1971-07-07"^^xsd:date ;
	ex:worksFor ex:UntypedCompany .
						</div>
						<div class="jsonld">
							<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:Alice",
			"@type": "ex:Person",
			"ex:ssn": "987-65-432A"
		},
		{
			"@id": "ex:Bob",
			"@type": "ex:Person",
			"ex:ssn": [
				"123-45-6789",
				"124-35-6789"
			]
		},
		{
			"@id": "ex:Calvin",
			"@type": "ex:Person",
			"ex:birthDate": {
				"@type": "xsd:date",
				"@value": "1971-07-07"
			},
			"ex:worksFor": {
				"@id": "ex:UntypedCompany"
			}
		}
	]
}</pre>
						</div>
					</div>
					<p>
						The following conditions are shown in the example:
					</p>
					<ul>
						<li>
							A <a>SHACL instance</a> of <code>ex:Person</code> can have at most one <a>value</a> for the property <code>ex:ssn</code>,
							and this <a>value</a> is a <a>literal</a> with the datatype <code>xsd:string</code> that matches
							a specified regular expression.
						</li>
						<li>
							A <a>SHACL instance</a> of <code>ex:Person</code> can have unlimited <a>values</a> for the property <code>ex:worksFor</code>,
							and these <a>values</a> are <a>IRIs</a> and <a>SHACL instances</a> of <code>ex:Company</code>.
						</li>
						<li>
							A <a>SHACL instance</a> of <code>ex:Person</code> cannot have <a>values</a> for any other property apart from
							<code>ex:ssn</code>, <code>ex:worksFor</code> and <code>rdf:type</code>.
						</li>
					</ul>
					<p>
						The aforementioned conditions can be represented as <a>shapes</a> and <a>constraints</a> in the following <a>shapes graph</a>:
					</p>
					<div class="shapes-graph">
						<div class="turtle">
ex:PersonShape
	a sh:NodeShape ;
	sh:targetClass ex:Person ;    # Applies to all persons
	sh:property [                 # _:b1
		sh:path ex:ssn ;           # constrains the values of ex:ssn
		sh:maxCount 1 ;
		sh:datatype xsd:string ;
		sh:pattern "^\\d{3}-\\d{2}-\\d{4}$" ;
	] ;
	sh:property [                 # _:b2
		sh:path ex:worksFor ;
		sh:class ex:Company ;
		sh:nodeKind sh:IRI ;
	] ;
	sh:closed true ;
	sh:ignoredProperties ( rdf:type ) .
						</div>
						<div class="jsonld">
							<pre class="jsonld">{
	"@id": "ex:PersonShape",
	"@type": "sh:NodeShape",
	"sh:closed": {
		"@type": "xsd:boolean",
		"@value": "true"
	},
	"sh:ignoredProperties": {
		"@list": [
			{
				"@id": "rdf:type"
			}
		]
	},
	"sh:property": [
		{
			"sh:datatype": {
				"@id": "xsd:string"
			},
			"sh:maxCount": {
				"@type": "xsd:integer",
				"@value": "1"
			},
			"sh:path": {
				"@id": "ex:ssn"
			},
			"sh:pattern": "^\\d{3}-\\d{2}-\\d{4}$"
		},
		{
			"sh:class": {
				"@id": "ex:Company"
			},
			"sh:nodeKind": {
				"@id": "sh:IRI"
			},
			"sh:path": {
				"@id": "ex:worksFor"
			}
		}
	],
	"sh:targetClass": {
		"@id": "ex:Person"
	}
}</pre>
						</div>
					<div class="shaclc"><pre class="shaclc">shape ex:PersonShape -&gt; ex:Person {
	closed=true ignoredProperties=[rdf:type] .
	ex:ssn xsd:string [0..1] pattern="^\\d{3}-\\d{2}-\\d{4}$" .
	ex:worksFor IRI ex:Company .
}</pre></div></div>
				</aside>
				<p>
					We can use the shape declaration above to illustrate some of the key terminology used by SHACL.
					The <a>target</a> for the <a>shape</a> <code>ex:PersonShape</code> is the set of all <a>SHACL instances</a> of the <a>class</a> <code>ex:Person</code>.
					This is specified using the property <code>sh:targetClass</code>.
					During the validation, these target nodes become <a>focus nodes</a> for the shape.
					The <a>shape</a> <code>ex:PersonShape</code> is a <a>node shape</a>, which means that it applies to the focus nodes.
					It declares <a>constraints</a> on the <a>focus nodes</a>, for example using the <a>parameters</a> <code>sh:closed</code> and <code>sh:ignoredProperties</code>.
					The <a>node shape</a> also declares two other constraints with the property <code>sh:property</code>,
					and each of these is backed by a <a>property shape</a>. 
					These <a>property shapes</a> declare additional <a>constraints</a> using <a>parameters</a> such as <code>sh:datatype</code> and <code>sh:maxCount</code>.
				</p>
				<p>
					Some of the <a>property shapes</a> specify parameters from multiple <a>constraint components</a> in order to
					restrict multiple aspects of the <a>property values</a>.
					For example, in the <a>property shape</a> for <code>ex:ssn</code>, parameters from three <a>constraint components</a> are used.
					The <a>parameters</a> of these <a>constraint components</a> are <code>sh:datatype</code>, <code>sh:pattern</code> and <code>sh:maxCount</code>.
					For each <a>focus node</a> the <a>property values</a> of <code>ex:ssn</code> will be validated against all three components.
				</p>
				<p>
					SHACL <a>validation</a> based on the provided <a>data graph</a> and <a>shapes graph</a> would produce the following <a>validation report</a>.
					See the section <a href="#validation-report">Validation Report</a> for details on the format.
				</p>
				<aside class="example">
					<div class="results-graph">
						<div class="turtle">
[	a sh:ValidationReport ;
	sh:conforms false ;
	sh:result
	[	a sh:ValidationResult ;
		sh:resultSeverity sh:Violation ;
		sh:focusNode ex:Alice ;
		sh:resultPath ex:ssn ;
		sh:value "987-65-432A" ;
		sh:sourceConstraintComponent sh:PatternConstraintComponent ;
		sh:sourceShape _:b1 ; # ... blank node _:b1 on ex:ssn above ...
	] ,
	[	a sh:ValidationResult ;
		sh:resultSeverity sh:Violation ;
		sh:focusNode ex:Bob ;
		sh:resultPath ex:ssn ;
		sh:sourceConstraintComponent sh:MaxCountConstraintComponent ;
		sh:sourceShape _:b1 ; # ... blank node _:b1 on ex:ssn above ...
	] ,
	[	a sh:ValidationResult ;
		sh:resultSeverity sh:Violation ;
		sh:focusNode ex:Calvin ;
		sh:resultPath ex:worksFor ;
		sh:value ex:UntypedCompany ;
		sh:sourceConstraintComponent sh:ClassConstraintComponent ;
		sh:sourceShape _:b2 ; # ... blank node _:b2 on ex:worksFor above ...
	] ,
	[	a sh:ValidationResult ;
		sh:resultSeverity sh:Violation ;
		sh:focusNode ex:Calvin ;
		sh:resultPath ex:birthDate ;
		sh:value "1971-07-07"^^xsd:date ;
		sh:sourceConstraintComponent sh:ClosedConstraintComponent ;
		sh:sourceShape sh:PersonShape ;
	] 
] .
						</div>
						<div class="jsonld">
							<pre class="jsonld">{
	"@type": "sh:ValidationReport",
	"sh:conforms": {
		"@type": "xsd:boolean",
		"@value": "false"
	},
	"sh:result": [
		{
			"@type": "sh:ValidationResult",
			"sh:focusNode": {
				"@id": "ex:Alice"
			},
			"sh:resultPath": {
				"@id": "ex:ssn"
			},
			"sh:resultSeverity": {
				"@id": "sh:Violation"
			},
			"sh:sourceConstraintComponent": {
				"@id": "sh:PatternConstraintComponent"
			},
			"sh:sourceShape": {
				"@id": "_:b1"
			},
			"sh:value": "987-65-432A"
		},
		{
			"@type": "sh:ValidationResult",
			"sh:focusNode": {
				"@id": "ex:Bob"
			},
			"sh:resultPath": {
				"@id": "ex:ssn"
			},
			"sh:resultSeverity": {
				"@id": "sh:Violation"
			},
			"sh:sourceConstraintComponent": {
				"@id": "sh:MaxCountConstraintComponent"
			},
			"sh:sourceShape": {
				"@id": "_:b1"
			}
		},
		{
			"@type": "sh:ValidationResult",
			"sh:focusNode": {
				"@id": "ex:Calvin"
			},
			"sh:resultPath": {
				"@id": "ex:worksFor"
			},
			"sh:resultSeverity": {
				"@id": "sh:Violation"
			},
			"sh:sourceConstraintComponent": {
				"@id": "sh:ClassConstraintComponent"
			},
			"sh:sourceShape": {
				"@id": "_:b2"
			},
			"sh:value": {
				"@id": "ex:UntypedCompany"
			}
		},
		{
			"@type": "sh:ValidationResult",
			"sh:focusNode": {
				"@id": "ex:Calvin"
			},
			"sh:resultPath": {
				"@id": "ex:birthDate"
			},
			"sh:resultSeverity": {
				"@id": "sh:Violation"
			},
			"sh:sourceConstraintComponent": {
				"@id": "sh:ClosedConstraintComponent"
			},
			"sh:sourceShape": {
				"@id": "sh:PersonShape"
			},
			"sh:value": {
				"@type": "xsd:date",
				"@value": "1971-07-07"
			}
		}
	]
}</pre>
						</div>
					</div>
				</aside>
				<p>
					The <a>validation results</a> are enclosed in a <a>validation report</a>.
					The first <a>validation result</a> is produced because <code>ex:Alice</code> has a <a>value</a> for <code>ex:ssn</code>
					that does not match the regular expression specified by the property <code>sh:pattern</code>.
					The second <a>validation result</a> is produced because <code>ex:Bob</code> has more than the permitted number of <a>values</a>
					for the property <code>ex:ssn</code> as specified by the <code>sh:maxCount</code> of 1.
					The third <a>validation result</a> is produced because <code>ex:Calvin</code> has a <a>value</a> for <code>ex:worksFor</code>
					that does not have an <code>rdf:type</code> triple that makes it a <a>SHACL instance</a> of <code>ex:Company</code>.
					The forth <a>validation result</a> is produced because the <a>shape</a> <code>ex:PersonShape</code> has the	property <code>sh:closed</code> set to <code>true</code>
					but <code>ex:Calvin</code> uses the property <code>ex:birthDate</code> which is neither one of the predicates from any of the 
					<a>property shapes</a> of the shape, nor one of the properties listed using <code>sh:ignoredProperties</code>.
				</p>
			</section>
			
			<section id="shacl-rdfs">
				<h3>Relationship between SHACL and RDFS inferencing</h3>
				<p>
					SHACL uses the RDF and RDFS vocabularies, but full RDFS inferencing is not required.
				</p>
				<p>
					However, SHACL processors MAY operate on RDF graphs that include entailments [[!sparql12-entailment]] -
					either pre-computed before being submitted to a SHACL processor or performed on the fly as
					part of SHACL processing (without modifying either <a>data graph</a> or <a>shapes graph</a>).
					To support processing of entailments, SHACL includes the property
					<code>sh:entailment</code> to indicate what inferencing is required
					by a given <a>shapes graph</a>.
				</p>
				<p class="syntax">
					<span data-syntax-rule="entailment-nodeKind">The <a>values</a> of the property <code>sh:entailment</code> are IRIs.</span>
					Common values for this property are covered by [[!sparql12-entailment]].
				</p>
				<p>
					SHACL implementations MAY, but are not required to, support entailment regimes.
					If a <a>shapes graph</a> contains any <a>triple</a> with the <a>predicate</a> <code>sh:entailment</code> and <a>object</a> <code>E</code>
					and the SHACL processor does not support <code>E</code> as an entailment regime for the given <a>data graph</a>
					then the processor MUST signal a <a>failure</a>.
					Otherwise, the SHACL processor MUST provide the entailments for all of the values of <code>sh:entailment</code> in the <a>shapes graph</a>,
					and any inferred triples MUST be returned by all queries against the <a>data graph</a> during the <a>validation</a> process.
				</p>
			</section>			
		</section>

		<section id="constraints-section">
			<h2>Shapes and Constraints</h2>
			
			<p><em>The following introduction is non-normative.</em></p>
			<p>
				The following informal diagram provides an overview of some of the key classes in the SHACL vocabulary.
				Each box represents a class.
				The content of the boxes under the class name lists some of the properties that instances of these classes may have, together with their value types.
				The arrows indicate <code>rdfs:subClassOf</code> triples.
			</p>
			<div>
				<div class="diagram-class" style="margin-left: 200px">
					<div class="diagram-class-name"><a href="#shapes">sh:Shape</a></div>
					<div class="diagram-class-properties">
						<div class="diagram-class-properties-start">
							<div><a href="#targetClass">sh:targetClass</a> : rdfs:Class</div>
							<div><a href="#targetNode">sh:targetNode</a> : any</div>
							<div><a href="#targetObjectsOf">sh:targetObjectsOf</a> : rdf:Property</div>
							<div><a href="#targetSubjectsOf">sh:targetSubjectsOf</a> : rdf:Property</div>
						</div>
						<div class="diagram-class-properties-section">
							<div><a href="#deactivated">sh:deactivated</a> : xsd:boolean</div>
							<div><a href="#message">sh:message</a> : xsd:string or rdf:langString</div>
							<div><a href="#severity">sh:severity</a> : sh:Severity</div>
						</div>
					</div>
				</div>
				<div style="height: 60px; margin-left: 260px">
					<img alt="Class Diagram Arrows" src="images/Class-Diagram-Arrows.png">
				</div>
				<div style="white-space: nowrap; min-width: 1000px">
				<div class="diagram-class" style="float: left; margin-right: 60px;">
					<div class="diagram-class-name"><a href="#node-shapes">sh:NodeShape</a></div>
					<div class="diagram-class-properties">
						<div class="diagram-class-properties-start">
							<div><b><a href="#constraints">Constraint parameters</a></b>, for example:</div>
							<div><a href="#ClosedConstraintComponent">sh:closed</a> : xsd:boolean or sh:ByTypes</div>
							<div><a href="#OrConstraintComponent">sh:or</a> : rdf:List</div>
							<div><a href="#NotConstraintComponent">sh:not</a> : sh:Shape</div>
							<div><a href="#PropertyConstraintComponent">sh:property</a> : sh:PropertyShape</div>
						</div>
					</div>
				</div>
				<div class="diagram-class" style="float: left;">
					<div class="diagram-class-name"><a href="#property-shapes">sh:PropertyShape</a></div>
					<div class="diagram-class-properties">
						<div class="diagram-class-properties-start">
							<div><b><a href="#constraints">Constraint parameters</a></b>, for example:</div>
							<div><a href="#MinCountConstraintComponent">sh:minCount</a>, <a href="#MaxCountConstraintComponent">sh:maxCount</a> : xsd:integer</div>
							<div><a href="#ClassConstraintComponent">sh:class</a> or <a href="#DatatypeConstraintComponent">sh:datatype</a> : rdfs:Resource</div>
							<div><a href="#NodeConstraintComponent">sh:node</a> : sh:NodeShape</div>
						</div>
						<div class="diagram-class-properties-section">
							<div><a href="#name">sh:name</a> : xsd:string or rdf:langString</div>
							<div><a href="#description">sh:description</a> : xsd:string or rdf:langString</div>
							<div><a href="#syntax-rule-path-defaultValue">sh:defaultValue</a> : any</div>
							<div><a href="#group">sh:group</a> : sh:PropertyGroup</div>
						</div>
						<div class="diagram-class-properties-section">
							<div><a href="#property-shapes">sh:path</a> : rdfs:Resource</div>
						</div>
					</div>
				</div>
				<div style="clear: both"></div>
				</div>
				<p>
					The <a href="http://www.w3.org/ns/shacl.ttl">Turtle serialization of the SHACL vocabulary</a> contains the complete SHACL vocabulary.
				</p>
			</div>
			
			<section id="shapes">
			
				<h3>Shapes</h3>
				<div class="syntax" data-syntax-rule="shape">
					A <dfn data-lt="shape|shapes">shape</dfn> is an <a>IRI</a> or <a>blank node</a> <code>s</code>
					that fulfills at least one of the following conditions in the <a>shapes graph</a>:
					<ul>
						<li>
							<code>s</code> is a <a>SHACL instance</a> of <code>sh:NodeShape</code> or <code>sh:PropertyShape</code>.
						</li>
						<li>
							<code>s</code> is <a>subject</a> of a triple that has <code>sh:targetClass</code>, <code>sh:targetNode</code>,
							<code>sh:targetObjectsOf</code> or <code>sh:targetSubjectsOf</code> as <a>predicate</a>.
						</li>
						<li>
							<code>s</code> is <a>subject</a> of a triple that has a <a>parameter</a> as <a>predicate</a>.
						</li>
						<li>
							<code>s</code> is a <a>value</a> of a <a>shape-expecting</a>, non-<a>list-taking</a> <a>parameter</a> such as <code>sh:node</code>,
							or a <a>member</a> of a <a>SHACL list</a> that is a <a>value</a> of a <a>shape-expecting</a> and <a>list-taking</a> parameter such as <code>sh:or</code>.
						</li>
					</ul>
				</div>
				<p>
					Note that the definition above does not include all of the syntax rules of <a>well-formed</a> shapes.
					Those are found throughout the document and summarized in Appendix <a href="#syntax-rules"></a>.
					For example, shapes that have <a>literals</a> as values for <code>sh:targetClass</code> are <a>ill-formed</a>.
				</p>
				<p>
					Informally, a shape determines how to validate a <a>focus node</a> based on the <a>values</a> of properties and other characteristics of the focus node.
					For example, shapes can declare the condition that a focus node be an IRI or that a focus node has a particular value for a property and also a minimum number of values for the property.
				</p>
				<p>
					The SHACL Core language defines two types of shapes:
				</p>
				<ul>
					<li>shapes about the <a>focus node</a> itself, called <a>node shapes</a></li>
					<li>shapes about the <a>values</a> of a particular property or path for the focus node, called <a>property shapes</a></li>
				</ul>
				<p>
					<code>sh:Shape</code> is the <a>SHACL superclass</a> of those two shape types in the SHACL vocabulary.
					Its subclasses <code>sh:NodeShape</code> and <code>sh:PropertyShape</code> can be used as SHACL type of node and property shapes, respectively.
				</p>
				
				<section id="constraints">
					<h3>Constraints, Parameters and Constraint Components</h3>
					<p>
						Shapes can declare <a>constraints</a> using the <a>parameters</a> of <a>constraint components</a>.
					</p>
					<p>
						A <dfn data-lt="constraint component|constraint components|components|component">constraint component</dfn> is an <a>IRI</a>.
						Each constraint component has one or more <dfn data-lt="mandatory parameter">mandatory parameters</dfn>, each of which is a property.
						Each constraint component has zero or more <dfn data-lt="optional parameter">optional parameters</dfn>, each of which is a property.
						The <dfn data-lt="parameter">parameters</dfn> of a constraint component are its mandatory parameters plus its optional parameters.
					</p>
					<p>
						For example, the <a>component</a> <code>sh:MinCountConstraintComponent</code> declares the <a>parameter</a> <code>sh:minCount</code> to represent the restriction
						that a <a>node</a> has at least a minimum number of <a>values</a> for a	particular property.
					</p>
					<p>
						For a <a>constraint component</a> <code>C</code> with <a>mandatory parameters</a> <code>p1</code>, ... <code>pn</code>,
						a <a>shape</a> <code>s</code> in a <a>shapes graph</a> <code>SG</code> <em>declares</em> a <dfn data-lt="constraints">constraint</dfn>
						that has <dfn>kind</dfn> <code>C</code> with <a>mandatory parameter</a> <a>values</a> <code>&lt;p1,v1&gt;</code>, ... <code>&lt;pn,vn&gt;</code>
						in <code>SG</code> when <code>s</code> has <code>vi</code> as a <a>value</a> for <code>pi</code> in <code>SG</code>.
						For constraint components with <a>optional parameters</a>, the constraint declaration consists of the <a>values</a> that the shape has for all mandatory and optional parameters of that component.
					</p>
					<p id="multiple-parameter-constraints-section">
						Some constraint components declare only a single parameter.
						For example <a href="#ClassConstraintComponent"><code>sh:ClassConstraintComponent</code></a> has the single parameter <code>sh:class</code>.
						These parameters may be used multiple times in the same shape,
						and each <a>value</a> of such a parameter declares an individual <a>constraint</a>. 
						The interpretation of such declarations is conjunction, i.e. all constraints apply.
						The following example specifies that the values of <code>ex:customer</code> have to be <a>SHACL instances</a> of both
						<code>ex:Customer</code> and <code>ex:Person</code>.
					</p>
					<aside class="example">
						<div class="shapes-graph">
							<div class="turtle">
ex:InvoiceShape
	a sh:NodeShape ;
	sh:property [
		sh:path ex:customer ;
		sh:class ex:Customer ;
		sh:class ex:Person ;
	] .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@id": "ex:InvoiceShape",
	"@type": "sh:NodeShape",
	"sh:property": {
		"sh:class": [
			{
				"@id": "ex:Customer"
			},
			{
				"@id": "ex:Person"
			}
		],
		"sh:path": {
			"@id": "ex:customer"
		}
	}
}</pre>
							</div>
						</div>
					</aside>
					<p class="syntax" data-syntax-rule="multiple-parameters">
						Some constraint components such as <a href="#PatternConstraintComponent"><code>sh:PatternConstraintComponent</code></a> declare more than one parameter.
						Shapes that have more than one value for any of the parameters of such components are <a>ill-formed</a>.
					</p>
					<p>
						One way to bypass this syntax rule is to spread the constraints across multiple (property) shapes, as illustrated in the following example.
					</p>
					<aside class="example">
						<div class="shapes-graph">
							<div class="turtle">
ex:MultiplePatternsShape
	a sh:NodeShape ;
	sh:property [
		sh:path ex:name ;
		sh:pattern "^Start" ;
		sh:flags "i" ;
	] ;
	sh:property [
		sh:path ex:name ;
		sh:pattern "End$" ;
	] .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@id": "ex:MultiplePatternsShape",
	"@type": "sh:NodeShape",
	"sh:property": [
		{
			"sh:flags": "i",
			"sh:path": {
				"@id": "ex:name"
			},
			"sh:pattern": "^Start"
		},
		{
			"sh:path": {
				"@id": "ex:name"
			},
			"sh:pattern": "End$"
		}
	]
}</pre>
							</div>
						<div class="shaclc"><pre class="shaclc">shape ex:MultiplePatternsShape {
	ex:name pattern="^Start" flags="i" .
	ex:name pattern="End$" .
}</pre></div></div>
					</aside>
					<p>
						Constraint components are associated with <dfn data-lt="validator|validators">validators</dfn>, which provide instructions (for example expressed via SPARQL queries)
						on how the parameters are used to validate data.
						Validating an <a>RDF term</a> against a <a>shape</a> involves validating the term against each <a>constraint</a> where the 
						shape has <a>values</a> for all <a>mandatory parameters</a> of the <a>component</a> of the <a>constraint</a>,
						using the validators associated with the respective component.
					</p>
					<p>
						The list of constraint components included in SHACL Core is described in <a href="#constraints">section 4</a>.
						SHACL-SPARQL can be used to declare additional <a href="shacl12-sparql#sparql-constraint-components">constraint components based on SPARQL</a>.
					</p>
				</section>

				<section id="focusNodes">
					<h3>Focus Nodes</h3>
					<p>
						An <a>RDF term</a> that is <a>validated</a> against a <a>shape</a> using the triples from a <a>data graph</a> is called a <dfn data-lt="focus node|focus nodes">focus node</dfn>.
					</p>
					<p><em>The remainder of this section is informative.</em></p>
					<p>
						The set of <a>focus nodes</a> for a <a>shape</a> may be identified as follows:
					</p>
					<ul>
				    	<li>specified in a <a>shape</a> using <a>target declarations</a></li>
						<li>specified in any <a>constraint</a> that references a <a>shape</a>
							in parameters of <a>shape-expecting constraint parameters</a> (e.g. <code>sh:node</code>)</li>
						<li>specified as explicit input to the SHACL processor for validating a specific RDF term against a shape</li>
					</ul>
				</section>
	
				<section id="targets">
					<h3>Targets</h3>
					<p>
						<dfn data-lt="target declaration">Target declarations</dfn> of a <a>shape</a> in a <a>shapes graph</a> are
						<a>triples</a> with the <a>shape</a> as the <a>subject</a> and certain properties described in this document
						(e.g., <code>sh:targetClass</code>) as <a>predicates</a>.
						Target declarations can be used to produce <a>focus nodes</a> for a <a>shape</a>.
						The <dfn data-lt="targets">target</dfn> of a <a>target declaration</a> is the set of RDF terms produced
						by applying the rules described in the remainder of this section to the <a>data graph</a>. 
						The <dfn data-lt="target of the shape">target of a shape</dfn> is the union of all RDF terms produced by the individual
						<a>targets</a> that are declared by the <a>shape</a> in the <a>shapes graph</a>.
					</p>
					<p>
						SHACL Core includes the following kinds of targets:
						<a href="#targetNode">node targets</a>,
						<a href="#targetClass">class-based targets</a> (including <a href="#implicit-targetClass">implicit class-based targets</a>),
						<a href="#targetSubjectsOf">subjects-of targets</a>, and
						<a href="#targetObjectsOf">objects-of targets</a>.
					</p>
					<p><em>The remainder of this introduction is informative.</em></p>
					<p>
						RDF terms produced by targets are not required to exist as nodes in the <a>data graph</a>.
						Targets of a shape are ignored whenever a focus node is provided directly as input to the validation process for that shape.
						This includes the cases where the shape is a value of one of the
						<a>shape-expecting constraint parameters</a> (such as <code>sh:node</code>) and
						a focus node is determined during the validation of the corresponding constraint component (such as <code>sh:NodeConstraintComponent</code>).
						In such cases, the provided focus node does not need to be in the <a>target of the shape</a>.
					</p>
					
					<section id="targetNode">
						<h4>Node targets (sh:targetNode)</h4>
						<p class="syntax">
							A <dfn>node target</dfn> is specified using the <code>sh:targetNode</code> predicate.
							<span data-syntax-rule="targetNode-nodeKind">Each <a>value</a> of <code>sh:targetNode</code> in a shape is a well-formed <a>node expression</a>.</span>
						</p>
						<div class="def">
							<div class="def-header">TEXTUAL DEFINITION</div>
							If <code>s</code> is a <a>shape</a> in a <a>shapes graph</a> <code>SG</code> and <code>s</code> has
							<a>value</a> <code>expr</code> for <code>sh:targetNode</code> in <code>SG</code>,
							then the <a>output nodes</a> of <code>expr</code> are <a>targets</a>
							for the data graph <code>DG</code> as <a>focus graph</a>.
						</div>
						<p><em>The remainder of this section is informative.</em></p>
						<p>
							With the example data below, only <code>ex:Alice</code> is the target of the provided shape:
						</p>
						<aside class="example">
							<div class="shapes-graph">
								<div class="turtle">
ex:PersonShape
	a sh:NodeShape ;
	sh:targetNode ex:Alice .
								</div>
								<div class="jsonld">
									<pre class="jsonld">{
	"@id": "ex:PersonShape",
	"@type": "sh:NodeShape",
	"sh:targetNode": {
		"@id": "ex:Alice"
	}
}</pre>
								</div>
							<div class="shaclc"><pre class="shaclc">shape ex:PersonShape {
	targetNode=ex:Alice .
}</pre></div></div>
							<div class="data-graph">
								<div class="turtle">
<span class="focus-node-selected">ex:Alice</span> a ex:Person .
ex:Bob a ex:Person .
								</div>
								<div class="jsonld">
									<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:Alice",
			"@type": "ex:Person"
		},
		{
			"@id": "ex:Bob",
			"@type": "ex:Person"
		}
	]
}</pre>
								</div>
							</div>
						</aside>
					</section>
					
					<section id="targetClass">
						<h4>Class-based Targets (sh:targetClass)</h4>
						<p class="syntax">
							A <dfn>class target</dfn> is specified with the <code>sh:targetClass</code> predicate.
							<span data-syntax-rule="targetClass-nodeKind">Each value of <code>sh:targetClass</code> in a shape is an <a>IRI</a>.</span>
						</p>
						<div class="def">
							<div class="def-header">TEXTUAL DEFINITION</div>
							If <code>s</code> is a shape in a shapes graph <code>SG</code> and <code>s</code> has <a>value</a> <code>c</code> for
							<code>sh:targetClass</code> in <code>SG</code> then the set of <a>SHACL instances</a> of <code>c</code> in a data graph
							<code>DG</code> is a <a>target</a> from <code>DG</code> for <code>s</code> in <code>SG</code>.
						</div>
						<p><em>The remainder of this section is informative.</em></p>
						<aside class="example">
							<div class="shapes-graph">
								<div class="turtle">
ex:PersonShape
	a sh:NodeShape ;
	sh:targetClass ex:Person .
								</div>
								<div class="jsonld">
									<pre class="jsonld">{
	"@id": "ex:PersonShape",
	"@type": "sh:NodeShape",
	"sh:targetClass": {
		"@id": "ex:Person"
	}
}</pre>
								</div>
							<div class="shaclc"><pre class="shaclc">shape ex:PersonShape -&gt; ex:Person {
}</pre></div></div>

							<div class="data-graph">
								<div class="turtle">
<span class="focus-node-selected">ex:Alice</span> a ex:Person .
<span class="focus-node-selected">ex:Bob</span> a ex:Person .
ex:NewYork a ex:Place .
								</div>
								<div class="jsonld">
									<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:Alice",
			"@type": "ex:Person"
		},
		{
			"@id": "ex:Bob",
			"@type": "ex:Person"
		},
		{
			"@id": "ex:NewYork",
			"@type": "ex:Place"
		}
	]
}</pre>
								</div>
							</div>
						</aside>
						<p>
							In this example, only <code>ex:Alice</code> and <code>ex:Bob</code> are focus nodes.
							Note that, according to the <a>SHACL instance</a> definition, all the <code>rdfs:subClassOf</code> declarations needed to walk the class hierarchy need to exist in the <a>data graph</a>.
							However, the <code>ex:Person a rdfs:Class</code> triple is not required to exist in either graphs.
						</p>
						<p>
							In the following example, the selected focus node is only <code>ex:Who</code>.
						</p>
						<aside class="example">
							<div class="data-graph">
								<div class="turtle">
ex:Doctor rdfs:subClassOf ex:Person .
<span class="focus-node-selected">ex:Who</span> a ex:Doctor .
ex:House a ex:Nephrologist .
								</div>
								<div class="jsonld">
									<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:Doctor",
			"rdfs:subClassOf": {
				"@id": "ex:Person"
			}
		},
		{
			"@id": "ex:House",
			"@type": "ex:Nephrologist"
		},
		{
			"@id": "ex:Who",
			"@type": "ex:Doctor"
		}
	]
}</pre>
								</div>
							</div>
						</aside>
	
					</section>
					
					<section id="implicit-targetClass">
						<h4>Implicit Class Targets and sh:ShapeClass</h4>
						<p>
							Informally, if a <a>shape</a> is also declared to be a <a>class</a> in the <a>shapes graph</a> then 
							all <a>SHACL instances</a> of this class are a target for the shape.
						</p>
						<p class="syntax" data-syntax-rule="implicit-targetClass-nodeKind">
							If <code>s</code> is a <a>SHACL instance</a> of <code>sh:NodeShape</code> or <code>sh:PropertyShape</code>
							in an RDF graph <code>G</code> and <code>s</code> is also a <a>SHACL instance</a> of
							<code>rdfs:Class</code> in <code>G</code> and <code>s</code> is not an <a>IRI</a> then <code>s</code> is an <a>ill-formed</a> shape in <code>G</code>.
						</p>
						<div class="def">
							<div class="def-header">TEXTUAL DEFINITION</div>
							If <code>s</code> is a <a>SHACL instance</a> of <code>sh:NodeShape</code> or <code>sh:PropertyShape</code>
							in a <a>shapes graph</a> <code>SG</code> and <code>s</code> is also a <a>SHACL instance</a> of <code>rdfs:Class</code>
							in <code>SG</code> then the set of <a>SHACL instances</a> of <code>s</code> in a data graph <code>DG</code> is a <a>target</a> from <code>DG</code> for <code>s</code> in <code>SG</code>.
						</div>
						<p id="ShapeClass">
							The SHACL namespace includes a dedicated class <code>sh:ShapeClass</code> that can serve as a syntactic shortcut for the implicit class targets pattern.
						</p>
						<div class="def">
							<div class="def-header">TEXTUAL DEFINITION</div>
							The class <code>sh:ShapeClass</code> is an <code>rdfs:subClassOf</code> of both <code>sh:NodeShape</code> and <code>rdfs:Class</code>.
							If <code>s</code> is a <a>SHACL instance</a> of <code>sh:ShapeClass</code> in a <a>shapes graph</a> <code>SG</code>
							then the set of <a>SHACL instances</a> of <code>s</code> in a data graph <code>DG</code> is a <a>target</a> from <code>DG</code> for <code>s</code> in <code>SG</code>.
						</div>
						<p>
							Please keep in mind that <code>sh:ShapeClass</code> may not be understood to be a subclass of <code>rdfs:Class</code> by some SHACL-unaware implementations.
							It is therefore recommended (but not required) that graphs that use <code>sh:ShapeClass</code> include an <code>owl:imports sh:</code> statement.
						</p>
						<p><em>The remainder of this section is informative.</em></p>
						<p>
							In the following example, <code>ex:Alice</code> is a focus node, because it is a <a>SHACL instance</a> of
							<code>ex:Person</code> which is both a class and a shape in the <a>shapes graph</a>.
						</p>
						<aside class="example">
							<div class="shapes-graph">
								<div class="turtle">
ex:Person
	<b>a rdfs:Class</b>, sh:NodeShape .
								</div>
								<div class="jsonld">
									<pre class="jsonld">{
	"@id": "ex:Person",
	"@type": [
		"rdfs:Class",
		"sh:NodeShape"
	]
}</pre>
								</div>
							<div class="shaclc"><pre class="shaclc">shapeClass ex:Person {
}</pre></div></div>
							<div class="data-graph">
								<div class="turtle">
<span class="focus-node-selected">ex:Alice</span> a ex:Person .
ex:NewYork a ex:Place .
								</div>
								<div class="jsonld">
									<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:Alice",
			"@type": "ex:Person"
		},
		{
			"@id": "ex:NewYork",
			"@type": "ex:Place"
		}
	]
}</pre>
								</div>
							</div>
						</aside>
						<p>
							In the following variation of the example above, <code>ex:Person</code> is declared as an instance of <code>sh:ShapeClass</code>,
							with the same interpretation.
						</p>
						<aside class="example">
							<div class="shapes-graph">
								<div class="turtle">
ex:Person
	<b>a sh:ShapeClass</b> .
								</div>
								<div class="jsonld">
									<pre class="jsonld">{
	"@id": "ex:Person",
	"@type": "sh:ShapeClass"
}</pre>
								</div>
							</div>
						</aside>
					</section>
					
					<section id="targetSubjectsOf">
						<h4>Subjects-of targets (sh:targetSubjectsOf)</h4>
						<p class="syntax">
							A <dfn>subjects-of target</dfn> is specified with the predicate <code>sh:targetSubjectsOf</code>.
							<span data-syntax-rule="targetSubjectsOf-nodeKind">The <a>values</a> of <code>sh:targetSubjectsOf</code> in a shape are <a>IRIs</a>.</span>
						</p>
						<div class="def">
							<div class="def-header">TEXTUAL DEFINITION</div>
							If <code>s</code> is a shape in a shapes graph <code>SG</code> and <code>s</code> has <a>value</a>
							<code>p</code> for <code>sh:targetSubjectsOf</code> in <code>SG</code> then the set of nodes in a
							data graph <code>DG</code> that are <a>subjects</a> of triples in <code>DG</code> with <a>predicate</a>
							<code>p</code> is a <a>target</a> from <code>DG</code> for <code>s</code> in <code>SG</code>.
						</div>
						<p><em>The remainder of this section is informative.</em></p>
						<aside class="example">
							<div class="shapes-graph">
								<div class="turtle">
ex:TargetSubjectsOfExampleShape
	a sh:NodeShape ;
	sh:targetSubjectsOf ex:knows .
								</div>
								<div class="jsonld">
									<pre class="jsonld">{
	"@id": "ex:TargetSubjectsOfExampleShape",
	"@type": "sh:NodeShape",
	"sh:targetSubjectsOf": {
		"@id": "ex:knows"
	}
}</pre>
								</div>
							<div class="shaclc"><pre class="shaclc">shape ex:TargetSubjectsOfExampleShape {
	targetSubjectsOf=ex:knows .
}</pre></div></div>
							<div class="data-graph">
								<div class="turtle">
<span class="focus-node-selected">ex:Alice</span> ex:knows ex:Bob .
ex:Bob ex:livesIn ex:NewYork .
								</div>
								<div class="jsonld">
									<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:Alice",
			"ex:knows": {
				"@id": "ex:Bob"
			}
		},
		{
			"@id": "ex:Bob",
			"ex:livesIn": {
				"@id": "ex:NewYork"
			}
		}
	]
}</pre>
								</div>
							</div>
						</aside>
						<p>
							In the example above, only <code>ex:Alice</code> is validated against the given shape,
							because it is the <a>subject</a> of a <a>triple</a> that has <code>ex:knows</code> as its <a>predicate</a>.
						</p>
					</section>
					
					<section id="targetObjectsOf">
						<h4>Objects-of targets (sh:targetObjectsOf)</h4>
						<p class="syntax">
							An <dfn>objects-of target</dfn> is specified with the predicate <code>sh:targetObjectsOf</code>.
							<span data-syntax-rule="targetObjectsOf-nodeKind">The <a>values</a> of <code>sh:targetObjectsOf</code> in a shape are <a>IRIs</a>.</span>
						</p>
						<div class="def">
							<div class="def-header">TEXTUAL DEFINITION</div>
							If <code>s</code> is a shape in a shapes graph <code>SG</code> and <code>s</code> has <a>value</a>
							<code>p</code> for <code>sh:targetObjectsOf</code> in <code>SG</code> then the set of nodes in a
							data graph <code>DG</code> that are <a>objects</a> of triples in <code>DG</code> with <a>predicate</a>
							<code>p</code> is a <a>target</a> from <code>DG</code> for <code>s</code> in <code>SG</code>.
						</div>
						<p><em>The remainder of this section is informative.</em></p>
						<aside class="example">
							<div class="shapes-graph">
								<div class="turtle">
ex:TargetObjectsOfExampleShape
	a sh:NodeShape ;
	sh:targetObjectsOf ex:knows .
								</div>
								<div class="jsonld">
									<pre class="jsonld">{
	"@id": "ex:TargetObjectsOfExampleShape",
	"@type": "sh:NodeShape",
	"sh:targetObjectsOf": {
		"@id": "ex:knows"
	}
}</pre>
								</div>
							<div class="shaclc"><pre class="shaclc">shape ex:TargetObjectsOfExampleShape {
	targetObjectsOf=ex:knows .
}</pre></div></div>
							<div class="data-graph">
								<div class="turtle">
ex:Alice ex:knows <span class="focus-node-selected">ex:Bob</span> .
ex:Bob ex:livesIn ex:NewYork .
								</div>
								<div class="jsonld">
									<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:Alice",
			"ex:knows": {
				"@id": "ex:Bob"
			}
		},
		{
			"@id": "ex:Bob",
			"ex:livesIn": {
				"@id": "ex:NewYork"
			}
		}
	]
}</pre>
								</div>
							</div>
						</aside>
						<p>
							In the example above, only <code>ex:Bob</code> is validated against the given shape,
							because it is the <a>object</a> of a <a>triple</a> that has <code>ex:knows</code> as its <a>predicate</a>.
						</p>
					</section>
				</section>

				<section id="severity">
					<h4>Declaring the Severity of a Shape or Constraint</h4>
					<p class="syntax">
						<span data-syntax-rule="severity-maxCount">Shapes can specify one <a>value</a> for the property <code>sh:severity</code> in the <a>shapes graph</a>.</span>
						<span data-syntax-rule="severity-nodeKind">Each value of <code>sh:severity</code> is an <a>IRI</a>.</span>
					</p>
					<p>
						The values of <code>sh:severity</code> are called <dfn data-lt="severity">severities</dfn>.
						SHACL includes the three IRIs listed in the table below to represent <a>severities</a>.
						These are declared in the SHACL vocabulary as SHACL instances of <code>sh:Severity</code>.
					</p>
					<table class="term-table">
						<tbody><tr>
							<th>Severity</th>
							<th>Description</th>
						</tr>
						<tr>
							<td><code>sh:Trace</code></td>
							<td>A trace message that is not a violation.</td>
						</tr>
						<tr>
							<td><code>sh:Debug</code></td>
							<td>A debug message that is not a violation.</td>
						</tr>
						<tr>
							<td><code>sh:Info</code></td>
							<td>A non-critical constraint violation indicating an informative message.</td>
						</tr>
						<tr>
							<td><code>sh:Warning</code></td>
							<td>A non-critical constraint violation indicating a warning.</td>
						</tr>
						<tr>
							<td><code>sh:Violation</code></td>
							<td>A constraint violation.</td>
						</tr>
					</tbody></table>
					<p>
						Validation engines MAY treat <code>sh:Info</code> and <code>sh:Warning</code> as non-violating based on
						options passed to the engine. By default, they are treated as violations.
					</p>
					<p>
						In addition to declaring severities per shape, the property <code>sh:severity</code> can also be used
						on a <a>reifier</a> for a triple where the <a>shape</a> is the <a>subject</a> and one of the <a>parameters</a>
						of the <a>constraint</a> is the <a>predicate</a>.
					</p>
					<p class="syntax">
						<span data-syntax-rule="severity-reifier-maxCount">
						Let <code>T</code> be the set of <a>triples</a> that represent a <a>constraint</a> in a <a>shape</a>.
						A <a>shapes graph</a> can specify at most one <a>value</a> for the property <code>sh:severity</code>
						in the <a>reifiers</a> of the <a>triples</a> in <code>T</code>.
					</span></p>
					<p><em>The remainder of this section is informative.</em></p>
					<p>
						The specific values of <code>sh:severity</code> have no impact on the validation,
						but MAY be used by user interface tools to categorize validation results.
						The values of <code>sh:severity</code> are used by SHACL processors to populate the <code>sh:resultSeverity</code> field of
						validation results, see <a href="#results-severity">section on severity in validation results</a>.
						Any IRI can be used as a severity.
					</p>
					<p>
						For every shape and constraint, <code>sh:Violation</code> is the default if <code>sh:severity</code> is unspecified.
						The following example illustrates this.
					</p>
					<aside class="example">
						<div class="shapes-graph">
							<div class="turtle">
ex:MyShape
	a sh:NodeShape ;
	<span class="target-can-be-skipped">sh:targetNode ex:MyInstance ;</span>
	sh:property [    # _:b1
		# Violations of sh:minCount and sh:datatype are produced as warnings
		sh:path ex:myProperty ;
		sh:minCount 1 ;
		sh:datatype xsd:string ;
		sh:severity sh:Warning ;
	] ;
	sh:property [    # _:b2
		# The default severity here is sh:Violation
		sh:path ex:myProperty ;
		sh:maxLength 10 ;
		sh:message "Too many characters"@en ;
		sh:message "Zu viele Zeichen"@de ;
	] .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@id": "ex:MyShape",
	"@type": "sh:NodeShape",
	"sh:property": [
		{
			"sh:datatype": {
				"@id": "xsd:string"
			},
			"sh:minCount": {
				"@type": "xsd:integer",
				"@value": "1"
			},
			"sh:path": {
				"@id": "ex:myProperty"
			},
			"sh:severity": {
				"@id": "sh:Warning"
			}
		},
		{
			"sh:maxLength": {
				"@type": "xsd:integer",
				"@value": "10"
			},
			"sh:message": [
				{
					"@language": "en",
					"@value": "Too many characters"
				},
				{
					"@language": "de",
					"@value": "Zu viele Zeichen"
				}
			],
			"sh:path": {
				"@id": "ex:myProperty"
			}
		}
	],
	"sh:targetNode": {
		"@id": "ex:MyInstance"
	}
}</pre>
							</div>
						<div class="shaclc"><pre class="shaclc">shape ex:MyShape {
	targetNode=ex:MyInstance .
	ex:myProperty xsd:string [1..*] severity=Warning .
	ex:myProperty maxLength=10 message="Too many characters"@en message="Zu viele Zeichen"@de .
}</pre></div></div>
						<div class="data-graph">
							<div class="turtle">
ex:MyInstance
	ex:myProperty "http://toomanycharacters"^^xsd:anyURI .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@id": "ex:MyInstance",
	"ex:myProperty": {
		"@type": "xsd:anyURI",
		"@value": "http://toomanycharacters"
	}
}</pre>
							</div>
						</div>
						<div class="results-graph">
							<div class="turtle">
[	a sh:ValidationReport ;
	sh:conforms false ;
	sh:result
	[	a sh:ValidationResult ;
		sh:resultSeverity sh:Warning ;
		sh:focusNode ex:MyInstance ;
		sh:resultPath ex:myProperty ;
		sh:value "http://toomanycharacters"^^xsd:anyURI ;
		sh:sourceConstraintComponent sh:DatatypeConstraintComponent ;
		sh:sourceShape _:b1 ;
	] ,
	[	a sh:ValidationResult ;
		sh:resultSeverity sh:Violation ;
		sh:focusNode ex:MyInstance ;
		sh:resultPath ex:myProperty ;
		sh:value "http://toomanycharacters"^^xsd:anyURI ;
		sh:resultMessage "Too many characters"@en ;
		sh:resultMessage "Zu viele Zeichen"@de ;
		sh:sourceConstraintComponent sh:MaxLengthConstraintComponent ;
		sh:sourceShape _:b2 ;
	]
] .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@type": "sh:ValidationReport",
	"sh:conforms": {
		"@type": "xsd:boolean",
		"@value": "false"
	},
	"sh:result": [
		{
			"@type": "sh:ValidationResult",
			"sh:focusNode": {
				"@id": "ex:MyInstance"
			},
			"sh:resultPath": {
				"@id": "ex:myProperty"
			},
			"sh:resultSeverity": {
				"@id": "sh:Warning"
			},
			"sh:sourceConstraintComponent": {
				"@id": "sh:DatatypeConstraintComponent"
			},
			"sh:sourceShape": {
				"@id": "_:b1"
			},
			"sh:value": {
				"@type": "xsd:anyURI",
				"@value": "http://toomanycharacters"
			}
		},
		{
			"@type": "sh:ValidationResult",
			"sh:focusNode": {
				"@id": "ex:MyInstance"
			},
			"sh:resultMessage": [
				{
					"@language": "en",
					"@value": "Too many characters"
				},
				{
					"@language": "de",
					"@value": "Zu viele Zeichen"
				}
			],
			"sh:resultPath": {
				"@id": "ex:myProperty"
			},
			"sh:resultSeverity": {
				"@id": "sh:Violation"
			},
			"sh:sourceConstraintComponent": {
				"@id": "sh:MaxLengthConstraintComponent"
			},
			"sh:sourceShape": {
				"@id": "_:b2"
			},
			"sh:value": {
				"@type": "xsd:anyURI",
				"@value": "http://toomanycharacters"
			}
		}
	]
}</pre>
							</div>
						</div>
					</aside>
					<p>
						The following example is a variation of the shapes graph above, but using reification to
						specify the severity of individual constraints:
					</p>
					<aside class="example">
						<div class="shapes-graph">
							<div class="turtle">
ex:MyShape
	a sh:NodeShape ;
	<span class="target-can-be-skipped">sh:targetNode ex:MyInstance ;</span>
	sh:property [    # _:b1
		sh:path ex:myProperty ;
		sh:minCount 1 {| sh:severity sh:Info |} ;
		sh:datatype xsd:string {| sh:severity sh:Warning |} ;
	] ;
	sh:property [    # _:b2
		# The default severity here is sh:Violation
		sh:path ex:myProperty ;
		sh:maxLength 10 ;
		sh:message "Too many characters"@en ;
		sh:message "Zu viele Zeichen"@de ;
	] .
							</div>
							<div class="jsonld">
								N/A
							</div>
						</div>
					</aside>
				</section>
				
				<section id="message">
					<h4>Declaring Messages for a Shape or Constraint</h4>
					<p class="syntax">
						Shapes can have values for the property <code>sh:message</code>.
						<span data-syntax-rule="message-datatype">The values of <code>sh:message</code> are either <code>xsd:string</code> literals or literals with a language tag.</span>
						A subject should not have more than one value for <code>sh:message</code> with the same language tag.
					</p>
					<p>
						If a shape has at least one value for <code>sh:message</code> in the shapes graph, then
						all <a>validation results</a> produced as a result of the shape will have exactly these messages
						as their value of <code>sh:resultMessage</code>, i.e. the values will be copied from the shapes graph
						into the results graph.
					</p>
					<p>
						In addition to declaring messages per shape, the property <code>sh:message</code> can also be used
						on a <a>reifier</a> for a triple where the <a>shape</a> is the <a>subject</a> and one of the <a>parameters</a>
						of the <a>constraint</a> is the <a>predicate</a>.
					</p>
					<p class="syntax">
						<span data-syntax-rule="message-reifier-maxCount">
						Let <code>T</code> be the set of <a>triples</a> that represent a <a>constraint</a> in a <a>shape</a>.
						A <a>shapes graph</a> can specify at most one <a>value</a> for the property <code>sh:message</code>
						in the <a>reifiers</a> of the <a>triples</a> in <code>T</code>.
					</span></p>
					<p><em>The remainder of this section is informative.</em></p>
					<p>
						See the <a href="#results-message">section on <code>sh:resultMessage</code> in the validation results</a>
						on further details on how the values of <code>sh:resultMessage</code> are populated.
					</p>
					<p>
						The example from the previous section uses this mechanism to supply the second validation result
						with two messages.
						The following example is a variation where the message is declared using reification.
					</p>
					<aside class="example">
						<div class="shapes-graph">
							<div class="turtle">
ex:MyShape
	a sh:NodeShape ;
	<span class="target-can-be-skipped">sh:targetNode ex:MyInstance ;</span>
	sh:property [
		sh:path ex:myProperty ;
		sh:maxLength 10 {|
			sh:message "Too many characters"@en ;
			sh:message "Zu viele Zeichen"@de ;
		|}
	] .
							</div>
							<div class="jsonld">
								N/A
							</div>
						</div>
					</aside>
				</section>
				
				<section id="deactivated">
					<h4>Deactivating Shapes and Constraints</h4>
					<p class="syntax">
						<span data-syntax-rule="deactivated-maxCount">Shapes can have at most one value for the property <code>sh:deactivated</code>.</span>
						<span data-syntax-rule="deactivated-datatype">The value of <code>sh:deactivated</code> is a <a>node expression</a>
						that must have either <code>true</code> or <code>false</code> as the (only) <a>output node</a>.</span>
					</p>
					<p>
						Let <code>expr</code> be the <a>value</a> of <code>sh:deactivated</code> in a <a>shape</a>.
						If <code>evalExpr(expr, <a>data graph</a>, <a>focus node</a>, {})</code> produces <code>true</code> as its only
						<a>output node</a>, the shape is called <dfn data-lt="deactivate">deactivated</dfn>.
						All RDF terms <a>conform</a> to a deactivated shape.
					</p>
					<p>
						In addition to deactivating all constraints for a shape, it is also possible to deactivate individual constraints.
						This is done using reification.
					</p>
					<p class="syntax">
						<span data-syntax-rule="deactivated-reified-maxCount">A <a>triple</a> that has a <a>shape</a> as <a>subject</a>,
						a <a>parameter</a> (such as <code>sh:minCount</code>) as <a>predicate</a> can have at most one
						<a>reifier</a> with a <a>value</a> for the property <code>sh:deactivated</code>.</span>
					</p>
					<p>
						Let <code>expr</code> be the <a>value</a> of <code>sh:deactivated</code> in a <a>reifier</a> on a <a>triple</a>
						that has <a>shape</a> <a>subject</a> and a <a>parameter</a> as <a>predicate</a>.
						If <code>evalExpr(expr, <a>data graph</a>, <a>focus node</a>, {})</code> produces <code>true</code> as its only
						<a>output node</a>, the constraints that use the <a>triple</a> are called <dfn data-lt="deactivated constraint">deactivated constraints</dfn>.
						Deactivated constraints do not produce any validation results.
					</p>
					<p><em>The remainder of this section is informative.</em></p>
					<p>
						In SHACL Core, the only valid values for <code>sh:deactivated</code> are the 
						<a href="#LiteralExpression">constant literal node expressions</a>
						<code>true</code> and <code>false</code>.
					</p>
					<p>
						Use cases of this feature include shape reuse and debugging.
						In scenarios where shapes from other graphs or files are imported into a given <a>shapes graph</a>,
						<code>sh:deactivated</code> can be set to <code>true</code> in the local shapes graph for imported shapes
						to exclude shapes that do not apply in the current application context.
						This makes it possible to reuse SHACL graphs developed by others even if you disagree with certain assumptions made by the original authors.
						If a shape author anticipates that a shape may need to be disabled or modified by others, it is a good practice to use <a>IRIs</a> instead of <a>blank nodes</a>
						for the actual shapes.  For example, a <a>property shape</a> for the property <code>ex:name</code> at the shape <code>ex:PersonShape</code> may have the IRI <code>ex:PersonShape-name</code>.
						Another typical use case of <code>sh:deactivated</code> is during the development and testing of shapes, to (temporarily) disable certain shapes.
					</p>
					<p>
						The following example illustrates the use of <code>sh:deactivated</code> to deactivate a shape.
						In cases where shapes are imported from other graphs, the <code>sh:deactivated true</code> triple would be in the importing graph.
					</p>
					<aside class="example" title="Deactivating a property shape">
						<div class="shapes-graph">
							<div class="turtle">
ex:PersonShape
	a sh:NodeShape ;
	<span class="target-can-be-skipped">sh:targetClass ex:Person ;</span>
	sh:property ex:PersonShape-name .

ex:PersonShape-name
	a sh:PropertyShape ;
	sh:path ex:name ;
	sh:minCount 1 ;
	sh:deactivated true .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:PersonShape",
			"@type": "sh:NodeShape",
			"sh:property": {
				"@id": "ex:PersonShape-name"
			},
			"sh:targetClass": {
				"@id": "ex:Person"
			}
		},
		{
			"@id": "ex:PersonShape-name",
			"@type": "sh:PropertyShape",
			"sh:deactivated": {
				"@type": "xsd:boolean",
				"@value": "true"
			},
			"sh:minCount": {
				"@type": "xsd:integer",
				"@value": "1"
			},
			"sh:path": {
				"@id": "ex:name"
			}
		}
	]
}</pre>
							</div>
						</div>
						<p>
							With the following data, no constraint violation will be reported even though the instance does not have any value for <code>ex:name</code>. 
						</p>
						<div class="data-graph">
							<div class="turtle">
ex:JohnDoe a ex:Person .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@id": "ex:JohnDoe",
	"@type": "ex:Person"
}</pre>
							</div>
						</div>
					</aside>
					<p>
						The following variation uses reification to deactivate just the <code>sh:minCount</code>
						constraint without affecting other constraints at the same property shape.
					</p>
					<aside class="example" title="Deactivating individual constraints using reification">
						<div class="shapes-graph">
							<div class="turtle">
ex:PersonShape
	a sh:NodeShape ;
	<span class="target-can-be-skipped">sh:targetClass ex:Person ;</span>
	sh:property ex:PersonShape-name .

ex:PersonShape-name
	a sh:PropertyShape ;
	sh:path ex:name ;
	sh:minCount 1 {| sh:deactivated true |} ;
	sh:maxCount 1 .
							</div>
							<div class="jsonld">
							</div>
						</div>
					</aside>
				</section>
			</section>
			
			<section id="node-shapes">
				<h3>Node Shapes</h3>
				<p class="syntax">
					A <dfn data-lt="node shapes">node shape</dfn> is a <a>shape</a> in the <a>shapes graph</a> that
					is not the <a>subject</a> of a <a>triple</a> with <code>sh:path</code> as its <a>predicate</a>.
					It is recommended, but not required, for a <a>node shape</a> to be declared as a <a>SHACL instance</a> of <code>sh:NodeShape</code>.
					<span data-syntax-rule="NodeShape-path-maxCount"><a>SHACL instances</a> of <code>sh:NodeShape</code> cannot have a <a>value</a> for the property <code>sh:path</code>.</span>
				</p>
				<p>
					Informally, node shapes specify constraints that need to be met with respect to <a>focus nodes</a>.
					In contrast to <a>property shapes</a> they primarily apply to the focus node itself, not to its property values.
				</p>
			</section>
			
			<section id="property-shapes">
				<h3>Property Shapes</h3>
				<p class="syntax">
					<span data-syntax-rule="PropertyShape">A <dfn data-lt="property shapes">property shape</dfn> is a <a>shape</a> in the <a>shapes graph</a>
					that is the <a>subject</a> of a <a>triple</a> that has <code>sh:path</code> as its <a>predicate</a>.</span>
					<span data-syntax-rule="path-maxCount">A shape has at most one <a>value</a> for <code>sh:path</code>.</span>
					<span data-syntax-rule="path-node">The <a>value</a> of <code>sh:path</code> in a property shape is a <a>well-formed</a>
					<a>SHACL property path</a>.</span>
					<br><br>
					It is recommended, but not required, for a <a>property shape</a> to be declared as a <a>SHACL instance</a> of <code>sh:PropertyShape</code>.
					<span data-syntax-rule="PropertyShape-path-minCount"><a>SHACL instances</a> of <code>sh:PropertyShape</code> have one <a>value</a> for the property <code>sh:path</code>.</span>
					<br><br>
					<span data-syntax-rule="path-values">A <a>property shape</a> has at most one <a>value</a> for the property <code>sh:values</code> and this <a>value</a> is a <a>well-formed</a> <a>node expression</a>.</span>
					<span data-syntax-rule="path-defaultValue">A <a>property shape</a> has at most one <a>value</a> for the property <code>sh:defaultValue</code> and this <a>value</a> is a <a>well-formed</a> <a>node expression</a>.</span>
					<span data-syntax-rule="path-values-iri">A <a>property shape</a> can only have <a>values</a> for <code>sh:values</code> and/or <code>sh:defaultValue</code> when its <a>value</a> for <code>sh:path</code> is a <a href="#property-path-predicate">Predicate Path</a>.</span>
				</p>
				<p>
					Informally, property shapes specify constraints that need to be met with respect to <a>nodes</a> that can be reached from the
					<a>focus node</a> by 
					(a) directly following a given property (specified as an <a>IRI</a> using <code>sh:path</code>),
					(b) directly following any other <a>SHACL property path</a> (specified using <code>sh:path</code>), 
					(c) evaluating the node expression specified using <code>sh:values</code>, or,
					(d) if no other values exist, evaluating the node expression specified using <code>sh:defaultValue</code>.
				</p>
				<p>
					Note that support for <code>sh:values</code> and <code>sh:defaultValue</code> is not required by SHACL Core,
					but is necessary for extensions such as [[shacl12-sparql]].
				</p>
				<p>
					Note that the definitions of <a>well-formed</a> <a>property shapes</a> and <a>node shapes</a> make these two sets of nodes disjoint.
				</p>
				<p>
					The following example illustrates some syntax variations of property shapes.
				</p>
				<aside class="example">
					<div class="shapes-graph">
						<div class="turtle">
ex:ExampleNodeShapeWithPropertyShapes
	a sh:NodeShape ;
	sh:property [
		sh:path ex:email ;
		sh:name "e-mail" ;
		sh:description "We need at least one email value" ;
		sh:minCount 1 ;
	] ;
	sh:property [
		sh:path (ex:knows ex:email) ;
		sh:name "Friend's e-mail" ;
		sh:description "We need at least one email for everyone you know" ;
		sh:minCount 1 ;
	] .
	
ex:ExamplePropertyShape
	a sh:PropertyShape ;
	sh:path ex:email ;
	sh:description "We need at least one email value" ;
	sh:minCount 1 .
						</div>
						<div class="jsonld">
							<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:ExampleNodeShapeWithPropertyShapes",
			"@type": "sh:NodeShape",
			"sh:property": [
				{
					"sh:description": "We need at least one email value",
					"sh:minCount": {
						"@type": "xsd:integer",
						"@value": "1"
					},
					"sh:name": "e-mail",
					"sh:path": {
						"@id": "ex:email"
					}
				},
				{
					"sh:description": "We need at least one email for everyone you know",
					"sh:minCount": {
						"@type": "xsd:integer",
						"@value": "1"
					},
					"sh:name": "Friend's e-mail",
					"sh:path": {
						"@list": [
							{
								"@id": "ex:knows"
							},
							{
								"@id": "ex:email"
							}
						]
					}
				}
			]
		},
		{
			"@id": "ex:ExamplePropertyShape",
			"@type": "sh:PropertyShape",
			"sh:description": "We need at least one email value",
			"sh:minCount": {
				"@type": "xsd:integer",
				"@value": "1"
			},
			"sh:path": {
				"@id": "ex:email"
			}
		}
	]
}</pre>
						</div>
					</div>
				</aside>
			</section>
		</section>

		<section id="property-paths">
			<h2>SHACL Property Paths</h2>
			<p>
				Property paths can be used at <a href="#property-shapes"><code>sh:path</code></a> to derive the <a>value nodes</a> of a property shape.
			</p>
			<p>
				SHACL includes RDF terms to represent the following subset of <a>SPARQL property paths</a>:
				<code>PredicatePath</code>, <code>InversePath</code>, <code>SequencePath</code>, <code>AlternativePath</code>,
				<code>ZeroOrMorePath</code>, <code>OneOrMorePath</code> and <code>ZeroOrOnePath</code>.
			</p>
			<p>
				The following sub-sections provide syntax rules of <a>well-formed</a> <a>SHACL property paths</a>
				together with mapping rules to <a href="https://www.w3.org/TR/sparql12-query/#pp-language">SPARQL 1.2 property paths</a>.
				These rules define the <dfn>path mapping</dfn> <code>path(p,G)</code> in an RDF graph <code>G</code> of an RDF term <code>p</code> that is a SHACL property path in <code>G</code>.
				Two SHACL property paths are considered <dfn data-lt="equivalent path">equivalent paths</dfn> when they map to the exact same SPARQL property paths.
			</p>
			<p class="syntax">
				<span data-syntax-rule="path-metarule">A node in an RDF graph is a <a>well-formed</a> <dfn data-lt="SHACL property paths">SHACL property path</dfn> <code>p</code> if it satisfies exactly one of the syntax rules in the following sub-sections.</span>
				<span data-syntax-rule="path-non-recursive">A node <code>p</code> is not a <a>well-formed</a> SHACL property path if <code>p</code> is a blank node and any path mappings of <code>p</code> directly or transitively reference <code>p</code>.</span>
			</p>
			<p>
				The following example illustrates some valid SHACL property paths, together with their SPARQL 1.2 equivalents.
			</p>
			<aside class="example" title="Some valid property path expressions and their SPARQL 1.2 equivalents">
				<div class="shapes-graph">
					<div class="turtle">
# SPARQL Property path: ex:parent
ex:SomeClass-predicateExample
	sh:path ex:parent .

# SPARQL Property path: ^ex:parent
ex:SomeClass-inversePathExample
	sh:path [ 
		sh:inversePath ex:parent 
	] .

# SPARQL Property path: ex:parent/ex:firstName
ex:SomeClass-sequencePathExample
	sh:path ( 
		ex:parent 
		ex:firstName 
	) .

# SPARQL Property path: rdf:type/rdfs:subClassOf*
ex:SomeClass-complexPathExample
	sh:path ( 
		rdf:type 
		[ sh:zeroOrMorePath rdfs:subClassOf ] 
	) .

# SPARQL Property path: ex:father|ex:mother
ex:SomeClass-alternativePathExample
	sh:path [ 
		sh:alternativePath ( ex:father ex:mother  ) 
	] .						
					</div>
					<div class="jsonld">
						<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:SomeClass-alternativePathExample",
			"sh:path": {
				"sh:alternativePath": {
					"@list": [
						{
							"@id": "ex:father"
						},
						{
							"@id": "ex:mother"
						}
					]
				}
			}
		},
		{
			"@id": "ex:SomeClass-complexPathExample",
			"sh:path": {
				"@list": [
					{
						"@id": "rdf:type"
					},
					{
						"sh:zeroOrMorePath": {
							"@id": "rdfs:subClassOf"
						}
					}
				]
			}
		},
		{
			"@id": "ex:SomeClass-inversePathExample",
			"sh:path": {
				"sh:inversePath": {
					"@id": "ex:parent"
				}
			}
		},
		{
			"@id": "ex:SomeClass-predicateExample",
			"sh:path": {
				"@id": "ex:parent"
			}
		},
		{
			"@id": "ex:SomeClass-sequencePathExample",
			"sh:path": {
				"@list": [
					{
						"@id": "ex:parent"
					},
					{
						"@id": "ex:firstName"
					}
				]
			}
		}
	]
}</pre>
					</div>
				</div>
			</aside>
			<section id="property-path-predicate">
				<h3>Predicate Paths</h3>
				<p class="syntax">
					A <dfn>predicate path</dfn> is an <a>IRI</a>.
				</p>
				<p>
					If <code>p</code> is a <a>predicate path</a>, then <code>path(p,G)</code> is
					a SPARQL <code>PredicatePath</code> with <code>p</code> as <code>iri</code>.
				</p>
			</section>
			<section id="property-path-sequence">
				<h3>Sequence Paths</h3>
				<p class="syntax" data-syntax-rule="path-sequence">
					A <dfn>sequence path</dfn> is a <a>blank node</a> that is a <a>SHACL list</a>
					with at least two <a>members</a> and each member is a <a>well-formed</a> SHACL property path.
				</p>
				<p>
					If <code>p</code> is a <a>sequence path</a> in <code>G</code> with list <a>members</a>
					<code>v<sub>1</sub></code>, <code>v<sub>2</sub></code>, ..., <code>v<sub>n</sub></code>,
					then <code>path(p,G)</code> is a SPARQL <code>SequencePath</code> of
					<code>path(v<sub>1</sub>,G)</code> as <code>elt1</code>, and the results of the <a>path mapping</a>
					of the list node of <code>v<sub>2</sub></code> as <code>elt2</code>.
				</p>
				<p>
					Informal note: the <a>nodes</a> in such a <a>SHACL list</a> should not have <a>values</a> for
					other properties beside <code>rdf:first</code> and <code>rdf:rest</code>.
				</p>
			</section>
			<section id="property-path-alternative">
				<h3>Alternative Paths</h3>
				<p class="syntax" data-syntax-rule="path-alternative">
					An <dfn>alternative path</dfn> is a <a>blank node</a> that is the subject of exactly one triple in <code>G</code>.
					This triple has <code>sh:alternativePath</code> as predicate, <code>L</code> as object,
					and <code>L</code> is a <a>SHACL list</a> with at least two <a>members</a>
					and each member of <code>L</code> is a <a>well-formed</a> SHACL property path.
				</p>
				<p>
					If <code>p</code> is an <a>alternative path</a> in <code>G</code>,
					then, for the members of its SHACL list <code>L</code>:
					<code>v<sub>1</sub></code>, <code>v<sub>2</sub></code>, ..., <code>v<sub>n</sub></code>,
					<code>path(p,G)</code> is a SPARQL <code>AlternativePath</code> with
					<code>path(v<sub>1</sub>,G)</code> as <code>elt1</code> followed by an <code>AlternativePath</code>
					for <code>v<sub>2</sub></code> as <code>elt2</code>, ..., up to <code>path(v<sub>n</sub>,G)</code>.
				</p>
			</section>
			<section id="property-path-inverse">
				<h3>Inverse Paths</h3>
				<p class="syntax" data-syntax-rule="path-inverse">
					An <dfn>inverse path</dfn> is a <a>blank node</a> that is the <a>subject</a> of exactly one <a>triple</a> in <code>G</code>.
					This triple has <code>sh:inversePath</code> as predicate, and the <a>object</a> <code>v</code> is a <a>well-formed</a> SHACL property path.
				</p>
				<p>
					If <code>p</code> is an <a>inverse path</a> in <code>G</code>, then <code>path(p,G)</code> is a
					SPARQL <code>InversePath</code> with <code>path(v,G)</code> as its <code>elt</code>.
				</p>
			</section>
			<section id="property-path-zero-or-more">
				<h3>Zero-Or-More Paths</h3>
				<p class="syntax" data-syntax-rule="path-zero-or-more">
					A <dfn>zero-or-more path</dfn> is a <a>blank node</a> that is the <a>subject</a> of exactly one <a>triple</a> in <code>G</code>.
					This triple has <code>sh:zeroOrMorePath</code> as <a>predicate</a>, and the <a>object</a> <code>v</code> is a <a>well-formed</a> SHACL property path.
				</p>
				<p>
					If <code>p</code> is a <a>zero-or-more path</a> in <code>G</code>, then <code>path(p,G)</code> is a
					SPARQL <code>ZeroOrMorePath</code> with <code>path(v,G)</code> as its <code>elt</code>.
				</p>
			</section>
			<section id="property-path-one-or-more">
				<h3>One-Or-More Paths</h3>
				<p class="syntax" data-syntax-rule="path-one-or-more">
					A <dfn>one-or-more path</dfn> is a <a>blank node</a> that is the <a>subject</a> of exactly one <a>triple</a> in <code>G</code>.
					This triple has <code>sh:oneOrMorePath</code> as <a>predicate</a>, and the <a>object</a> <code>v</code> is a <a>well-formed</a> SHACL property path.
				</p>
				<p>
					If <code>p</code> is a <a>one-or-more path</a> in <code>G</code>, then <code>path(p,G)</code> is a
					SPARQL <code>OneOrMorePath</code> with <code>path(v,G)</code> as its <code>elt</code>.
				</p>
			</section>
			<section id="property-path-zero-or-one">
				<h3>Zero-Or-One Paths</h3>
				<p class="syntax" data-syntax-rule="path-zero-or-one">
					A <dfn>zero-or-one path</dfn> is a <a>blank node</a> that is the <a>subject</a> of exactly one <a>triple</a> in <code>G</code>.
					This triple has <code>sh:zeroOrOnePath</code> as <a>predicate</a>, and the <a>object</a> <code>v</code> is a <a>well-formed</a> SHACL property path.
				</p>
				<p>
					If <code>p</code> is a <a>zero-or-one path</a> in <code>G</code>, then <code>path(p,G)</code> is a
					SPARQL <code>ZeroOrOnePath</code> with <code>path(v,G)</code> as its <code>elt</code>.
				</p>
			</section>
		</section>

		<section id="node-expressions">
			<h2>Node Expressions</h2>
			<p>
				This section introduces the concept of <a>node expressions</a>.
				SHACL Core supports node expressions in the following features:
			</p>
			<ul>
				<li>At <a href="#property-shapes"><code>sh:values</code> and <code>sh:defaultValue</code></a> to derive the value nodes of a property shape.</li>
				<li>At <a href="#targetNode"><code>sh:targetNode</code></a> to dynamically compute the targets of a shape.</li>
				<li>At <a href="#NodeByExpressionConstraintComponent"><code>sh:nodeByExpression</code></a> to validate nodes against a dynamically computed set of node shapes.</li>
				<li>At <a href="#ExpressionConstraintComponent"><code>sh:expression</code></a> to validate nodes against a condition.</li>
				<li>At <a href="#deactivated"><code>sh:deactivated</code></a> to deactivate certain shapes under specific conditions.</li>
			</ul>
			<p>
				Readers who are only interested in SHACL Core can typically skip this section.
				Given that Core only supports constant IRIs and literals as node expressions, the use cases of node expressions
				are identical to traditional use of SHACL Core.
			</p>
			<div class="def">
				<div class="def-header">TEXTUAL DEFINITION</div>
				A <dfn>node expression</dfn> is a <a>node</a> that follows the syntax rules of exactly one <dfn>node expression function</dfn>.
				Each <a>node expression function</a> has an <a>IRI</a> as its <dfn>function name</dfn>.
			</div>
			<div class="def" id="node-expression-evaluation">
				<div class="def-header">EVALUATION OF NODE EXPRESSIONS</div>
				The <dfn>evaluation</dfn> of a node expression is defined as a function <code>evalExpr(expr, focusGraph, focusNode, scope) -&gt; outputNodes</code>
				where
				<ul>
					<li><code>expr</code> is a <a>node expression</a> in a <a>shapes graph</a>.
					During evaluation, the engine can access <a>triples</a> related to <code>expr</code> in the <a>shapes graph</a>.</li>
					<li><code>focusGraph</code> is a <a>graph</a>, called the <dfn>focus graph</dfn>. This is the default query graph for the evaluation of the node expression.</li>
					<li><code>focusNode</code> is a <a>node</a>, called the <dfn>input focus node</dfn>. This variable may have no value.</li>
					<li><code>scope</code> is a map from <a href="https://www.w3.org/TR/sparql12-query/#defn_QueryVariable">variable names</a> to individual <a>nodes</a>.
					The empty map is written as <code>{}</code>.
					</li>
				</ul>
				The result of the evaluation of a node expression is a list of <a>nodes</a> (possibly empty and with duplicates) called the <dfn>output nodes</dfn>.
				The evaluation may also result in an <dfn>evaluation failure</dfn>.
			</div>
			<p>
				The SHACL Core specification only exactly defines the <a>node expression functions</a> based on the next two subsections.
				Other specifications such as [[shacl12-sparql]] introduce additional functions, using <a>blank nodes</a>.
				Therefore <a>node expressions</a> serve as an extension point of SHACL.
				<span class="todo">TODO: Add link to shacl12-node-expr once that is stable.</span>
			</p>
			<section id="IRIExpression">
				<h3>IRI Expressions</h3>
				<p>
					A <a>node expression</a> that is a <a>IRI</a> is called an <dfn>IRI expression</dfn> with the <a>function name</a>
					<code>sh:IRIExpression</code>.
				</p>
				<p class="syntax">
					<span data-syntax-rule="IRIExpression-syntax">A node in an RDF graph is a <a>well-formed</a> <a>IRI expression</a> if it is an <a>IRI</a>.</span>
				</p>
				<div class="def" id="IRIExpression-evaluation">
					<div class="def-header">EVALUATION OF IRI EXPRESSIONS</div>
					<p>
						The <a>output nodes</a> of an <a>IRI expression</a> are the list consisting of exactly the <a>node expression</a> itself:
						<br>
						<br>
						<code>evalExpr(expr, focusGraph, focusNode, scope) -&gt; [expr]</code>
					</p>
				</div>
			</section>
			<section id="LiteralExpression">
				<h3>Literal Expressions</h3>
				<p>
					A <a>node expression</a> that is a <a>literal</a> is called a <dfn>literal expression</dfn> with the <a>function name</a>
					<code>sh:LiteralExpression</code>.
				</p>
				<p class="syntax">
					<span data-syntax-rule="LiteralExpression-syntax">A node in an RDF graph is a <a>well-formed</a> <a>literal expression</a> if it is a <a>literal</a>.</span>
				</p>
				<div class="def" id="LiteralExpression-evaluation">
					<div class="def-header">EVALUATION OF LITERAL EXPRESSIONS</div>
					<p>
						The <a>output nodes</a> of a <a>literal expression</a> are the list consisting of exactly the <a>node expression</a> itself:
						<br>
						<br>
						<code>evalExpr(expr, focusGraph, focusNode, scope) -&gt; [expr]</code>
					</p>
				</div>
			</section>
		</section>

		<section id="validation">
			<h2>Validation and Graphs</h2>
			<p>
				<a>Validation</a> takes a <a>data graph</a> and a <a>shapes graph</a> as input and produces
				a <a>validation report</a> containing the results of the validation.
				<a>Conformance checking</a> is a simplified version of validation, producing a boolean result.
				A system that is capable of performing validation is called a <dfn>processor</dfn>,
				and the verb <dfn>processing</dfn> is sometimes used to refer to the validation process.
			</p>
			<p>
				SHACL defines an RDF <a>Validation Report Vocabulary</a> that can be used by processors that produce validation reports as RDF results graphs.
				This specification uses the SHACL results vocabulary for the normative definitions of the <a>validators</a>
				associated with the <a>constraint components</a>.
				Only SHACL implementations that can produce all of the mandatory properties of the <a>Validation Report Vocabulary</a> are standards-compliant.
			</p>

			<section id="shapes-graph">
				<h3>Shapes Graph</h3>
				<p>
					A <dfn data-lt="shapes graphs">shapes graph</dfn> is an RDF graph containing zero or more shapes
					that is passed into a SHACL <a>validation</a> process so that a <a>data graph</a> can be validated against the shapes.
				</p>
				<p><em>The remainder of this section is informative.</em></p>
				<p>
					Shapes graphs can be reusable validation modules that can be cross-referenced with the predicate <a data-cite="owl2-syntax/#Imports"><code>owl:imports</code></a>.
					As a pre-validation step, SHACL processors SHOULD extend the originally provided <a>shapes graph</a> by transitively following and importing all referenced <a>shapes graphs</a>
					through the <a data-cite="owl2-syntax/#Imports"><code>owl:imports</code></a> predicate.
					The resulting graph forms the input <a>shapes graph</a> for validation and MUST NOT be further modified during the validation process.
				</p>
				<p>
					In addition to shape declarations, the shapes graph may contain additional information for the SHACL processor such as <code>sh:entailment</code> statements.
				</p>
			</section>
			
			<section id="data-graph">
				<h3>Data Graph</h3>
				<p>
					Any RDF graph can be a <dfn data-lt="data graphs">data graph</dfn>.
				</p>
				<p><em>The remainder of this section is informative.</em></p>
				<p>
					A data graph is one of the inputs to the SHACL processor for <a>validation</a>.
					SHACL processors treat it as a general RDF graph and makes no assumption about its nature.
					For example, it can be an in-memory graph or a named graph from an RDF dataset or a SPARQL endpoint.
				</p>
				<p>
					SHACL can be used with RDF graphs that are obtained by any means, e.g. from the file system, HTTP requests, or <a data-cite="rdf12-concepts/#section-dataset">RDF datasets</a>.
					SHACL makes no assumptions about whether a graph contains triples that are entailed from the graph under any RDF entailment regime.
				</p>
				<p>
					The data graph is expected to include all the ontology axioms related to the data and especially all the
					<code>rdfs:subClassOf</code> triples in order for SHACL to correctly identify class targets and validate Core SHACL constraints.
				</p>
				<p class="note">
					<code>owl:imports</code> in the data graph is not enacted, in order to avoid uncontrolled increase of validation work. If you want to validate 
					several related ontologies, pass all of them to the SHACL processor (together or one by one), do not rely on <code>owl:imports</code> links.
				</p>
			</section>
			
			<section id="sh-shapes-graph">
				<h3>Linking to shapes graphs (sh:shapesGraph)</h3>
				<p class="syntax">
					A <a>data graph</a> can include triples used to suggest one or more graphs to a SHACL processor with the predicate <code>sh:shapesGraph</code>.
					<span data-syntax-rule="shapesGraph-nodeKind">Every <a>value</a> of <code>sh:shapesGraph</code> is an <a>IRI</a></span> representing a graph that SHOULD be included into the <a>shapes graph</a> used to validate the <a>data graph</a>.
				</p>
				<p>
					In the following example, a SHACL processor SHOULD use the union of <code>ex:graph-shapes1</code> and <code>ex:graph-shapes2</code> graphs (and their <code>owl:imports</code>) as the <a>shapes graph</a> when validating the given graph.
				</p>

				<aside class="example">
					<div class="data-graph">
						<div class="turtle">
&lt;http://example.com/myDataGraph&gt;
	sh:shapesGraph ex:graph-shapes1 ;
	sh:shapesGraph ex:graph-shapes2 .
						</div>
						<div class="jsonld">
							<pre class="jsonld">{
	"@id": "http://example.com/myDataGraph",
	"sh:shapesGraph": [
		{
			"@id": "ex:graph-shapes1"
		},
		{
			"@id": "ex:graph-shapes2"
		}
	]
}</pre>
						</div>
					</div>
				</aside>
			</section>
			
			<section id="validation-definition">
				<h3>Validation</h3>
				<p>
					<dfn data-lt="validating|validates|validated|validate">Validation</dfn> is a mapping from some input
					to <a>validation results</a>, as defined in the following paragraphs.
				</p>
				<p>
					<dfn>Validation of a data graph against a shapes graph:</dfn>
					Given a <a>data graph</a> and a <a>shapes graph</a>,
					the <a>validation results</a> are the union of results of the <a>validation</a> of the <a>data graph</a> against all
					<a>shapes</a> in the <a>shapes graph</a>.
				</p>
				<p>
					<dfn>Validation of a data graph against a shape:</dfn>
					Given a <a>data graph</a> and a <a>shape</a> in the <a>shapes graph</a>,
					the <a>validation results</a> are the union of the results of the <a>validation</a> of all
					<a>focus nodes</a> that are in the <a>target</a> of the <a>shape</a> in the <a>data graph</a>.
				</p>
				<p>
					<dfn>Validation of a focus node against a shape:</dfn>
					Given a <a>focus node</a> in the <a>data graph</a> and a <a>shape</a> in the <a>shapes graph</a>,
					the <a>validation results</a> are the union of the results of the <a>validation</a> of the <a>focus node</a> against all
					<a>constraints</a> declared by the <a>shape</a>, unless the <a>shape</a> has been <a>deactivated</a>,
					in which case the <a>validation results</a> are empty.
				</p>
				<p>
					<dfn>Validation of a focus node against a constraint:</dfn>
					Given a <a>focus node</a> in the <a>data graph</a> and a <a>constraint</a> of <a>kind</a> <code>C</code> in the <a>shapes graph</a>,
					the <a>validation results</a> are defined by the <a>validators</a> of the <a>constraint component</a> <code>C</code>.
					These <a>validators</a> typically take as input the <a>focus node</a>, the specific <a>values</a> of the <a>parameters</a> of <code>C</code>
					of the <a>constraint</a> in the <a>shapes graph</a>, and the <a>value nodes</a> of the <a>shape</a> that declares the constraint.
				</p>
				<p>
					During validation, the <a>data graph</a> and the <a>shapes graph</a> MUST remain immutable, i.e. both graphs at the end of the validation MUST be identical to the graph at the beginning of validation.
					SHACL processors MUST NOT change the graphs that they use to construct the shapes graph or the data graph,
					even if these graphs are part of an RDF store that allows changes to its stored graphs.
					SHACL processors MAY store the graphs that they create, such as a graph containing validation results,
					and this operation MAY change existing graphs in an RDF store, but not any of the graphs that were used to construct the shapes graph or the data graph.
					SHACL processing is thus idempotent.
				</p>

				<section id="failures">
					<h4>Failures</h4>
					<p>
						<a>Validation</a> and <a>conformance checking</a> can result in a <dfn data-lt="failures">failure</dfn>.
						For example, a particular SHACL processor might allow recursive shapes but report a failure
						if it detects a loop within the data.
						Failures can also be reported due to resource exhaustion.
						Failures are signalled through implementation-specific channels.
					</p>
				</section>
	
				<section id="ill-formed-shape-graphs">
					<h4>Handling of Ill-formed Shapes Graphs</h4>
					<p>
						If the <a>shapes graph</a> contains <a>ill-formed</a> nodes, then the result of the validation process is <em>undefined</em>.
						A SHACL processor SHOULD produce a <a>failure</a> in this case.
						See also <a href="#shapesGraphWellFormed"></a>.
					</p>
				</section>
	
				<section id="shapes-recursion">
					<h4>Handling of Recursive Shapes</h4>
					<p id="shape-expecting-constraint-parameters">
						The following properties are the so-called <dfn data-lt="shape-expecting">shape-expecting constraint parameters</dfn> in SHACL Core:
					</p>
					<ul>
						<li><a href="#AndConstraintComponent">sh:and</a></li>
						<li><a href="#NotConstraintComponent">sh:not</a></li>
						<li><a href="#OrConstraintComponent">sh:or</a></li>
						<li><a href="#PropertyConstraintComponent">sh:property</a></li>
						<li><a href="#QualifiedValueShapeConstraintComponent">sh:qualifiedValueShape</a></li>
						<li><a href="#NodeConstraintComponent">sh:node</a></li>
						<li><a href="#MemberShapeConstraintComponent">sh:memberShape</a></li>
						<li><a href="#MinListLengthConstraintComponent">sh:minListLength</a></li>
						<li><a href="#MaxListLengthConstraintComponent">sh:maxListLength</a></li>
						<li><a href="#UniqueMembersConstraintComponent">sh:uniqueMembers</a></li>
						<li><a href="#XoneConstraintComponent">sh:xone</a></li>
					</ul>
					<p>
						The following properties are the so-called <dfn data-lt="list-taking">list-taking constraint parameters</dfn> in SHACL Core:
					</p>
					<ul>
						<li><a href="#AndConstraintComponent">sh:and</a></li>
						<li><a href="#InConstraintComponent">sh:in</a></li>
						<li><a href="#LanguageInConstraintComponent">sh:languageIn</a></li>
						<li><a href="#OrConstraintComponent">sh:or</a></li>
						<li><a href="#XoneConstraintComponent">sh:xone</a></li>
					</ul>					
					<p>
						A shape <code>s1</code> in an RDF graph <code>G</code> <dfn>refers</dfn> to shape <code>s2</code>
						in <code>G</code> if it	has <code>s2</code> as <a>value</a> for some non-list-taking,
						shape-expecting parameter of some constraint component or <code>s2</code> as a <a>member</a> of
						the <a>value</a> for some list-taking, shape-expecting parameter of some constraint component.
						A shape in an RDF graph <code>G</code> is a <dfn data-lt="recursive">recursive shape</dfn> in <code>G</code> if it is related to
						itself by the transitive closure of the <a>refers</a> relationship in <code>G</code>.
					</p>
					<p>
						The <a>validation</a> with <a>recursive</a> shapes is not defined in SHACL and is left to SHACL processor implementations.
						For example, SHACL processors may support recursion scenarios or produce a failure when they detect recursion.
					</p>
					<p><em>The remainder of this section is informative.</em></p>
					<p>
						The recursion policy above has been selected to support a large variety of implementation strategies.
						By leaving recursion undefined, implementations may chose to not support recursion so that they
						can issue a static set of SPARQL queries (against SPARQL end points) without having to support cycles.
						The Working Group is aware that other implementations may support recursion and that some shapes graphs may
						rely on these specific characteristics.
						The expectation is that future work, for example in W3C Community Groups, will lead to the definition
						of specific dialects of SHACL where recursion is well-defined.
					</p>
				</section>
			</section>

			<section id="conformance-definition">
				<h3>Conformance Checking</h3>
				<p>
					A <a>focus node</a> <dfn data-lt="conform|conformance">conforms</dfn> to a <a>shape</a> if and only if
					the set of result of the <a>validation</a> of the <a>focus node</a> against the <a>shape</a> does not contain any results with a severity level representing a violation and no <a>failure</a>
					has been reported by it.
				</p>
				<p>
					<dfn data-lt="conformance check">Conformance checking</dfn> produces <code>true</code> if and only if a given <a>focus node</a>
					<a>conforms</a> to a given <a>shape</a>, and <code>false</code> otherwise.
				</p>
				<p id="conformance-nested">
					Note that all <a href="#shape-expecting-constraint-parameters">shape-expecting constraint parameters</a> of SHACL Core
					rely on conformance checking.
					In these cases, the <a>validation results</a> used to determine the outcome of conformance checking are
					separated from those of the surrounding validation process and typically do not end up in the same validation report
					(except perhaps as values of <a href="#results-detail"><code>sh:detail</code></a>).
				</p>
			</section>

			<section id="validation-report">
				<h3>Validation Report</h3>
				<p>
					The <dfn data-lt="validation report|report">validation report</dfn> is the result of the <a>validation</a> process that reports the <a>conformance</a> and the set of all <dfn data-lt="validation result|result">validation results</dfn>.
					The validation report is described with the SHACL <dfn>Validation Report Vocabulary</dfn> as defined in this section.
					This vocabulary defines the RDF properties to represent structural information that may provide guidance on how to identify or fix violations in the data graph.
				</p>
				<p><!-- ISSUE-181 -->
					SHACL-compliant processors MUST be capable of returning a validation report with all required <a>validation results</a>
					described in this specification.
					SHACL-compliant processors MAY support optional arguments that make it possible to limit the number of returned results.
					This flexibility is for example needed in some large-scale dataset validation use cases.
				</p>
				<p>
					The following graph represents an example of a validation report for the validation of a data graph that conforms to a shapes graph.
				</p>
				<aside class="example">
					<div class="results-graph">
						<div class="turtle">
[ 	a sh:ValidationReport ;
	sh:conforms true ;
] .
						</div>
						<div class="jsonld">
							<pre class="jsonld">{
	"@id": "_:b1",
	"@type": "sh:ValidationReport",
	"sh:conforms": {
		"@type": "xsd:boolean",
		"@value": "true"
	}
}</pre>
						</div>
					</div>
				</aside>
				<p>
					The following graph represents an example of a validation report for the validation of a data graph that does not conform to a shapes graph.
					Note that the specific value of <code>sh:resultMessage</code> is not mandated by SHACL and considered implementation-specific.
				</p>
				<aside class="example">
					<div class="results-graph">
						<div class="turtle">
[	a sh:ValidationReport ;
	sh:conforms false ;
	sh:result [
		a sh:ValidationResult ;
		sh:resultSeverity sh:Violation ;
		sh:focusNode ex:Bob ;
		sh:resultPath ex:age ;
		sh:value "twenty two" ;
		sh:resultMessage "ex:age expects a literal of datatype xsd:integer." ;
		sh:sourceConstraintComponent sh:DatatypeConstraintComponent ;
		sh:sourceShape ex:PersonShape-age ;
	]
] .
						</div>
						<div class="jsonld">
							<pre class="jsonld">{
	"@type": "sh:ValidationReport",
	"sh:conforms": {
		"@type": "xsd:boolean",
		"@value": "false"
	},
	"sh:result": {
		"@type": "sh:ValidationResult",
		"sh:focusNode": {
			"@id": "ex:Bob"
		},
		"sh:resultMessage": "ex:age expects a literal of datatype xsd:integer.",
		"sh:resultPath": {
			"@id": "ex:age"
		},
		"sh:resultSeverity": {
			"@id": "sh:Violation"
		},
		"sh:sourceConstraintComponent": {
			"@id": "sh:DatatypeConstraintComponent"
		},
		"sh:sourceShape": {
			"@id": "ex:PersonShape-age"
		},
		"sh:value": "twenty two"
	}
}</pre>
						</div>
					</div>
				</aside>

				<section id="results-validation-report">
					<h4>Validation Report (sh:ValidationReport)</h4>
					<p>
						The result of a <a>validation</a> process is an RDF graph with exactly one <a>SHACL instance</a> of <code>sh:ValidationReport</code>.
						The RDF graph MAY contain additional information such as provenance metadata.
					</p>
					<section id="conforms">
						<h5>Conforms (sh:conforms)</h5>
						<p>
							Each SHACL instance of <code>sh:ValidationReport</code> in the results graph has exactly one value for the property <code>sh:conforms</code> and the value is of datatype <code>xsd:boolean</code>.
							It represents the outcome of the <a>conformance checking</a>.
							The value of <code>sh:conforms</code> is <code>true</code> if and only if the <a>validation</a> did not produce any <a>validation results</a> with a severity level representing a violation, and <code>false</code> otherwise.
						</p>
					</section>
					<section id="result">
						<h5>Result (sh:result)</h5>
						<p>
							For every validation result that is produced by a <a>validation</a> process
							(except those mentioned in the context of <a href="#conformance-nested">conformance checking</a>),
							the SHACL instance of <code>sh:ValidationReport</code> in the results graph has a value for the property <code>sh:result</code>.
							Each value of <code>sh:result</code> is a <a>SHACL instance</a> of the class <code>sh:ValidationResult</code>.
						</p>
					</section>
					<section id="shapesGraphWellFormed"><!-- ISSUE-233 -->
						<h5>Syntax Checking of Shapes Graph (sh:shapesGraphWellFormed)</h5>
						<p>
							SHACL validation engines are not strictly required to check whether the <a>shapes graph</a> is <a>well-formed</a>.
							Implementations that do perform such checks (e.g., when the shapes graph is installed in the system,
							or before or during the validation) SHOULD use the property <code>sh:shapesGraphWellFormed</code> to inform the
							consumer of the validation report about this fact.
							If a SHACL instance of <code>sh:ValidationReport</code> in the results graph has <code>true</code> as the <a>value</a>
							for <code>sh:shapesGraphWellFormed</code> then the <a>processor</a> was certain that the <a>shapes graph</a> that was used for the
							<a>validation</a> process has passed all SHACL syntax rules (as summarized in <a href="#syntax-rules"></a>) during the validation process.
						</p>
					</section>
				</section>

				<section id="results-validation-result">
					<h4>Validation Result (sh:ValidationResult)</h4>
					<p>
						SHACL defines <code>sh:ValidationResult</code> as a subclass of <code>sh:AbstractResult</code> to report individual SHACL <a>validation results</a>.
						SHACL implementations may use other <a>SHACL subclasses</a> of <code>sh:AbstractResult</code>, for example,
						to report successfully completed constraint checks or accumulated results.
					</p>
					<p>
						All the properties described in the remaining sub-sections of this section can be specified in a <code>sh:ValidationResult</code>.
						The properties <code>sh:focusNode</code>, <code>sh:resultSeverity</code> and <code>sh:sourceConstraintComponent</code>
						are the only properties that are mandatory for all validation results.
					</p>

					<section id="results-focus-node">
						<h5>Focus node (sh:focusNode)</h5>
						<p>
							Each validation result has exactly one value for the property <code>sh:focusNode</code>
							that is equal to the <a>focus node</a> that has caused the result.
							This is the <a>focus node</a> that was validated when the validation result was produced.
						</p>
					</section>
					<section id="results-path">
						<h4>Path (sh:resultPath)</h4>
						<p>
							Validation results may have a value for the property <code>sh:resultPath</code> pointing at a <a>well-formed</a> <a>SHACL property path</a>.
							For results produced by a <a>property shape</a>, this <a>SHACL property path</a> is equivalent to the <a>value</a> of <code>sh:path</code> of the shape,
							unless stated otherwise. <!-- sh:closed is an exception -->
							If the <code>sh:path</code> <code>p</code> is a <a>blank node</a>, then the <code>sh:resultPath</code> is a <a>deep copy</a> of <code>p</code> in the results graph.
						</p>
					</section>
					<section id="results-value">
						<h4>Value (sh:value)</h4>
						<p>
							Validation results may include, as a <a>value</a> of the property <code>sh:value</code>,
							at most one RDF term that has caused the result.
							The textual definitions of the validators of the SHACL Core components specify how this
							value is constructed - often they are the <a>value nodes</a> that have violated a constraint.
						</p>
					</section>
					<section id="results-source-shape">
						<h4>Source (sh:sourceShape)</h4>
						<p>
							Validation results may include, as the only <a>value</a> of the property <code>sh:sourceShape</code>,
							the <a>shape</a> that the given <code>sh:focusNode</code> was validated against.
						</p>
					</section>
					<section id="results-source-constraint-component">
						<h4>Constraint Component (sh:sourceConstraintComponent)</h4>
						<p>
							Validation results have exactly one value for the property <code>sh:sourceConstraintComponent</code>
							and this value is the <a>IRI</a> of the <a>constraint component</a> that caused the result.
							For example, results produced due to a violation of a constraint based on a value of <code>sh:minCount</code>
							would have the source constraint component <code>sh:MinCountConstraintComponent</code>.
						</p>
					</section>
					<section id="results-detail">
						<h4>Details (sh:detail)</h4>
						<p>
							The property <code>sh:detail</code> may link a (parent) result with one or more SHACL instances of
							<code>sh:AbstractResult</code> that can provide further details about the cause of the (parent) result.
							Depending on the capabilities of the SHACL processor, this may for example include violations of
							constraints that have been evaluated as part of conformance checking via <code>sh:node</code>.
						</p>
					</section>
					<section id="results-message">
						<h4>Message (sh:resultMessage)</h4>
						<p>
							Validation results may have values for the property <code>sh:resultMessage</code>,
							for example to communicate additional textual details to humans.
							While <code>sh:resultMessage</code> may have multiple values, there should not be two values with the same language tag.
							These values are produced by a validation engine based on the values of <code>sh:message</code> of the constraints
							in the shapes graph, see <a href="#message">Declaring Messages for a Shape</a>.
							Messages declared using reification have precedence over those declared at the surrounding shape.
							In cases where a constraint does not have any values for <code>sh:message</code> in the shapes graph the
							SHACL processor MAY automatically generate other values for <code>sh:resultMessage</code>.
						</p>
					</section>
					<section id="results-severity">
						<h4>Severity (sh:resultSeverity)</h4>
						<p>
							Each validation result has exactly one <a>value</a> for the property <code>sh:resultSeverity</code>, and this value is an <a>IRI</a>.
							The value is determined by the following rules (in order):
						</p>
						<ol>
							<li>the <a>value</a> of <a href="#severity"><code>sh:severity</code></a> at a <a>reifier</a> of any of the <a>triples</a> containing the <a>parameters</a> of the <a>constraint</a> that caused the result</li>
							<li>the <a>value</a> of <a href="#severity"><code>sh:severity</code></a> of the <a>shape</a> in the <a>shapes graph</a> that caused the result</li>
							<li>defaulting to <code>sh:Violation</code> if no <code>sh:severity</code> has been specified for the shape or constraint.</li>
						</ol>
					</section>
				</section>
			</section>
			
			<section id="value-nodes">
				<h3>Value Nodes</h3>
				<p>
					The <a>validators</a> of most constraint components use the concept of <dfn data-lt="value node">value nodes</dfn>, which is defined by the following two sub-sections.
				</p>
				<section id="value-nodes-node-shapes">
					<h4>Value Nodes of Node Shapes</h4>
					<p>
						For <a>node shapes</a> the <a>value nodes</a> are the individual <a>focus nodes</a>, forming a set with exactly one member.
					</p>
				</section>
				<section id="value-nodes-property-shapes">
					<h4>Value Nodes of Property Shapes</h4>
					<p>
						For <a>property shapes</a> with a <a>value</a> for <code>sh:path</code> <code>p</code> the
						set of <a>value nodes</a> is produced by the following steps:
					</p>
					<ol>
						<li>
							Add all <a>nodes</a> in the <a>data graph</a> that can be reached from the <a>focus node</a> with the <a>path mapping</a> of <code>p</code>.
						</li>
						<li>
							If <code>e</code> is the <a>value</a> of <code>sh:values</code> at the <a>property shape</a>,
							then add the <a>output nodes</a> of <code>evalExpr(e, <a>data graph</a>, <a>focus node</a>, {})</code>.
						</li>
						<li>
							If the set is still empty and <code>d</code> is the <a>value</a> of <code>sh:defaultValue</code> at the <a>property shape</a>,
							then add the <a>output nodes</a> of <code>evalExpr(d, <a>data graph</a>, <a>focus node</a>, {})</code>.
						</li>
					</ol>
				</section>
			</section>
		</section>

		<section id="core-components">
			<h2>Core Constraint Components</h2>
			<p>
				This section defines the built-in SHACL Core <a>constraint components</a> that MUST be supported by all SHACL Core processors.
				The definition of each constraint component contains its IRI as well as a table of its <a>parameters</a>.
				Unless stated otherwise, all these parameters are <a>mandatory parameters</a>.
				Shapes that violate any of the syntax rules enumerated in those parameter tables are <a>ill-formed</a>.
			</p>
			<p>
				Each constraint component also includes a textual definition, which describes the <a>validator</a> associated with the component.
				These textual definitions refer to the values of the parameters in the constraint by variables of the form
				<code>$paramName</code> where <code>paramName</code> is the part of the parameter's <a>IRI</a> after the <code>sh:</code> namespace.
				For example, the textual definition of <code>sh:ClassConstraintComponent</code> refers to the value of
				<code>sh:class</code> using the variable <code>$class</code>.
				In SHACL Core, the term <dfn data-lt="parameter value|parameter values">parameter value</dfn> means the <a>value</a> of a parameter,
				i.e. the <a>object</a> of the <a>triple</a> in the <a>shapes graph</a> where the <a>subject</a> is the <a>shape</a>
				and the <a>predicate</a> is the <a>parameter</a> (such as <code>sh:class</code>).
			</p>
			<p class="issue">
				At the time of writing, the intent of the WG is to define a dialect of SHACL outside of SHACL Core in which the term
				<a>parameter value</a> also allows <a>node expressions</a>.
				Note that not all constraint components use the term <a>parameter value</a> but instead refer to the term <a>value</a>.
				For example, the values of <code>sh:node</code> cannot ever be <a>node expressions</a>, because this would complicate
				the handling of blank nodes.
				<span class="todo">TODO: Add link to Node Expression spec in case it's ready, or clarify the sentences above otherwise.</span>
			</p>
			<p>
				Note that these validators define the <em>only</em> validation results that are being produced by the component.
				Furthermore, the validators always produce <em>new</em> result nodes, i.e. when the textual definition states that
				"...there is a validation result..." then this refers to a distinct new node in a results graph.
			</p>
			<p><em>The remainder of this section is informative.</em></p>
			<p>
				The choice of constraint components that were included into the SHACL Core was made based on
				the requirements collected by the [[shacl-ucr]] document.
				Special attention was paid to the balance between trying to cover as many common use cases as possible
				and keeping the size of the Core language manageable.
				Not all use cases can be expressed by the Core language alone.
				Instead, SHACL-SPARQL provides an extension mechanism, described in the second part of this specification.
				It is expected that additional reusable libraries of <a>constraint components</a> will be maintained by third parties.
			</p>
			<p>
				Unless stated otherwise, the Core constraint components can be used both in <a>property shapes</a> and <a>node shapes</a>.
				Some constraint parameters have syntax rules attached to them that would make <a>node shapes</a> that use these parameters <a>ill-formed</a>.
				Examples of this include <code>sh:minCount</code> which is only supported for <a>property shapes</a>.
			</p>

			<section id="core-components-value-type">
				<h3>Value Type Constraint Components</h3>
				<p>
					The constraint components in this section have in common that they can be used to restrict the type of value nodes.
					Note that it is possible to represent multiple value type alternatives using <a href="#OrConstraintComponent">sh:or</a>.
				</p>
				<section id="ClassConstraintComponent">
					<h4>sh:class</h4>
					<p>
						The condition specified by <code>sh:class</code> is that each <a>value node</a> is a <a>SHACL instance</a> of the given type(s).
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:ClassConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<thead><tr>
							<th>Property</th>
							<th>Summary and Syntax Rules</th>
						</tr>
						</thead>
				<tbody>
						<tr>
							<td><code>sh:class</code></td>
							<td>
								The type of all value nodes.
								<span data-syntax-rule="class-nodeKind">The values of <code>sh:class</code> in a shape are either <a>IRIs</a>
								or <a>blank nodes</a> that are <a>well-formed</a> <a>SHACL lists</a> where all <a>members</a> are <a>IRIs</a>.</span>
							</td>
						</tr>
					</tbody></table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body" data-validator="Class">
							Let <code>$class</code> be a <a>parameter value</a> for <code>sh:class</code>.
							Let <code>classes</code> be a set of <a>IRIs</a> so that
							when <code>$class</code> is an <a>IRI</a> then the set only consists of exactly that IRI,
							and when <code>$class</code> is a <a>blank node</a> <a>SHACL list</a> then the set consists of
							exactly the members of the list.<br><br>
							For each <a>value node</a>
							that is either a <a>literal</a>, or a non-literal that is not a <a>SHACL instance</a> of any of the <code>classes</code> in the <a>data graph</a>,
							there is a <a>validation result</a> with the <a>value node</a> as <code>sh:value</code>.
						</div>
					</div>
					<p><em>The remainder of this section is informative.</em></p>
					<p>
						Note that multiple values for <code>sh:class</code> are interpreted as a conjunction,
						i.e., the values need to be SHACL instances of all of them.
						Use lists for union semantics.
					</p>
					<aside class="example">
						<div class="shapes-graph">
							<div class="turtle">
ex:ClassExampleShape
	a sh:NodeShape ;
	<span class="target-can-be-skipped">sh:targetNode ex:Bob, ex:Alice, ex:Carol ;</span>
	sh:property [
		sh:path ex:address ;
		sh:class ex:PostalAddress ;
	] .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@id": "ex:ClassExampleShape",
	"@type": "sh:NodeShape",
	"sh:property": {
		"sh:class": {
			"@id": "ex:PostalAddress"
		},
		"sh:path": {
			"@id": "ex:address"
		}
	},
	"sh:targetNode": [
		{
			"@id": "ex:Bob"
		},
		{
			"@id": "ex:Alice"
		},
		{
			"@id": "ex:Carol"
		}
	]
}</pre>
							</div>
						<div class="shaclc"><pre class="shaclc">shape ex:ClassExampleShape {
	targetNode=ex:Bob targetNode=ex:Alice targetNode=ex:Carol .
	ex:address ex:PostalAddress .
}</pre></div></div>
						<div class="data-graph">
							<div class="turtle">
ex:Alice a ex:Person .
ex:Bob ex:address [ a ex:PostalAddress ; ex:city ex:Berlin ] .
<span class="focus-node-error">ex:Carol</span> ex:address [ ex:city ex:Cairo ] .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:Alice",
			"@type": "ex:Person"
		},
		{
			"@id": "ex:Bob",
			"ex:address": {
				"@type": "ex:PostalAddress",
				"ex:city": {
					"@id": "ex:Berlin"
				}
			}
		},
		{
			"@id": "ex:Carol",
			"ex:address": {
				"ex:city": {
					"@id": "ex:Cairo"
				}
			}
		}
	]
}</pre>
							</div>
						</div>
					</aside>
					<p>
						The following example illustrates the list-based syntax for <code>sh:class</code>,
						meaning that the values of the property <code>ex:pet</code> must be either cats or dogs.
					</p>
					<aside class="example">
						<div class="shapes-graph">
							<div class="turtle">
ex:ClassListExampleShape
	a sh:NodeShape ;
	<span class="target-can-be-skipped">sh:targetClass ex:Person ;</span>
	sh:property [
		sh:path ex:pet ;
		sh:class ( ex:Cat ex:Dog ) ;
	] .
							</div>
							<div class="jsonld">
							</div>
						</div>
						<div class="data-graph">
							<div class="turtle">
ex:Tessie a ex:Cat .
ex:Rusty a ex:Dog .
ex:Fluffy a ex:Unicorn .

ex:Alice a ex:Person ; ex:pet ex:Tessie, ex:Rusty .
<span class="focus-node-error">ex:Bob</span> a ex:Person ; ex:pet ex:Fluffy .
							</div>
							<div class="jsonld">
							</div>
						</div>
					</aside>
				</section>
				
				<section id="DatatypeConstraintComponent">
					<h4>sh:datatype</h4>
					<p>
						<code>sh:datatype</code> specifies a condition to be satisfied with regards to the datatype of each <a>value node</a>.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:DatatypeConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<thead><tr>
							<th>Property</th>
							<th>Summary and Syntax Rules</th>
						</tr>
						</thead>
				<tbody>
						<tr>
							<td><code>sh:datatype</code></td>
							<td>
								The allowed datatype(s) of all value nodes (e.g., <code>xsd:integer</code>).
								<span data-syntax-rule="datatype-maxCount">A shape has at most one value for <code>sh:datatype</code>.</span>
								<span data-syntax-rule="datatype-nodeKind">The value of <code>sh:datatype</code> in a shape is either an <a>IRI</a>
								or a <a>blank node</a> that is a <a>well-formed</a> <a>SHACL list</a> where all <a>members</a> are <a>IRIs</a>.</span>
							</td>
						</tr>
					</tbody></table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body" data-validator="Datatype">
							Let <code>$datatype</code> be a <a>parameter value</a> for <code>sh:datatype</code>.
							Let <code>datatypes</code> be a set of <a>IRIs</a> so that
							when <code>$datatype</code> is an <a>IRI</a> then the set only consists of exactly that IRI,
							and when <code>$datatype</code> is a <a>blank node</a> <a>SHACL list</a> then the set consists of
							exactly the members of the list.<br><br>
							For each <a>value node</a>
							that is not a <a>literal</a>, or is a <a>literal</a> with a datatype that matches none of the <code>datatypes</code>,
							there is a <a>validation result</a> with the <a>value node</a> as <code>sh:value</code>.<br><br>
							The datatype of a literal is determined following the <a data-cite="sparql12-query/#func-datatype">datatype</a> function of SPARQL 1.2.
							A <a>literal</a> matches a datatype if the <a>literal</a>'s datatype has the same <a>IRI</a>
							and, for the datatypes supported by SPARQL 1.2, is not an <a data-cite="rdf12-concepts#section-Graph-Literal">ill-typed</a> literal.
						</div>
					</div>
					<p><em>The remainder of this section is informative.</em></p>
					<p>
						The values of <code>sh:datatype</code> are typically <a>datatypes</a>, such as <code>xsd:string</code>.
					</p>
					<aside class="example" title="Shape with an IRI as sh:datatype property constraint">
						<div class="shapes-graph">
							<div class="turtle">
ex:DatatypeExampleShape
	a sh:NodeShape ;
	<span class="target-can-be-skipped">sh:targetNode ex:Alice, ex:Bob, ex:Carol ;</span>
	sh:property [
		sh:path ex:age ;
		sh:datatype xsd:integer ;
	] .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@id": "ex:DatatypeExampleShape",
	"@type": "sh:NodeShape",
	"sh:property": {
		"sh:datatype": {
			"@id": "xsd:integer"
		},
		"sh:path": {
			"@id": "ex:age"
		}
	},
	"sh:targetNode": [
		{
			"@id": "ex:Alice"
		},
		{
			"@id": "ex:Bob"
		},
		{
			"@id": "ex:Carol"
		}
	]
}</pre>
							</div>
						<div class="shaclc"><pre class="shaclc">shape ex:DatatypeExampleShape {
	targetNode=ex:Alice targetNode=ex:Bob targetNode=ex:Carol .
	ex:age xsd:integer .
}</pre></div></div>
						<div class="data-graph">
							<div class="turtle">
ex:Alice ex:age "23"^^xsd:integer .
<span class="focus-node-error">ex:Bob</span> ex:age "twenty two" .
<span class="focus-node-error">ex:Carol</span> ex:age "23"^^xsd:int .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:Alice",
			"ex:age": {
				"@type": "xsd:integer",
				"@value": "23"
			}
		},
		{
			"@id": "ex:Bob",
			"ex:age": "twenty two"
		},
		{
			"@id": "ex:Carol",
			"ex:age": {
				"@type": "xsd:int",
				"@value": "23"
			}
		}
	]
}</pre>
							</div>
						</div>
					</aside>
					<p>
						The following example illustrates the list-based syntax, meaning that all values of
						<code>rdfs:label</code> must be either <code>xsd:string</code> or <code>rdf:langString</code>.
						Note that using <code>rdf:langString</code> as value of <code>sh:datatype</code> can be used to test if value nodes have a language tag.
					</p>
					<aside class="example" title="Shape with a list of IRIs as sh:datatype property constraint">
						<div class="shapes-graph">
							<div class="turtle">
ex:TextExampleShape
	a sh:NodeShape ;
	<span class="target-can-be-skipped">sh:targetNode ex:Estonia, ex:GreatBritain ;</span>
	sh:property [
		sh:path rdfs:label ;
		sh:datatype ( xsd:string rdf:langString ) ;
	] .
							</div>
							<div class="jsonld">
							</div>
						</div>
						<div class="data-graph">
							<div class="turtle">
ex:Estonia rdfs:label "Estonia", "Estland"@de .
<span class="focus-node-error">ex:GreatBritain</span> rdfs:label "Great Britain", "&lt;b&gt;Great&lt;/b&gt; Britain"^^rdf:HTML .
							</div>
							<div class="jsonld">
							</div>
						</div>
					</aside>
				</section>
				
				<section id="NodeKindConstraintComponent">
					<h4>sh:nodeKind</h4>
					<p>
						<code>sh:nodeKind</code> specifies a condition to be satisfied by the RDF node kind of each <a>value node</a>.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:NodeKindConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<thead><tr>
							<th>Property</th>
							<th>Summary and Syntax Rules</th>
						</tr>
						</thead>
				<tbody>
						<tr>
							<td><code>sh:nodeKind</code></td>
							<td>
								The node kind (IRI, blank node, literal or combinations of these) of all value nodes.
								<span data-syntax-rule="nodeKind-in">The values of <code>sh:nodeKind</code> in a shape are one of the following six instances of the class <code>sh:NodeKind</code>:
								<code>sh:BlankNode</code>, <code>sh:IRI</code>, <code>sh:Literal</code> 
								<code>sh:BlankNodeOrIRI</code>, <code>sh:BlankNodeOrLiteral</code> and <code>sh:IRIOrLiteral</code>.</span>
								<span data-syntax-rule="nodeKind-maxCount">A shape has at most one value for <code>sh:nodeKind</code>.</span>
							</td>
						</tr>
					</tbody></table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body" data-validator="NodeKind">
							Let <code>$nodeKind</code> be a <a>parameter value</a> for <code>sh:nodeKind</code>.
							For each <a>value node</a>
							that does not match <code>$nodeKind</code>,
							there is a <a>validation result</a> with the <a>value node</a> as <code>sh:value</code>.
							Any <a>IRI</a> matches only <code>sh:IRI</code>, <code>sh:BlankNodeOrIRI</code> and <code>sh:IRIOrLiteral</code>.
							Any <a>blank node</a> matches only <code>sh:BlankNode</code>, <code>sh:BlankNodeOrIRI</code> and <code>sh:BlankNodeOrLiteral</code>.
							Any <a>literal</a> matches only <code>sh:Literal</code>, <code>sh:BlankNodeOrLiteral</code> and <code>sh:IRIOrLiteral</code>.
						</div>
					</div>
					<p><em>The remainder of this section is informative.</em></p>
					<p>
						The following example states that all values of <code>ex:knows</code> need to be IRIs, at any subject.
					</p>
					<aside class="example">
						<div class="shapes-graph">
							<div class="turtle">
ex:NodeKindExampleShape
	a sh:NodeShape ;
	<span class="target-can-be-skipped">sh:targetObjectsOf ex:knows ;</span>
	sh:nodeKind sh:IRI .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@id": "ex:NodeKindExampleShape",
	"@type": "sh:NodeShape",
	"sh:nodeKind": {
		"@id": "sh:IRI"
	},
	"sh:targetObjectsOf": {
		"@id": "ex:knows"
	}
}</pre>
							</div>
						<div class="shaclc"><pre class="shaclc">shape ex:NodeKindExampleShape {
	targetObjectsOf=ex:knows nodeKind=IRI .
}</pre></div></div>
						<div class="data-graph">
							<div class="turtle">
ex:Bob ex:knows ex:Alice .
	ex:Alice ex:knows <span class="focus-node-error">"Bob"</span> .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:Alice",
			"ex:knows": "Bob"
		},
		{
			"@id": "ex:Bob",
			"ex:knows": {
				"@id": "ex:Alice"
			}
		}
	]
}</pre>
							</div>
						</div>
					</aside>
				</section>
			</section>

			<section id="core-components-count">
				<h3>Cardinality Constraint Components</h3>
				<p>
					The following <a>constraint components</a> represent restrictions on the number of <a>value nodes</a> for the given <a>focus node</a>.
				</p>
				<section id="MinCountConstraintComponent">
					<h4>sh:minCount</h4>
					<p>
						<code>sh:minCount</code> specifies the minimum number of <a>value nodes</a> that satisfy the condition.
						If the minimum cardinality value is 0 then this constraint is always satisfied and so may be omitted.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:MinCountConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<thead><tr>
							<th>Property</th>
							<th>Summary and Syntax Rules</th>
						</tr>
						</thead>
				<tbody>
						<tr>
							<td><code>sh:minCount</code></td>
							<td>
								The minimum cardinality.
								<span data-syntax-rule="minCount-scope"><a>Node shapes</a> cannot have any value for <code>sh:minCount</code>.</span>
								<span data-syntax-rule="minCount-maxCount">A <a>property shape</a> has at most one value for <code>sh:minCount</code>.</span>
								<span data-syntax-rule="minCount-datatype">The values of <code>sh:minCount</code> in a property shape are literals with datatype <code>xsd:integer</code>.</span>
							</td>
						</tr>
					</tbody></table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body" data-validator="MinCount">
							Let <code>$minCount</code> be a <a>parameter value</a> for <code>sh:minCount</code>.
							If the number of <a>value nodes</a> is less than <code>$minCount</code>,
							there is a <a>validation result</a>.
						</div>
					</div>
					<p><em>The remainder of this section is informative.</em></p>
					<aside class="example">
						<div class="shapes-graph">
							<div class="turtle">
ex:MinCountExampleShape
	a sh:PropertyShape ;
	<span class="target-can-be-skipped">sh:targetNode ex:Alice, ex:Bob ;</span>
	sh:path ex:name ;
	sh:minCount 1 .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@id": "ex:MinCountExampleShape",
	"@type": "sh:PropertyShape",
	"sh:minCount": {
		"@type": "xsd:integer",
		"@value": "1"
	},
	"sh:path": {
		"@id": "ex:name"
	},
	"sh:targetNode": [
		{
			"@id": "ex:Alice"
		},
		{
			"@id": "ex:Bob"
		}
	]
}</pre>
							</div>
						</div>
						<div class="data-graph">
							<div class="turtle">
	ex:Alice ex:name "Alice" .
<span class="focus-node-error">ex:Bob</span> ex:givenName "Bob"@en .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:Alice",
			"ex:name": "Alice"
		},
		{
			"@id": "ex:Bob",
			"ex:givenName": {
				"@language": "en",
				"@value": "Bob"
			}
		}
	]
}</pre>
							</div>
						</div>
					</aside>
				</section>
				
				<section id="MaxCountConstraintComponent">
					<h4>sh:maxCount</h4>
					<p>
						<code>sh:maxCount</code> specifies the maximum number of <a>value nodes</a> that satisfy the condition.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:MaxCountConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<thead><tr>
							<th>Property</th>
							<th>Summary and Syntax Rules</th>
						</tr>
						</thead>
				<tbody>
						<tr>
							<td><code>sh:maxCount</code></td>
							<td>
								The maximum cardinality.
								<span data-syntax-rule="maxCount-scope"><a>Node shapes</a> cannot have any value for <code>sh:maxCount</code>.</span>
								<span data-syntax-rule="maxCount-maxCount">A <a>property shape</a> has at most one value for <code>sh:maxCount</code>.</span>
								<span data-syntax-rule="maxCount-datatype">The values of <code>sh:maxCount</code> in a property shape are literals with datatype <code>xsd:integer</code>.</span>
							</td>
						</tr>
					</tbody></table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body" data-validator="MaxCount">
							Let <code>$maxCount</code> be a <a>parameter value</a> for <code>sh:maxCount</code>.
							If the number of <a>value nodes</a> is greater than <code>$maxCount</code>,
							there is a <a>validation result</a>.
						</div>
					</div>
					<p><em>The remainder of this section is informative.</em></p>
					<aside class="example">
						<div class="shapes-graph">
							<div class="turtle">
ex:MaxCountExampleShape
	a sh:NodeShape ;
	<span class="target-can-be-skipped">sh:targetNode ex:Bob ;</span>
	sh:property [
		sh:path ex:birthDate ;
		sh:maxCount 1 ;
	] .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@id": "ex:MaxCountExampleShape",
	"@type": "sh:NodeShape",
	"sh:property": {
		"sh:maxCount": {
			"@type": "xsd:integer",
			"@value": "1"
		},
		"sh:path": {
			"@id": "ex:birthDate"
		}
	},
	"sh:targetNode": {
		"@id": "ex:Bob"
	}
}</pre>
							</div>
						<div class="shaclc"><pre class="shaclc">shape ex:MaxCountExampleShape {
	targetNode=ex:Bob .
	ex:birthDate [0..1] .
}</pre></div></div>
						<div class="data-graph">
							<div class="turtle">
ex:Bob ex:birthDate "May 5th 1990" .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@id": "ex:Bob",
	"ex:birthDate": "May 5th 1990"
}</pre>
							</div>
						</div>
					</aside>
				</section>
			</section>
			
			<section id="core-components-range">
				<h3>Value Range Constraint Components</h3>
				<p>
					The following constraint components specify value range conditions to be satisfied by value nodes that are comparable
					via operators such as <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> and <code>&gt;=</code>.
					The following example illustrates a typical use case of these constraint components.
				</p>
				<aside class="example">
					<div class="shapes-graph">
						<div class="turtle">
ex:NumericRangeExampleShape
	a sh:NodeShape ;
	<span class="target-can-be-skipped">sh:targetNode ex:Bob, ex:Alice, ex:Ted ;</span>
	sh:property [
		sh:path ex:age ;
		sh:minInclusive 0 ;
		sh:maxInclusive 150 ;
	] .
						</div>
						<div class="jsonld">
							<pre class="jsonld">{
	"@id": "ex:NumericRangeExampleShape",
	"@type": "sh:NodeShape",
	"sh:property": {
		"sh:maxInclusive": {
			"@type": "xsd:integer",
			"@value": "150"
		},
		"sh:minInclusive": {
			"@type": "xsd:integer",
			"@value": "0"
		},
		"sh:path": {
			"@id": "ex:age"
		}
	},
	"sh:targetNode": [
		{
			"@id": "ex:Bob"
		},
		{
			"@id": "ex:Alice"
		},
		{
			"@id": "ex:Ted"
		}
	]
}</pre>
						</div>
					<div class="shaclc"><pre class="shaclc">shape ex:NumericRangeExampleShape {
	targetNode=ex:Bob targetNode=ex:Alice targetNode=ex:Ted .
	ex:age minInclusive=0 maxInclusive=150 .
}</pre></div></div>

					<div class="data-graph">
						<div class="turtle">
ex:Bob ex:age 23 .
<span class="focus-node-error">ex:Alice</span> ex:age 220 .
<span class="focus-node-error">ex:Ted</span> ex:age "twenty one" .
						</div>
						<div class="jsonld">
							<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:Alice",
			"ex:age": {
				"@type": "xsd:integer",
				"@value": "220"
			}
		},
		{
			"@id": "ex:Bob",
			"ex:age": {
				"@type": "xsd:integer",
				"@value": "23"
			}
		},
		{
			"@id": "ex:Ted",
			"ex:age": "twenty one"
		}
	]
}</pre>
						</div>
					</div>
				</aside>
				
				<section id="MinExclusiveConstraintComponent">
					<h4>sh:minExclusive</h4>
					<p>
						<span class="component-class">Constraint Component IRI:</span> <code>sh:MinExclusiveConstraintComponent</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<thead><tr>
							<th>Property</th>
							<th>Summary and Syntax Rules</th>
						</tr>
						</thead>
				<tbody>
						<tr>
							<td><code>sh:minExclusive</code></td>
							<td>
								The minimum exclusive value.
								<span data-syntax-rule="minExclusive-nodeKind">The values of <code>sh:minExclusive</code> in a shape are <a>literals</a>.</span>
								<span data-syntax-rule="minExclusive-maxCount">A shape has at most one value for <code>sh:minExclusive</code>.</span>
							</td>
						</tr>
					</tbody></table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body" data-validator="MinExclusive">
							Let <code>$minExclusive</code> be a <a>parameter value</a> for <code>sh:minExclusive</code>.
							For each <a>value node</a> <code>v</code>
							where the SPARQL expression <code>$minExclusive &lt; v</code> does not return <code>true</code>,
							there is a <a>validation result</a> with <code>v</code> as <code>sh:value</code>. 
						</div>
					</div>
					<p><em>The remainder of this section is informative.</em></p>
					<p>
						There is a validation result if the value node cannot be compared to the specified range,
						for example when someone compares a string with an integer.	
					</p>
				</section>
				
				<section id="MinInclusiveConstraintComponent">
					<h4>sh:minInclusive</h4>
					<p>
						<span class="component-class">Constraint Component IRI:</span> <code>sh:MinInclusiveConstraintComponent</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<thead><tr>
							<th>Property</th>
							<th>Summary and Syntax Rules</th>
						</tr>
						</thead>
				<tbody>
						<tr>
							<td><code>sh:minInclusive</code></td>
							<td>
								The minimum inclusive value.
								<span data-syntax-rule="minInclusive-nodeKind">The values of <code>sh:minInclusive</code> in a shape are <a>literals</a>.</span>
								<span data-syntax-rule="minInclusive-maxCount">A shape has at most one value for <code>sh:minInclusive</code>.</span>
							</td>
						</tr>
					</tbody></table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body" data-validator="MinInclusive">
							Let <code>$minInclusive</code> be a <a>parameter value</a> for <code>sh:minInclusive</code>.
							For each <a>value node</a> <code>v</code>
							where the SPARQL expression <code>$minInclusive &lt;= v</code> does not return <code>true</code>,
							there is a <a>validation result</a> with <code>v</code> as <code>sh:value</code>. 
						</div>
					</div>
				</section>

				<section id="MaxExclusiveConstraintComponent">
					<h4>sh:maxExclusive</h4>
					<p>
						<span class="component-class">Constraint Component IRI:</span> <code>sh:MaxExclusiveConstraintComponent</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<thead><tr>
							<th>Property</th>
							<th>Summary and Syntax Rules</th>
						</tr>
						</thead>
				<tbody>
						<tr>
							<td><code>sh:maxExclusive</code></td>
							<td>
								The maximum exclusive value.
								<span data-syntax-rule="maxExclusive-nodeKind">The values of <code>sh:maxExclusive</code> in a shape are <a>literals</a>.</span>
								<span data-syntax-rule="maxExclusive-maxCount">A shape has at most one value for <code>sh:maxExclusive</code>.</span>
							</td>
						</tr>
					</tbody></table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body" data-validator="MaxExclusive">
							Let <code>$maxExclusive</code> be a <a>parameter value</a> for <code>sh:maxExclusive</code>.
							For each <a>value node</a> <code>v</code>
							where the SPARQL expression <code>$maxExclusive &gt; v</code> does not return <code>true</code>,
							there is a <a>validation result</a> with <code>v</code> as <code>sh:value</code>. 
						</div>
					</div>
				</section>
				
				<section id="MaxInclusiveConstraintComponent">
					<h4>sh:maxInclusive</h4>
					<p>
						<span class="component-class">Constraint Component IRI:</span> <code>sh:MaxInclusiveConstraintComponent</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<thead><tr>
							<th>Property</th>
							<th>Summary and Syntax Rules</th>
						</tr>
						</thead>
				<tbody>
						<tr>
							<td><code>sh:maxInclusive</code></td>
							<td>
								The maximum inclusive value.
								<span data-syntax-rule="maxInclusive-nodeKind">The values of <code>sh:maxInclusive</code> in a shape are <a>literals</a>.</span>
								<span data-syntax-rule="maxInclusive-maxCount">A shape has at most one value for <code>sh:maxInclusive</code>.</span>
							</td>
						</tr>
					</tbody></table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body" data-validator="MaxInclusive">
							Let <code>$maxInclusive</code> be a <a>parameter value</a> for <code>sh:maxInclusive</code>.
							For each <a>value node</a> <code>v</code>
							where the SPARQL expression <code>$maxInclusive &gt;= v</code> does not return <code>true</code>,
							there is a <a>validation result</a> with <code>v</code> as <code>sh:value</code>. 
						</div>
					</div>
				</section>
			</section>

			<section id="core-components-string">
				<h3>String-based Constraint Components</h3>
				<p>
					The constraint components in this section have in common that they specify conditions
					on the string representation of <a>value nodes</a>.
				</p>
				<section id="MinLengthConstraintComponent">
					<h4>sh:minLength</h4>
					<p>
						<code>sh:minLength</code> specifies the minimum string length of each <a>value node</a> that satisfies the condition.
						This can be applied to any <a>literals</a> and <a>IRIs</a>, but not to <a>blank nodes</a>.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:MinLengthConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<thead><tr>
							<th>Property</th>
							<th>Summary and Syntax Rules</th>
						</tr>
						</thead>
				<tbody>
						<tr>
							<td><code>sh:minLength</code></td>
							<td>
								The minimum length.
								<span data-syntax-rule="minLength-datatype">The values of <code>sh:minLength</code> in a shape are literals with datatype <code>xsd:integer</code>.</span>
								<span data-syntax-rule="minLength-maxCount">A shape has at most one value for <code>sh:minLength</code>.</span>
							</td>
						</tr>
					</tbody></table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body" data-validator="MinLength">
							Let <code>$minLength</code> be a <a>parameter value</a> for <code>sh:minLength</code>.
							For each <a>value node</a> <code>v</code>
							where the length (as defined by the <a data-cite="sparql12-query/#func-strlen">SPARQL STRLEN function</a>)
							of the string representation of <code>v</code> (as defined by the <a data-cite="sparql12-query/#func-str">SPARQL str function</a>)
							is less than <code>$minLength</code>, or where <code>v</code> is a <a>blank node</a>,
							there is a <a>validation result</a> with <code>v</code> as <code>sh:value</code>.
						</div>
					</div>
					<p><em>The remainder of this section is informative.</em></p>
					<p>
						Note that if the value of <code>sh:minLength</code> is 0 then there is no restriction on the
						string length but the constraint is still violated if the value node is a blank node.
					</p>
				</section>
				
				<section id="MaxLengthConstraintComponent">
					<h4>sh:maxLength</h4>
					<p>
						<code>sh:maxLength</code> specifies the maximum string length of each <a>value node</a> that satisfies the condition.
						This can be applied to any <a>literals</a> and <a>IRIs</a>, but not to <a>blank nodes</a>.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:MaxLengthConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<thead><tr>
							<th>Property</th>
							<th>Summary and Syntax Rules</th>
						</tr>
						</thead>
				<tbody>
						<tr>
							<td><code>sh:maxLength</code></td>
							<td>
								The maximum length.
								<span data-syntax-rule="maxLength-datatype">The values of <code>sh:maxLength</code> in a shape are literals with datatype <code>xsd:integer</code>.</span>
								<span data-syntax-rule="maxLength-maxCount">A shape has at most one value for <code>sh:maxLength</code>.</span>
							</td>
						</tr>
					</tbody></table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body" data-validator="MaxLength">
							Let <code>$maxLength</code> be a <a>parameter value</a> for <code>sh:maxLength</code>.
							For each <a>value node</a> <code>v</code>
							where the length (as defined by the <a data-cite="sparql12-query/#func-strlen">SPARQL STRLEN function</a>)
							of the string representation of <code>v</code> (as defined by the <a data-cite="sparql12-query/#func-str">SPARQL str function</a>)
							is greater than <code>$maxLength</code>, or where <code>v</code> is a <a>blank node</a>,
							there is a <a>validation result</a> with <code>v</code> as <code>sh:value</code>.
						</div>
					</div>
					<p><em>The remainder of this section is informative.</em></p>
					<aside class="example">
						<div class="shapes-graph">
							<div class="turtle">
ex:PasswordExampleShape
	a sh:NodeShape ;
	<span class="target-can-be-skipped">sh:targetNode ex:Bob, ex:Alice ;</span>
	sh:property [
		sh:path ex:password ;
		sh:minLength 8 ;
		sh:maxLength 10 ;
	] .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@id": "ex:PasswordExampleShape",
	"@type": "sh:NodeShape",
	"sh:property": {
		"sh:maxLength": {
			"@type": "xsd:integer",
			"@value": "10"
		},
		"sh:minLength": {
			"@type": "xsd:integer",
			"@value": "8"
		},
		"sh:path": {
			"@id": "ex:password"
		}
	},
	"sh:targetNode": [
		{
			"@id": "ex:Bob"
		},
		{
			"@id": "ex:Alice"
		}
	]
}</pre>
							</div>
						<div class="shaclc"><pre class="shaclc">shape ex:PasswordExampleShape {
	targetNode=ex:Bob targetNode=ex:Alice .
	ex:password minLength=8 maxLength=10 .
}</pre></div></div>
						<div class="data-graph">
							<div class="turtle">
ex:Bob ex:password "123456789" .
<span class="focus-node-error">ex:Alice</span> ex:password "1234567890ABC" .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:Alice",
			"ex:password": "1234567890ABC"
		},
		{
			"@id": "ex:Bob",
			"ex:password": "123456789"
		}
	]
}</pre>
							</div>
						</div>
					</aside>
				</section>
				
				<section id="PatternConstraintComponent">
					<h4>sh:pattern</h4>
					<p>
						<code>sh:pattern</code> specifies a regular expression that each <a>value node</a> matches to satisfy the condition.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:PatternConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<thead><tr>
							<th>Property</th>
							<th>Summary and Syntax Rules</th>
						</tr>
						</thead>
				<tbody>
						<tr>
							<td><code>sh:pattern</code></td>
							<td>
								A regular expression that all value nodes need to match.
								<span data-syntax-rule="pattern-datatype">The values of <code>sh:pattern</code> in a shape are literals with datatype <code>xsd:string</code>.</span>
								<span data-syntax-rule="pattern-regex">The values of <code>sh:pattern</code> in a shape are valid pattern arguments for the <a data-cite="sparql12-query/#func-regex">SPARQL REGEX function</a>.</span>
							</td>
						</tr>
						<tr>
							<td><code>sh:flags</code></td>
							<td>
								An optional string of flags, interpreted as in <a data-cite="sparql12-query/#func-regex">SPARQL 1.2 REGEX</a>.
								<span data-syntax-rule="flags-datatype">The values of <code>sh:flags</code> in a shape are literals with datatype <code>xsd:string</code>.</span>
							</td>
						</tr>
					</tbody></table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body" data-validator="Pattern">
							Let <code>$pattern</code> be a <a>parameter value</a> for <code>sh:pattern</code>.
							Let <code>$flags</code> be a <a>parameter value</a> for <code>sh:flags</code>.
							For each <a>value node</a>
							that is a blank node or
							where the string representation (as defined by the <a data-cite="sparql12-query/#func-str">SPARQL str function</a>)
							does not match the regular expression <code>$pattern</code> (as defined by the <a data-cite="sparql12-query/#func-regex">SPARQL REGEX function</a>),
							there is a <a>validation result</a> with the <a>value node</a> as <code>sh:value</code>.
							If <code>$flags</code> has a value then the matching MUST follow the definition of the 3-argument variant of the SPARQL REGEX function, using <code>$flags</code> as third argument.
						</div>
					</div>
					<p><em>The remainder of this section is informative.</em></p>
					<aside class="example">
						<div class="shapes-graph">
							<div class="turtle">
ex:PatternExampleShape
	a sh:NodeShape ;
	<span class="target-can-be-skipped">sh:targetNode ex:Bob, ex:Alice, ex:Carol ;</span>
	sh:property [
		sh:path ex:bCode ;
		sh:pattern "^B" ;    # starts with 'B'
		sh:flags "i" ;       # Ignore case
	] .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@id": "ex:PatternExampleShape",
	"@type": "sh:NodeShape",
	"sh:property": {
		"sh:flags": "i",
		"sh:path": {
			"@id": "ex:bCode"
		},
		"sh:pattern": "^B"
	},
	"sh:targetNode": [
		{
			"@id": "ex:Bob"
		},
		{
			"@id": "ex:Alice"
		},
		{
			"@id": "ex:Carol"
		}
	]
}</pre>
							</div>
						<div class="shaclc"><pre class="shaclc">shape ex:PatternExampleShape {
	targetNode=ex:Bob targetNode=ex:Alice targetNode=ex:Carol .
	ex:bCode pattern="^B" flags="i" .
}</pre></div></div>
						<div class="data-graph">
							<div class="turtle">
ex:Bob ex:bCode "b101" .
ex:Alice ex:bCode "B102" .
<span class="focus-node-error">ex:Carol</span> ex:bCode "C103" .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:Alice",
			"ex:bCode": "B102"
		},
		{
			"@id": "ex:Bob",
			"ex:bCode": "b101"
		},
		{
			"@id": "ex:Carol",
			"ex:bCode": "C103"
		}
	]
}</pre>
							</div>
						</div>
					</aside>
				</section>
				
				<section id="SingleLineConstraintComponent">
					<h4>sh:singleLine</h4>
					<p class="issue">
						This feature is "at risk" pending a WG resolution on this (and similar) convenience features.
						The WG is not sure yet where to draw the lines between features that should go into Core versus some other document.
						Originally discussed as <a href="https://github.com/w3c/data-shapes/issues/177">Issue 177</a>.
					</p>
					<p>
						When set to <code>true</code>, <code>sh:singleLine</code> specifies that the <a>value nodes</a> must not contain line breaks.
						In addition to constraint validation, this information can be exploited by user interface builders to select between (single-lined) text fields and (multi-lined) text areas.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:SingleLineConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<thead><tr>
							<th>Property</th>
							<th>Summary and Syntax Rules</th>
						</tr>
						</thead>
				<tbody>
						<tr>
							<td><code>sh:singleLine</code></td>
							<td>
								<code>true</code> to activate this constraint.
								<span data-syntax-rule="singleLine-datatype">The values of <code>sh:singleLine</code> in a shape are literals with datatype <code>xsd:boolean</code>.</span>
								<span data-syntax-rule="singleLine-maxCount">A shape has at most one value for <code>sh:singleLine</code>.</span>
							</td>
						</tr>
					</tbody></table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body" data-validator="SingleLine">
							Let <code>$singleLine</code> be a <a>parameter value</a> for <code>sh:singleLine</code>.
							If <code>$singleLine</code> is <code>true</code>, then, for each <a>value node</a> that is a literal where the lexical form matches the
							regular expression (as defined by the <a data-cite="sparql12-query/#func-regex">SPARQL REGEX function</a>) <code>[\f\r\n\v]</code>, there is a validation result.
						</div>
					</div>
					<p><em>The remainder of this section is informative.</em></p>
					<aside class="example">
						<p>
							In this example, the valid target nodes of the shape can only contain single-lined values for <code>rdfs:label</code>.
							The values of <code>rdfs:comment</code> are explicitly allowed to contain line breaks, indicating to form builders that
							those values should be edited in a multi-line (text area) input widget.
						</p>
						<div class="shapes-graph">
							<div class="turtle">
ex:SingleLineExampleShape
	a sh:NodeShape ;
	sh:property [
		a sh:PropertyShape ;
		sh:path rdfs:label ;
		sh:datatype xsd:string ;
		sh:singleLine true ;
	] ;
	sh:property [
		a sh:PropertyShape ;
		sh:path rdfs:comment ;
		sh:or ( [ sh:datatype xsd:string ] [ sh:datatype rdf:langString ] ) ;
		sh:singleLine false ;
	] .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@id": "ex:SingleLineExampleShape",
	"@type": "sh:NodeShape",
	"sh:property": [
		{
			"@type": "sh:PropertyShape",
			"sh:datatype": {
				"@id": "xsd:string"
			},
			"sh:path": {
				"@id": "rdfs:label"
			},
			"sh:singleLine": {
				"@type": "xsd:boolean",
				"@value": "true"
			}
		},
		{
			"@type": "sh:PropertyShape",
			"sh:or": {
				"@list": [
					{
						"sh:datatype": {
							"@id": "xsd:string"
						}
					},
					{
						"sh:datatype": {
							"@id": "rdf:langString"
						}
					}
				]
			},
			"sh:path": {
				"@id": "rdfs:comment"
			},
			"sh:singleLine": {
				"@type": "xsd:boolean",
				"@value": "false"
			}
		}
	]
}</pre>
							</div>
						</div>
					</aside>
				</section>
				
				<section id="LanguageInConstraintComponent">
					<h4>sh:languageIn</h4>
					<p>
						The condition specified by <code>sh:languageIn</code> is that the allowed language tags for each <a>value node</a> are limited by a given list of language tags.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:LanguageInConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<thead><tr>
							<th>Property</th>
							<th>Summary and Syntax Rules</th>
						</tr>
						</thead>
				<tbody>
						<tr>
							<td><code>sh:languageIn</code></td>
							<td>
								A list of basic language ranges as per [[!BCP47]].
								<span data-syntax-rule="languageIn-node">Each value of <code>sh:languageIn</code> in a shape is a <a>SHACL list</a>.</span>
								<span data-syntax-rule="languageIn-members-datatype">Each <a>member</a> of such a list is a literal with datatype <code>xsd:string</code>.</span>
								<span data-syntax-rule="languageIn-maxCount">A shape has at most one value for <code>sh:languageIn</code>.</span>
							</td>
						</tr>
					</tbody></table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body" data-validator="LanguageIn">
							Let <code>$languageIn</code> be a <a>value</a> of <code>sh:languageIn</code>.
							For each <a>value node</a>
							that is either not a <a>literal</a> or that does not have a language tag
							matching any of the basic language ranges that are the <a>members</a> of <code>$languageIn</code>
							following the filtering schema defined by the <a data-cite="sparql12-query/#func-langMatches">SPARQL langMatches</a> function,
							there is a <a>validation result</a> with the <a>value node</a> as <code>sh:value</code>.
						</div>
					</div>
					<p><em>The remainder of this section is informative.</em></p>
					<p>
						The following example shape states that all values of <code>ex:prefLabel</code>
						can be either in English or Māori.
					</p>
					<aside class="example">
						<div class="shapes-graph">
							<div class="turtle">
ex:NewZealandLanguagesShape
	a sh:NodeShape ;
	<span class="target-can-be-skipped">sh:targetNode ex:Mountain, ex:Berg ;</span>
	sh:property [
		sh:path ex:prefLabel ;
		sh:languageIn ( "en" "mi" ) ;
	] .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@id": "ex:NewZealandLanguagesShape",
	"@type": "sh:NodeShape",
	"sh:property": {
		"sh:languageIn": {
			"@list": [
				"en",
				"mi"
			]
		},
		"sh:path": {
			"@id": "ex:prefLabel"
		}
	},
	"sh:targetNode": [
		{
			"@id": "ex:Mountain"
		},
		{
			"@id": "ex:Berg"
		}
	]
}</pre>
							</div>
						<div class="shaclc"><pre class="shaclc">shape ex:NewZealandLanguagesShape {
	targetNode=ex:Mountain targetNode=ex:Berg .
	ex:prefLabel languageIn=["en" "mi"] .
}</pre></div></div>
						<p>
							From the example instances, <code>ex:Berg</code> will lead to constraint violations for all
							of its labels.
						</p>
						<div class="data-graph">
							<div class="turtle">
ex:Mountain
	ex:prefLabel "Mountain"@en ;
	ex:prefLabel "Hill"@en-nz ;
	ex:prefLabel "Maunga"@mi .

<span class="focus-node-error">ex:Berg</span>
	ex:prefLabel "Berg" ;
	ex:prefLabel "Berg"@de ;
	ex:prefLabel ex:BergLabel .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:Berg",
			"ex:prefLabel": [
				"Berg",
				{
					"@language": "de",
					"@value": "Berg"
				},
				{
					"@id": "ex:BergLabel"
				}
			]
		},
		{
			"@id": "ex:Mountain",
			"ex:prefLabel": [
				{
					"@language": "en",
					"@value": "Mountain"
				},
				{
					"@language": "en-nz",
					"@value": "Hill"
				},
				{
					"@language": "mi",
					"@value": "Maunga"
				}
			]
		}
	]
}</pre>
							</div>
						</div>
					</aside>
				</section>
				
				<section id="UniqueLangConstraintComponent">
					<h4>sh:uniqueLang</h4>
					<p>
						The property <code>sh:uniqueLang</code> can be set to <code>true</code> to specify that no pair of <a>value nodes</a> may use the same language tag.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:UniqueLangConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<thead><tr>
							<th>Property</th>
							<th>Summary and Syntax Rules</th>
						</tr>
						</thead>
				<tbody>
						<tr>
							<td><code>sh:uniqueLang</code></td>
							<td>
								<code>true</code> to activate this constraint.
								<span data-syntax-rule="uniqueLang-datatype">The values of <code>sh:uniqueLang</code> in a shape are literals with datatype <code>xsd:boolean</code>.</span>
								<span data-syntax-rule="uniqueLang-maxCount">A property shape has at most one value for <code>sh:uniqueLang</code>.</span>
								<span data-syntax-rule="uniqueLang-scope"><a>Node shapes</a> cannot have any value for <code>sh:uniqueLang</code>.</span>
							</td>
						</tr>
					</tbody></table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body" data-validator="UniqueLang">
							Let <code>$uniqueLang</code> be a <a>parameter value</a> for <code>sh:uniqueLang</code>.
							If <code>$uniqueLang</code> is <code>true</code>
							then for each non-empty language tag that is used by at least two <a>value nodes</a>,
							there is a <a>validation result</a>. 
						</div>
					</div>
					<p><em>The remainder of this section is informative.</em></p>
					<aside class="example">
						<div class="shapes-graph">
							<div class="turtle">
ex:UniqueLangExampleShape
	a sh:NodeShape ;
	<span class="target-can-be-skipped">sh:targetNode ex:Alice, ex:Bob ;</span>
	sh:property [
		sh:path ex:label ;
		sh:uniqueLang true ;
	] .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@id": "ex:UniqueLangExampleShape",
	"@type": "sh:NodeShape",
	"sh:property": {
		"sh:path": {
			"@id": "ex:label"
		},
		"sh:uniqueLang": {
			"@type": "xsd:boolean",
			"@value": "true"
		}
	},
	"sh:targetNode": [
		{
			"@id": "ex:Alice"
		},
		{
			"@id": "ex:Bob"
		}
	]
}</pre>
							</div>
						<div class="shaclc"><pre class="shaclc">shape ex:UniqueLangExampleShape {
	targetNode=ex:Alice targetNode=ex:Bob .
	ex:label uniqueLang=true .
}</pre></div></div>
						<div class="data-graph">
							<div class="turtle">
ex:Alice
	ex:label "Alice" ;
	ex:label "Alice"@en ;
	ex:label "Alice"@fr .

<span class="focus-node-error">ex:Bob</span>
	ex:label "Bob"@en ;
	ex:label "Bobby"@en .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:Alice",
			"ex:label": [
				"Alice",
				{
					"@language": "en",
					"@value": "Alice"
				},
				{
					"@language": "fr",
					"@value": "Alice"
				}
			]
		},
		{
			"@id": "ex:Bob",
			"ex:label": [
				{
					"@language": "en",
					"@value": "Bob"
				},
				{
					"@language": "en",
					"@value": "Bobby"
				}
			]
		}
	]
}</pre>
							</div>
						</div>
					</aside>
				</section>
			</section>
			
			<section id="core-components-list">
				<h3>List Constraint Components</h3>
				<p>
					The constraint components in this section apply to <a>value nodes</a> that are <a href="#syntax-rule-SHACL-list">SHACL lists</a>.
					They specify conditions on the structure, length, and members of SHACL lists.
				</p>
				
				<section id="MemberShapeConstraintComponent">
					<h4>sh:memberShape</h4>
					<p>
						<code>sh:memberShape</code> specifies that all members of <a href="#syntax-rule-SHACL-list">SHACL list</a> <a>value nodes</a> must conform to the given <a>node shape</a>.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:MemberShapeConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<thead><tr>
							<th>Property</th>
							<th>Summary and Syntax Rules</th>
						</tr>
						</thead>
				<tbody>
						<tr>
							<td><code>sh:memberShape</code></td>
							<td>
								The shape that all members of the <a href="#syntax-rule-SHACL-list">SHACL list</a> must conform to.
								<span data-syntax-rule="memberShape-node">The value of <code>sh:memberShape</code> must be a <a>well-formed</a> <a>node shape</a>.</span>
							</td>
						</tr>
					</tbody></table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body" data-validator="MemberShape">
							Let <code>$memberShape</code> be a <a>parameter value</a> for <code>sh:memberShape</code>.
							Each <a>value node</a> <code>v</code> must be a <a href="#syntax-rule-SHACL-list">SHACL list</a> - if <code>v</code> is not a SHACL list there is a <a>validation result</a>.
							If any member <code>m</code> of the <a href="#syntax-rule-SHACL-list">SHACL list</a> <code>v</code> does not <a>conform</a> to <code>$memberShape</code>, there is a <a>validation result</a>.
						</div>
					</div>
					<p><em>The remainder of this section is informative.</em></p>
					<p>
						Each member <code>m</code> of a value node <code>v</code> that does not conform to the <code>$memberShape</code> should be reported as a separate <code>sh:detail</code> in the <a>validation result</a> for <code>v</code>.
						If <code>v</code> is not a valid <a href="#syntax-rule-SHACL-list">SHACL list</a>, this should be reported as a top-level <a>validation result</a> and validation of individual members should not be attempted.
					</p>
					<p>
						Examples of how to generate <code>sh:detail</code>s in validation results can be found in the test cases for <code>sh:memberShape</code> in the SHACL test suite: <a href="../shacl12-test-suite/tests/core/node/memberShape-001.ttl">memberShape-001.ttl</a>.
					</p>
					<p>
						In the following example, all values of the property <code>ex:speakerOrder</code> must be SHACL lists with members that are IRIs.
					</p>
					<aside class="example">
						<div class="shapes-graph">
							<div class="turtle">
ex:AgendaShape
	a sh:NodeShape ;
	<span class="target-can-be-skipped">sh:targetClass ex:Agenda ;</span>
	sh:property [
		sh:path ex:speakerOrder ;
		sh:memberShape [
			sh:nodeKind sh:IRI ;
		] ;
	] .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@id": "ex:AgendaShape",
	"@type": "sh:NodeShape",
	"sh:property": {
		"sh:memberShape": {
			"sh:nodeKind": {
				"@id": "sh:IRI"
			}
		},
		"sh:path": {
			"@id": "ex:speakerOrder"
		}
	},
	"sh:targetClass": {
		"@id": "ex:Agenda"
	}
}</pre>
							</div>
						</div>
						<div class="data-graph">
							<div class="turtle">
ex:agenda1 a ex:Agenda ;
	ex:speakerOrder ( ex:Alice ex:Bob ex:Charlie ) .

<span class="focus-node-error">ex:agenda2</span> a ex:Agenda ;
	ex:speakerOrder ( ex:Alice ex:Bob "Charlie" ) .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:agenda1",
			"@type": "ex:Agenda",
			"ex:speakerOrder": {
				"@list": [
					{
						"@id": "ex:Alice"
					},
					{
						"@id": "ex:Bob"
					},
					{
						"@id": "ex:Charlie"
					}
				]
			}
		},
		{
			"@id": "ex:agenda2",
			"@type": "ex:Agenda",
			"ex:speakerOrder": {
				"@list": [
					{
						"@id": "ex:Alice"
					},
					{
						"@id": "ex:Bob"
					},
					"Charlie"
				]
			}
		}
	]
}</pre>
							</div>
						</div>
					</aside>
				</section>
				
				<section id="MinListLengthConstraintComponent">
					<h4>sh:minListLength</h4>
					<p>
						<code>sh:minListLength</code> specifies the minimum number of members that <a href="#syntax-rule-SHACL-list">SHACL list</a> <a>value nodes</a> must have.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:MinListLengthConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<thead><tr>
							<th>Property</th>
							<th>Summary and Syntax Rules</th>
						</tr>
						</thead>
				<tbody>
						<tr>
							<td><code>sh:minListLength</code></td>
							<td>
								The minimum number of members in the <a href="#syntax-rule-SHACL-list">SHACL list</a>.
								<span data-syntax-rule="minListLength-datatype">The values of <code>sh:minListLength</code> in a shape are literals with datatype <code>xsd:integer</code>.</span>
								<span data-syntax-rule="minListLength-minInclusive">The values of <code>sh:minListLength</code> in a shape are integers greater than or equal to 0.</span>
							</td>
						</tr>
					</tbody></table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body" data-validator="MinListLength">
							Let <code>$minListLength</code> be a <a>parameter value</a> for <code>sh:minListLength</code>.
							Each <a>value node</a> <code>v</code> must be a <a href="#syntax-rule-SHACL-list">SHACL list</a> - if <code>v</code> is not a SHACL list there is a <a>validation result</a>.
							If the number of members in a list <code>v</code> is less than <code>$minListLength</code>,
							there is a <a>validation result</a>.
						</div>
					</div>
					<p><em>The remainder of this section is informative.</em></p>
					<p>
						In the following example, all values of the property <code>ex:skills</code> must be SHACL lists with at least 1 member.
						Additional test cases for <code>sh:minListLength</code> can be found in the SHACL test suite: <a href="../shacl12-test-suite/tests/core/node/minListLength-001.ttl">minListLength-001.ttl</a>.
					</p>
					<aside class="example">
						<div class="shapes-graph">
							<div class="turtle">
ex:PersonShape
	a sh:NodeShape ;
	<span class="target-can-be-skipped">sh:targetClass ex:Person ;</span>
	sh:property [
		sh:path ex:skills ;
		sh:minListLength 1 ;
	] .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@id": "ex:PersonShape",
	"@type": "sh:NodeShape",
	"sh:property": {
		"sh:minListLength": {
			"@type": "xsd:integer",
			"@value": "1"
		},
		"sh:path": {
			"@id": "ex:skills"
		}
	},
	"sh:targetClass": {
		"@id": "ex:Person"
	}
}</pre>
							</div>
						</div>
						<div class="data-graph">
							<div class="turtle">
ex:person1 a ex:Person ;
	ex:skills ( "programming" "design" ) .

<span class="focus-node-error">ex:person2</span> a ex:Person ;
	ex:skills () .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:person1",
			"@type": "ex:Person",
			"ex:skills": {
				"@list": [
					"programming",
					"design"
				]
			}
		},
		{
			"@id": "ex:person2",
			"@type": "ex:Person",
			"ex:skills": {
				"@list": []
			}
		}
	]
}</pre>
							</div>
						</div>
					</aside>
				</section>
				
				<section id="MaxListLengthConstraintComponent">
					<h4>sh:maxListLength</h4>
					<p>
						<code>sh:maxListLength</code> specifies the maximum number of members that <a href="#syntax-rule-SHACL-list">SHACL list</a> <a>value nodes</a> must have.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:MaxListLengthConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<thead><tr>
							<th>Property</th>
							<th>Summary and Syntax Rules</th>
						</tr>
						</thead>
				<tbody>
						<tr>
							<td><code>sh:maxListLength</code></td>
							<td>
								The maximum number of members in the <a href="#syntax-rule-SHACL-list">SHACL list</a>.
								<span data-syntax-rule="maxListLength-datatype">The values of <code>sh:maxListLength</code> in a shape are literals with datatype <code>xsd:integer</code>.</span>
								<span data-syntax-rule="maxListLength-minInclusive">The values of <code>sh:maxListLength</code> in a shape are integers greater than or equal to 0.</span>
							</td>
						</tr>
					</tbody></table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body" data-validator="MaxListLength">
							Let <code>$maxListLength</code> be a <a>parameter value</a> for <code>sh:maxListLength</code>.
							Each <a>value node</a> <code>v</code> must be a <a href="#syntax-rule-SHACL-list">SHACL list</a> - if <code>v</code> is not a SHACL list there is a <a>validation result</a>.
							If the number of members in the list <code>v</code> is greater than <code>$maxListLength</code>,
							there is a <a>validation result</a>.
						</div>
					</div>
					<p><em>The remainder of this section is informative.</em></p>
					<p>
						In the following example, all values of the property <code>ex:hobbies</code> must be SHACL lists with at most 2 members.
						Additional test cases for <code>sh:maxListLength</code> can be found in the SHACL test suite: <a href="../shacl12-test-suite/tests/core/node/maxListLength-001.ttl">maxListLength-001.ttl</a>.
					</p>
					<aside class="example">
						<div class="shapes-graph">
							<div class="turtle">
ex:PersonShape
	a sh:NodeShape ;
	<span class="target-can-be-skipped">sh:targetClass ex:Person ;</span>
	sh:property [
		sh:path ex:hobbies ;
		sh:maxListLength 2 ;
	] .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@id": "ex:PersonShape",
	"@type": "sh:NodeShape",
	"sh:property": {
		"sh:maxListLength": {
			"@type": "xsd:integer",
			"@value": "2"
		},
		"sh:path": {
			"@id": "ex:hobbies"
		}
	},
	"sh:targetClass": {
		"@id": "ex:Person"
	}
}</pre>
							</div>
						</div>
						<div class="data-graph">
							<div class="turtle">
ex:person1 a ex:Person ;
	ex:hobbies ( "reading" "writing" ) .

<span class="focus-node-error">ex:person2</span> a ex:Person ;
	ex:hobbies ( "reading" "writing" "swimming" ) .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:person1",
			"@type": "ex:Person",
			"ex:hobbies": {
				"@list": [
					"reading",
					"writing"
				]
			}
		},
		{
			"@id": "ex:person2",
			"@type": "ex:Person",
			"ex:hobbies": {
				"@list": [
					"reading",
					"writing",
					"swimming"
				]
			}
		}
	]
}</pre>
							</div>
						</div>
					</aside>
				</section>
				
				<section id="UniqueMembersConstraintComponent">
					<h4>sh:uniqueMembers</h4>
					<p>
						<code>sh:uniqueMembers</code> specifies whether <a href="#syntax-rule-SHACL-list">SHACL list</a> <a>value nodes</a> must have unique members.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:UniqueMembersConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<thead><tr>
							<th>Property</th>
							<th>Summary and Syntax Rules</th>
						</tr>
						</thead>
				<tbody>
						<tr>
							<td><code>sh:uniqueMembers</code></td>
							<td>
								A boolean that specifies whether the members of the <a href="#syntax-rule-SHACL-list">SHACL list</a> must be unique.
								<span data-syntax-rule="uniqueMembers-datatype">The values of <code>sh:uniqueMembers</code> in a shape are literals with datatype <code>xsd:boolean</code>.</span>
							</td>
						</tr>
					</tbody></table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body" data-validator="UniqueMembers">
							Let <code>$uniqueMembers</code> be a <a>parameter value</a> for <code>sh:uniqueMembers</code>.
							Each <a>value node</a> <code>v</code> must be a <a href="#syntax-rule-SHACL-list">SHACL list</a> - if <code>v</code> is not a SHACL list there is a <a>validation result</a>.
							If <code>$uniqueMembers</code> is <code>true</code> and the list <code>v</code> has duplicate members,
							there is a <a>validation result</a>.
						</div>
					</div>
					<p><em>The remainder of this section is informative.</em></p>
					<p>				
						Each duplicate member <code>m</code> of a list <code>v</code> should be reported as a separate <code>sh:detail</code> in the <a>validation result</a> for <code>v</code>. If the list <code>v</code> is not a valid <a href="#syntax-rule-SHACL-list">SHACL list</a>, this should be reported as a top-level <a>validation result</a> and validation of unique membership should not be attempted.
					</p>
					<p>
						Examples of how to generate <code>sh:detail</code>s in validation results can be found in the test cases for <code>sh:uniqueMembers</code> in the SHACL test suite: <a href="../shacl12-test-suite/tests/core/node/uniqueMembers-001.ttl">uniqueMembers-001.ttl</a>.
					</p>
					<p>
						In the following example, all values of the property <code>ex:preferences</code> must be SHACL lists with members that have unique values within each SHACL list.
					</p>
					<aside class="example">
						<div class="shapes-graph">
							<div class="turtle">
ex:PersonShape
	a sh:NodeShape ;
	<span class="target-can-be-skipped">sh:targetClass ex:Person ;</span>
	sh:property [
		sh:path ex:preferences ;
		sh:uniqueMembers true ;
	] .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@id": "ex:PersonShape",
	"@type": "sh:NodeShape",
	"sh:property": {
		"sh:uniqueMembers": {
			"@type": "xsd:boolean",
			"@value": "true"
		},
		"sh:path": {
			"@id": "ex:preferences"
		}
	},
	"sh:targetClass": {
		"@id": "ex:Person"
	}
}</pre>
							</div>
						</div>
						<div class="data-graph">
							<div class="turtle">
ex:person1 a ex:Person ;
	ex:preferences ( "coffee" "tea" ) .

<span class="focus-node-error">ex:person2</span> a ex:Person ;
	ex:preferences ( "coffee" "tea" "coffee" "tea" "tea" ) .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:person1",
			"@type": "ex:Person",
			"ex:preferences": {
				"@list": [
					"coffee",
					"tea"
				]
			}
		},
		{
			"@id": "ex:person2",
			"@type": "ex:Person",
			"ex:preferences": {
				"@list": [
					"coffee",
					"tea",
					"coffee",
					"tea",
					"tea"
				]
			}
		}
	]
}</pre>
							</div>
						</div>
					</aside>
				</section>
			</section>
			
			<section id="core-components-property-pairs">
				<h3>Property Pair Constraint Components</h3>
				<p>
					The constraint components in this section specify conditions on the sets of <a>value nodes</a> in relation to other properties.
					These constraint components can only be used by <a>property shapes</a>.
				</p>
				
				<section id="EqualsConstraintComponent">
					<h4>sh:equals</h4>
					<p>
						<code>sh:equals</code> specifies the condition that the set of all <a>value nodes</a> is equal to the set of <a>objects</a> of the <a>triples</a> that have the <a>focus node</a> as <a>subject</a> and the <a>value</a> of <code>sh:equals</code> as <a>predicate</a>.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:EqualsConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<thead><tr>
							<th>Property</th>
							<th>Summary and Syntax Rules</th>
						</tr>
						</thead>
				<tbody>
						<tr>
							<td><code>sh:equals</code></td>
							<td>
								The property to compare with.
								<span data-syntax-rule="equals-nodeKind">The values of <code>sh:equals</code> in a shape are <a>IRIs</a>.</span>
							</td>
						</tr>
					</tbody></table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body" data-validator="Equals">
							Let <code>$equals</code> be a <a>value</a> of <code>sh:equals</code>.
							For each <a>value node</a> 
							that does not exist as a <a>value</a> of the property <code>$equals</code> at the <a>focus node</a>,
							there is a <a>validation result</a> with the <a>value node</a> as <code>sh:value</code>.
							For each <a>value</a> of the property <code>$equals</code> at the <a>focus node</a>
							that is not one of the <a>value nodes</a>,
							there is a <a>validation result</a> with the <a>value</a> as <code>sh:value</code>.
						</div>
					</div>
					<p><em>The remainder of this section is informative.</em></p>
					<p>
						The following example illustrates the use of <code>sh:equals</code> in a shape to specify
						that certain focus nodes need to have the same set of values for <code>ex:firstName</code> and <code>ex:givenName</code>.
					</p>
					<aside class="example" title="Shape with sh:datatype property constraint">
						<div class="shapes-graph">
							<div class="turtle">
ex:EqualExampleShape
	a sh:NodeShape ;
	<span class="target-can-be-skipped">sh:targetNode ex:Bob ;</span>
	sh:property [
		sh:path ex:firstName ;
		sh:equals ex:givenName ;
	] .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@id": "ex:EqualExampleShape",
	"@type": "sh:NodeShape",
	"sh:property": {
		"sh:equals": {
			"@id": "ex:givenName"
		},
		"sh:path": {
			"@id": "ex:firstName"
		}
	},
	"sh:targetNode": {
		"@id": "ex:Bob"
	}
}</pre>
							</div>
						<div class="shaclc"><pre class="shaclc">shape ex:EqualExampleShape {
	targetNode=ex:Bob .
	ex:firstName equals=ex:givenName .
}</pre></div></div>
						<div class="data-graph">
							<div class="turtle">
ex:Bob
	ex:firstName "Bob" ;
	ex:givenName "Bob" .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@id": "ex:Bob",
	"ex:firstName": "Bob",
	"ex:givenName": "Bob"
}</pre>
							</div>
						</div>
					</aside>
				</section>
				
				<section id="DisjointConstraintComponent">
					<h4>sh:disjoint</h4>
					<p>
						<code>sh:disjoint</code> specifies the condition that the set of <a>value nodes</a>
						is disjoint with the set of <a>objects</a> of the <a>triples</a>
						that have the <a>focus node</a> as <a>subject</a>
						and the <a>value</a> of <code>sh:disjoint</code> as <a>predicate</a>.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:DisjointConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<thead><tr>
							<th>Property</th>
							<th>Summary and Syntax Rules</th>
						</tr>
						</thead>
				<tbody>
						<tr>
							<td><code>sh:disjoint</code></td>
							<td>
								The property to compare the values with.
								<span data-syntax-rule="disjoint-nodeKind">The values of <code>sh:disjoint</code> in a shape are <a>IRIs</a>.</span>
							</td>
						</tr>
					</tbody></table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body" data-validator="Disjoint">
							Let <code>$disjoint</code> be a <a>parameter value</a> of <code>sh:disjoint</code>.
							For each <a>value node</a>
							that also exists as a <a>value</a> of the property <code>$disjoint</code> at the <a>focus node</a>,
							there is a <a>validation result</a> with the <a>value node</a> as <code>sh:value</code>. 
						</div>
					</div>
					<p><em>The remainder of this section is informative.</em></p>
					<p>
						The following example illustrates the use of <code>sh:disjoint</code> in a shape to specify
						that certain focus nodes cannot share any values for <code>ex:prefLabel</code> and <code>ex:altLabel</code>.
					</p>
					<aside class="example">
						<div class="shapes-graph">
							<div class="turtle">
ex:DisjointExampleShape
	a sh:NodeShape ;
	<span class="target-can-be-skipped">sh:targetNode ex:USA, ex:Germany ;</span>
	sh:property [
		sh:path ex:prefLabel ;
		sh:disjoint ex:altLabel ;
	] .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@id": "ex:DisjointExampleShape",
	"@type": "sh:NodeShape",
	"sh:property": {
		"sh:disjoint": {
			"@id": "ex:altLabel"
		},
		"sh:path": {
			"@id": "ex:prefLabel"
		}
	},
	"sh:targetNode": [
		{
			"@id": "ex:USA"
		},
		{
			"@id": "ex:Germany"
		}
	]
}</pre>
							</div>
						<div class="shaclc"><pre class="shaclc">shape ex:DisjointExampleShape {
	targetNode=ex:USA targetNode=ex:Germany .
	ex:prefLabel disjoint=ex:altLabel .
}</pre></div></div>
						<div class="data-graph">
							<div class="turtle">
ex:USA
	ex:prefLabel "USA" ;
	ex:altLabel "United States" .

<span class="focus-node-error">ex:Germany</span>
	ex:prefLabel "Germany" ;
	ex:altLabel "Germany" .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:Germany",
			"ex:altLabel": "Germany",
			"ex:prefLabel": "Germany"
		},
		{
			"@id": "ex:USA",
			"ex:altLabel": "United States",
			"ex:prefLabel": "USA"
		}
	]
}</pre>
							</div>
						</div>
					</aside>
				</section>
				
				<section id="LessThanConstraintComponent">
					<h4>sh:lessThan</h4>
					<p>
						<code>sh:lessThan</code> specifies the condition that each <a>value node</a> is smaller than all the <a>objects</a> of the <a>triples</a> that have the <a>focus node</a> as <a>subject</a> and the <a>value</a> of <code>sh:lessThan</code> as <a>predicate</a>.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:LessThanConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<thead><tr>
							<th>Property</th>
							<th>Summary and Syntax Rules</th>
						</tr>
						</thead>
				<tbody>
						<tr>
							<td><code>sh:lessThan</code></td>
							<td>
								The property to compare the values with.
								<span data-syntax-rule="lessThan-nodeKind">The values of <code>sh:lessThan</code> in a shape are <a>IRIs</a>.</span>
								<span data-syntax-rule="lessThan-scope"><a>Node shapes</a> cannot have any value for <code>sh:lessThan</code>.</span>
							</td>
						</tr>
					</tbody></table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body" data-validator="LessThan">
							Let <code>$lessThan</code> be a <a>value</a> of <code>sh:lessThan</code>.
							For each pair of <a>value nodes</a> and the values of the property <code>$lessThan</code> at the given <a>focus node</a>
							where the first <a>value</a> is not less than the second <a>value</a> (based on SPARQL's <code>&lt;</code> operator)
							or where the two values cannot be compared,
							there is a <a>validation result</a> with the <a>value node</a> as <code>sh:value</code>. 
						</div>
					</div>
					<p><em>The remainder of this section is informative.</em></p>
					<p>
						The following example illustrates the use of <code>sh:lessThan</code> in a shape to specify
						that all values of <code>ex:startDate</code> are "before" the values of <code>ex:endDate</code>.
					</p>
					<aside class="example">
						<div class="shapes-graph">
							<div class="turtle">
ex:LessThanExampleShape
	a sh:NodeShape ;
	sh:property [
		sh:path ex:startDate ;
		sh:lessThan ex:endDate ;
	] .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@id": "ex:LessThanExampleShape",
	"@type": "sh:NodeShape",
	"sh:property": {
		"sh:lessThan": {
			"@id": "ex:endDate"
		},
		"sh:path": {
			"@id": "ex:startDate"
		}
	}
}</pre>
							</div>
						<div class="shaclc"><pre class="shaclc">shape ex:LessThanExampleShape {
	ex:startDate lessThan=ex:endDate .
}</pre></div></div>
					</aside>
				</section>
				
				<section id="LessThanOrEqualsConstraintComponent">
					<h4>sh:lessThanOrEquals</h4>
					<p>
						<code>sh:lessThanOrEquals</code> specifies the condition that each <a>value node</a> is smaller than or equal to all the <a>objects</a> of the <a>triples</a> that have the <a>focus node</a> as <a>subject</a> and the <a>value</a> of <code>sh:lessThanOrEquals</code> as <a>predicate</a>.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:LessThanOrEqualsConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<thead><tr>
							<th>Property</th>
							<th>Summary and Syntax Rules</th>
						</tr>
						</thead>
				<tbody>
						<tr>
							<td><code>sh:lessThanOrEquals</code></td>
							<td>
								The property to compare the values with.
								<span data-syntax-rule="lessThanOrEquals-nodeKind">The values of <code>sh:lessThanOrEquals</code> in a shape are <a>IRIs</a>.</span>
								<span data-syntax-rule="lessThanOrEquals-scope"><a>Node shapes</a> cannot have any value for <code>sh:lessThanOrEquals</code>.</span>
							</td>
						</tr>
					</tbody></table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body" data-validator="LessThanOrEquals">
							Let <code>$lessThanOrEquals</code> be a <a>value</a> of <code>sh:lessThanOrEquals</code>.
							For each pair of <a>value nodes</a> and the values of the property <code>$lessThanOrEquals</code> at the given <a>focus node</a>
							where the first <a>value</a> is not less than or equal to the second <a>value</a> (based on SPARQL's <code>&lt;=</code> operator)
							or where the two values cannot be compared,
							there is a <a>validation result</a> with the <a>value node</a> as <code>sh:value</code>. 
						</div>
					</div>
				</section>
			</section>				
	
			<section id="core-components-logical">
				<h4>Logical Constraint Components</h4>
				<p>
					The constraint components in this section implement the common logical operators
					<em>and</em>, <em>or</em> and <em>not</em>, as well as a variation of <em>exclusive or</em>.
				</p>
				<section id="NotConstraintComponent">
					<h3>sh:not</h3>
					<p>
						<code>sh:not</code> specifies the condition that each <a>value node</a> cannot <a>conform</a> to a given <a>shape</a>.
						This is comparable to negation and the logical "not" operator.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:NotConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<thead><tr>
							<th>Property</th>
							<th>Summary and Syntax Rules</th>
						</tr>
						</thead>
				<tbody>
						<tr>
							<td><code>sh:not</code></td>
							<td>
								The shape to negate.
								<span data-syntax-rule="not-node">The values of <code>sh:not</code> in a shape must be <a>well-formed</a> <a>shapes</a>.</span>
							</td>
						</tr>
					</tbody></table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body" data-validator="Not">
							Let <code>$not</code> be a <a>value</a> of <code>sh:not</code>.
							For each <a>value node</a> <code>v</code>:
							A <a>failure</a> MUST be reported if the <a>conformance checking</a> of <code>v</code> against
							the shape <code>$not</code> produces a <a>failure</a>.
							Otherwise, if <code>v</code> <a>conforms</a> to the shape <code>$not</code>,
							there is <a>validation result</a> with <code>v</code> as <code>sh:value</code>.
						</div>
					</div>
					<p><em>The remainder of this section is informative.</em></p>
					<p>
						The following example illustrates the use of <code>sh:not</code> in a shape to specify the condition
						that certain focus nodes cannot have any value of <code>ex:property</code>.
					</p>
					<aside class="example">
						<div class="shapes-graph">
							<div class="turtle">
ex:NotExampleShape
	a sh:NodeShape ;
	<span class="target-can-be-skipped">sh:targetNode ex:InvalidInstance1 ;</span>
	sh:not [
		a sh:PropertyShape ;
		sh:path ex:property ;
		sh:minCount 1 ;
	] .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@id": "ex:NotExampleShape",
	"@type": "sh:NodeShape",
	"sh:not": {
		"@type": "sh:PropertyShape",
		"sh:minCount": {
			"@type": "xsd:integer",
			"@value": "1"
		},
		"sh:path": {
			"@id": "ex:property"
		}
	},
	"sh:targetNode": {
		"@id": "ex:InvalidInstance1"
	}
}</pre>
							</div>
						</div>
						<div class="data-graph">
							<div class="turtle">
<span class="focus-node-error">ex:InvalidInstance1</span> ex:property "Some value" .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@id": "ex:InvalidInstance1",
	"ex:property": "Some value"
}</pre>
							</div>
						</div>
					</aside>
				</section>
				
				<section id="AndConstraintComponent">
					<h4>sh:and</h4>
					<p>
						<code>sh:and</code> specifies the condition that each <a>value node</a> conforms to all provided shapes.
						This is comparable to conjunction and the logical "and" operator.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:AndConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<thead><tr>
							<th>Property</th>
							<th>Summary and Syntax Rules</th>
						</tr>
						</thead>
				<tbody>
						<tr>
							<td><code>sh:and</code></td>
							<td>
								A <a>SHACL list</a> of shapes to validate the value nodes against.
								<span data-syntax-rule="and-node">Each value of <code>sh:and</code> in a shape is a <a>SHACL list</a>.</span>
								<span data-syntax-rule="and-members-node">Each <a>member</a> of such list must be a <a>well-formed</a> <a>shape</a>.</span>
							</td>
						</tr>
					</tbody></table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body" data-validator="And">
							Let <code>$and</code> be a <a>value</a> of <code>sh:and</code>.
							For each <a>value node</a> <code>v</code>:
							A <a>failure</a> MUST be produced if the <a>conformance checking</a> of <code>v</code> against any of the <a>members</a> of <code>$and</code> produces a <a>failure</a>.
							Otherwise, if <code>v</code> does not <a>conform</a> to each <a>member</a> of <code>$and</code>,
							there is a <a>validation result</a> with <code>v</code> as <code>sh:value</code>.
						</div>
					</div>
					<p><em>The remainder of this section is informative.</em></p>
					<p>
						Note that although <code>sh:and</code> has a <a>SHACL list</a> of shapes as its value,
						the order of those shapes does not impact the validation results.
						For implementations that use shortcut evaluation semantics, the order may impact the efficiency of validation.
						It is recommended to put earlier in the list constraints that are easier to evaluate, or are more likely to fail.
					</p>
					<p>
						The following example illustrates the use of <code>sh:and</code> in a shape to specify the condition
						that certain focus nodes have exactly one value of <code>ex:property</code>.
						This is achieved via the conjunction of a separate named shape (<code>ex:SuperShape</code>) which specifies
						the minimum count, and a property shape that additionally specifies the maximum count.
						As shown here, <code>sh:and</code> can be used to implement a specialization mechanism between shapes.
					</p>
					<aside class="example">
						<div class="shapes-graph">
							<div class="turtle">
ex:SuperShape
	a sh:NodeShape ;
	sh:property [
		sh:path ex:property ;
		sh:minCount 1 ;
	] .

ex:ExampleAndShape
	a sh:NodeShape ;
	<span class="target-can-be-skipped">sh:targetNode ex:ValidInstance, ex:InvalidInstance ;</span>
	sh:and (
		ex:SuperShape
		[
			sh:path ex:property ;
			sh:maxCount 1 ;
		]
	) .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:ExampleAndShape",
			"@type": "sh:NodeShape",
			"sh:and": {
				"@list": [
					{
						"@id": "ex:SuperShape"
					},
					{
						"sh:maxCount": {
							"@type": "xsd:integer",
							"@value": "1"
						},
						"sh:path": {
							"@id": "ex:property"
						}
					}
				]
			},
			"sh:targetNode": [
				{
					"@id": "ex:ValidInstance"
				},
				{
					"@id": "ex:InvalidInstance"
				}
			]
		},
		{
			"@id": "ex:SuperShape",
			"@type": "sh:NodeShape",
			"sh:property": {
				"sh:minCount": {
					"@type": "xsd:integer",
					"@value": "1"
				},
				"sh:path": {
					"@id": "ex:property"
				}
			}
		}
	]
}</pre>
							</div>
						</div>
						<div class="data-graph">
							<div class="turtle">
ex:ValidInstance
	ex:property "One" .

# Invalid: more than one property
<span class="focus-node-error">ex:InvalidInstance</span>
	ex:property "One" ;
	ex:property "Two" .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:InvalidInstance",
			"ex:property": [
				"One",
				"Two"
			]
		},
		{
			"@id": "ex:ValidInstance",
			"ex:property": "One"
		}
	]
}</pre>
							</div>
						</div>
					</aside>
				</section>
				
				<section id="OrConstraintComponent">
					<h4>sh:or</h4>
					<p>
						<code>sh:or</code> specifies the condition that each <a>value node</a> conforms to at least one of the provided shapes.
						This is comparable to disjunction and the logical "or" operator.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:OrConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<thead><tr>
							<th>Property</th>
							<th>Summary and Syntax Rules</th>
						</tr>
						</thead>
				<tbody>
						<tr>
							<td><code>sh:or</code></td>
							<td>
								A <a>SHACL list</a> of shapes to validate the value nodes against.
								<span data-syntax-rule="or-node">Each value of <code>sh:or</code> in a shape is a <a>SHACL list</a>.</span>
								<span data-syntax-rule="or-members-node">Each <a>member</a> of such list must be a <a>well-formed</a> <a>shape</a>.</span>
							</td>
						</tr>
					</tbody></table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body" data-validator="Or">
							Let <code>$or</code> be a <a>value</a> of <code>sh:or</code>.
							For each <a>value node</a> <code>v</code>:
							A <a>failure</a> MUST be produced if the <a>conformance checking</a> of <code>v</code> against any of the <a>members</a> produces a <a>failure</a>.
							Otherwise, if <code>v</code> <a>conforms</a> to none of the <a>members</a> of <code>$or</code>
							there is a <a>validation result</a> with <code>v</code> as <code>sh:value</code>.
						</div>
					</div>
					<p><em>The remainder of this section is informative.</em></p>
					<p>
						Note that although <code>sh:or</code> has a <a>SHACL list</a> of shapes as its value,
						the order of those shapes does not impact the validation results.
						For implementations that use shortcut evaluation semantics, the order may impact the efficiency of validation.
						It is recommended to put earlier in the list constraints that are easier to evaluate, or are more likely to succeed.
					</p>
					<p>
						The following example illustrates the use of <code>sh:or</code> in a shape to specify the condition
						that certain focus nodes have at least one value of <code>ex:firstName</code>
						or at least one value of <code>ex:givenName</code>.
					</p>
					<aside class="example">
						<div class="shapes-graph">
							<div class="turtle">
ex:OrConstraintExampleShape
	a sh:NodeShape ;
	<span class="target-can-be-skipped">sh:targetNode ex:Bob ;</span>
	sh:or (
		[
			sh:path ex:firstName ;
			sh:minCount 1 ;
		]
		[
			sh:path ex:givenName ;
			sh:minCount 1 ;
		]
	) .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@id": "ex:OrConstraintExampleShape",
	"@type": "sh:NodeShape",
	"sh:or": {
		"@list": [
			{
				"sh:minCount": {
					"@type": "xsd:integer",
					"@value": "1"
				},
				"sh:path": {
					"@id": "ex:firstName"
				}
			},
			{
				"sh:minCount": {
					"@type": "xsd:integer",
					"@value": "1"
				},
				"sh:path": {
					"@id": "ex:givenName"
				}
			}
		]
	},
	"sh:targetNode": {
		"@id": "ex:Bob"
	}
}</pre>
							</div>
						</div>
						<div class="data-graph">
							<div class="turtle">
ex:Bob ex:firstName "Robert" .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@id": "ex:Bob",
	"ex:firstName": "Robert"
}</pre>
							</div>
						</div>
					</aside>
					<p>
						The next example shows how <code>sh:or</code> can be used in a <a>property shape</a> to state that the values of
						the given property <code>ex:address</code> may be either literals with datatype <code>xsd:string</code>
						or <a>SHACL instances</a> of the class <code>ex:Address</code>.
					</p>
					<aside class="example">
						<div class="shapes-graph">
							<div class="turtle">
ex:PersonAddressShape
	a sh:NodeShape ;
	<span class="target-can-be-skipped">sh:targetClass ex:Person ;</span>
	sh:property [
		sh:path ex:address ;
		sh:or (
			[
				sh:datatype xsd:string ;
			]
			[
				sh:class ex:Address ;
			]
		)
	] .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@id": "ex:PersonAddressShape",
	"@type": "sh:NodeShape",
	"sh:property": {
		"sh:or": {
			"@list": [
				{
					"sh:datatype": {
						"@id": "xsd:string"
					}
				},
				{
					"sh:class": {
						"@id": "ex:Address"
					}
				}
			]
		},
		"sh:path": {
			"@id": "ex:address"
		}
	},
	"sh:targetClass": {
		"@id": "ex:Person"
	}
}</pre>
							</div>
						<div class="shaclc"><pre class="shaclc">shape ex:PersonAddressShape -&gt; ex:Person {
	ex:address xsd:string|ex:Address .
}</pre></div></div>
						<div class="data-graph">
							<div class="turtle">
ex:Bob ex:address "123 Prinzengasse, Vaduz, Liechtenstein" .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@id": "ex:Bob",
	"ex:address": "123 Prinzengasse, Vaduz, Liechtenstein"
}</pre>
							</div>
						</div>
					</aside>

					<p>
						Note that all constraints in SHACL get ANDed for execution. Consider the following example:
					</p>

<aside class="example">
						<div class="shapes-graph">
							<div class="turtle">
ex:shapeRoot a sh:NodeShape;
  	sh:or
    	(ex:shapeA ex:shapeB),
    	(ex:shapeC ex:shapeD).
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@id": "ex:shapeRoot",
	"@type": "sh:NodeShape",
	"sh:or": [
		{
			"@list": [
				{
					"@id": "ex:shapeA"
				},
				{
					"@id": "ex:shapeB"
				}
			]
		},
		{
			"@list": [
				{
					"@id": "ex:shapeC"
				},
				{
					"@id": "ex:shapeD"
				}
			]
		}
	]
}</pre>
							</div>
						</div>
					</aside>
					<p>
						The correct interpretation is (<code>shapeA</code> OR <code>shapeB</code>) AND (<code>shapeC</code> OR <code>shapeD</code>).
						The target nodes need to conform to <code>shapeA</code> or <code>shapeB</code>, and then also <code>shapeC</code> or <code>shapeD</code>.
					</p>
				</section>
				
				<section id="XoneConstraintComponent">
					<h4>sh:xone</h4>
					<p>
						<code>sh:xone</code> specifies the condition that each <a>value node</a> conforms to <em>exactly one</em> of the provided shapes.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:XoneConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<thead><tr>
							<th>Property</th>
							<th>Summary and Syntax Rules</th>
						</tr>
						</thead>
				<tbody>
						<tr>
							<td><code>sh:xone</code></td>
							<td>
								A <a>SHACL list</a> of shapes to validate the value nodes against.
								<span data-syntax-rule="xone-node">Each value of <code>sh:xone</code> in a shape is a <a>SHACL list</a>.</span>
								<span data-syntax-rule="xone-members-node">Each <a>member</a> of such list must be a <a>well-formed</a> <a>shape</a>.</span>
							</td>
						</tr>
					</tbody></table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body" data-validator="Xone">
							Let <code>$xone</code> be a <a>value</a> of <code>sh:xone</code>.
							For each <a>value node</a> <code>v</code>
							let <code>N</code> be the number of the <a>shapes</a> that are <a>members</a> of <code>$xone</code> 
							where <code>v</code> <a>conforms</a> to the shape.
							A <a>failure</a> MUST be produced if the <a>conformance checking</a> of <code>v</code> against any of the <a>members</a> produces a <a>failure</a>.
							Otherwise, if <code>N</code> is not exactly <code>1</code>,
							there is a <a>validation result</a> with <code>v</code> as <code>sh:value</code>.
						</div>
					</div>
					<p><em>The remainder of this section is informative.</em></p>
					<p>
						Note that although <code>sh:xone</code> has a <a>SHACL list</a> of shapes as its value,
						the order of those shapes does not impact the validation results.
					</p>
					<p>
						The following example illustrates the use of <code>sh:xone</code> in a shape to specify the condition
						that certain focus nodes must either have a value for <code>ex:fullName</code> or values for
						<code>ex:firstName</code> and <code>ex:lastName</code>, but not both.
					</p>
					<aside class="example">
						<div class="shapes-graph">
							<div class="turtle">
ex:XoneConstraintExampleShape
	a sh:NodeShape ;
	<span class="target-can-be-skipped">sh:targetClass ex:Person ;</span>
	sh:xone (
		[
			sh:property [
				sh:path ex:fullName ;
				sh:minCount 1 ;
			]
		]
		[
			sh:property [
				sh:path ex:firstName ;
				sh:minCount 1 ;
			] ;
			sh:property [
				sh:path ex:lastName ;
				sh:minCount 1 ;
			]
		]
	) .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@id": "ex:XoneConstraintExampleShape",
	"@type": "sh:NodeShape",
	"sh:targetClass": {
		"@id": "ex:Person"
	},
	"sh:xone": {
		"@list": [
			{
				"sh:property": {
					"sh:minCount": {
						"@type": "xsd:integer",
						"@value": "1"
					},
					"sh:path": {
						"@id": "ex:fullName"
					}
				}
			},
			{
				"sh:property": [
					{
						"sh:minCount": {
							"@type": "xsd:integer",
							"@value": "1"
						},
						"sh:path": {
							"@id": "ex:firstName"
						}
					},
					{
						"sh:minCount": {
							"@type": "xsd:integer",
							"@value": "1"
						},
						"sh:path": {
							"@id": "ex:lastName"
						}
					}
				]
			}
		]
	}
}</pre>
							</div>
						</div>
						<div class="data-graph">
							<div class="turtle">
ex:Bob a ex:Person ;
	ex:firstName "Robert" ; 
	ex:lastName "Coin" .

ex:Carla a ex:Person ;
	ex:fullName "Carla Miller" .
	
<span class="focus-node-error">ex:Dory</span> a ex:Person ;
	ex:firstName "Dory" ;
	ex:lastName "Dunce" ;
	ex:fullName "Dory Dunce" .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:Bob",
			"@type": "ex:Person",
			"ex:firstName": "Robert",
			"ex:lastName": "Coin"
		},
		{
			"@id": "ex:Carla",
			"@type": "ex:Person",
			"ex:fullName": "Carla Miller"
		},
		{
			"@id": "ex:Dory",
			"@type": "ex:Person",
			"ex:firstName": "Dory",
			"ex:fullName": "Dory Dunce",
			"ex:lastName": "Dunce"
		}
	]
}</pre>
							</div>
						</div>
					</aside>
				</section>
			</section>
	
			<section id="core-components-shape">
				<h3>Shape-based Constraint Components</h3>
				<p>
					The constraint components in this section can be used to specify complex conditions
					by validating the value nodes against certain shapes.
				</p>
				<section id="NodeConstraintComponent">
					<h4>sh:node</h4>
					<p>
						<code>sh:node</code> specifies the condition that each <a>value node</a> conforms to the given <a>node shape</a>.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:NodeConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<thead><tr>
							<th>Property</th>
							<th>Summary and Syntax Rules</th>
						</tr>
						</thead>
				<tbody>
						<tr>
							<td><code>sh:node</code></td>
							<td>
								The <a>node shape</a> that all value nodes need to conform to.
								<span data-syntax-rule="node-node">The values of <code>sh:node</code> in a shape must be <a>well-formed</a> <a>node shapes</a>.</span>
							</td>
						</tr>
					</tbody></table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body" data-validator="Node">
							Let <code>$node</code> be a <a>value</a> of <code>sh:node</code>.
							For each <a>value node</a> <code>v</code>:
							A <a>failure</a> MUST be produced if the <a>conformance checking</a> of <code>v</code> against <code>$node</code> produces a <a>failure</a>.
							Otherwise, if <code>v</code> does not <a>conform</a> to <code>$node</code>,
							there is a <a>validation result</a> with <code>v</code> as <code>sh:value</code>.
						</div>
					</div>
					<p><em>The remainder of this section is informative.</em></p>
					<p>
						In the following example, all values of the property <code>ex:address</code> must fulfill the
						constraints expressed by the <a>shape</a> <code>ex:AddressShape</code>.
					</p>
					<aside class="example">
						<div class="shapes-graph">
							<div class="turtle">
ex:AddressShape
	a sh:NodeShape ;
	sh:property [
		sh:path ex:postalCode ;
		sh:datatype xsd:string ;
		sh:maxCount 1 ;
	] .

ex:PersonShape
	a sh:NodeShape ;
	<span class="target-can-be-skipped">sh:targetClass ex:Person ;</span>
	sh:property [   # _:b1
		sh:path ex:address ;
		sh:minCount 1 ;
		sh:node ex:AddressShape ;
	] .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:AddressShape",
			"@type": "sh:NodeShape",
			"sh:property": {
				"sh:datatype": {
					"@id": "xsd:string"
				},
				"sh:maxCount": {
					"@type": "xsd:integer",
					"@value": "1"
				},
				"sh:path": {
					"@id": "ex:postalCode"
				}
			}
		},
		{
			"@id": "ex:PersonShape",
			"@type": "sh:NodeShape",
			"sh:property": {
				"sh:minCount": {
					"@type": "xsd:integer",
					"@value": "1"
				},
				"sh:node": {
					"@id": "ex:AddressShape"
				},
				"sh:path": {
					"@id": "ex:address"
				}
			},
			"sh:targetClass": {
				"@id": "ex:Person"
			}
		}
	]
}</pre>
							</div>
						<div class="shaclc"><pre class="shaclc">shape ex:AddressShape {
	ex:postalCode xsd:string [0..1] .
}
shape ex:PersonShape -&gt; ex:Person {
	ex:address [1..*] @ex:AddressShape .
}</pre></div></div>
						<div class="data-graph">
							<div class="turtle">
ex:Bob a ex:Person ;
	ex:address ex:BobsAddress .
	
ex:BobsAddress
	ex:postalCode "1234" .

<span class="focus-node-error">ex:Reto</span> a ex:Person ;
	ex:address ex:RetosAddress .

ex:RetosAddress
	ex:postalCode 5678 .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:Bob",
			"@type": "ex:Person",
			"ex:address": {
				"@id": "ex:BobsAddress"
			}
		},
		{
			"@id": "ex:BobsAddress",
			"ex:postalCode": "1234"
		},
		{
			"@id": "ex:Reto",
			"@type": "ex:Person",
			"ex:address": {
				"@id": "ex:RetosAddress"
			}
		},
		{
			"@id": "ex:RetosAddress",
			"ex:postalCode": {
				"@type": "xsd:integer",
				"@value": "5678"
			}
		}
	]
}</pre>
							</div>
						</div>
						<div class="results-graph">
							<div class="turtle">
[	a sh:ValidationReport ;
	sh:conforms false ;
	sh:result [
		a sh:ValidationResult ;
		sh:resultSeverity sh:Violation ;
		sh:focusNode ex:Reto ;
		sh:resultPath ex:address ;
		sh:value ex:RetosAddress ;
		sh:resultMessage "Value does not conform to shape ex:AddressShape." ;
		sh:sourceConstraintComponent sh:NodeConstraintComponent ;
		sh:sourceShape _:b1 ;
	]
] .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@type": "sh:ValidationReport",
	"sh:conforms": {
		"@type": "xsd:boolean",
		"@value": "false"
	},
	"sh:result": {
		"@type": "sh:ValidationResult",
		"sh:focusNode": {
			"@id": "ex:Reto"
		},
		"sh:resultMessage": "Value does not conform to shape ex:AddressShape.",
		"sh:resultPath": {
			"@id": "ex:address"
		},
		"sh:resultSeverity": {
			"@id": "sh:Violation"
		},
		"sh:sourceConstraintComponent": {
			"@id": "sh:NodeConstraintComponent"
		},
		"sh:sourceShape": {
			"@id": "_:b1"
		},
		"sh:value": {
			"@id": "ex:RetosAddress"
		}
	}
}</pre>
							</div>
						</div>
					</aside>
				</section>
				
				<section id="PropertyConstraintComponent">
					<h4>sh:property</h4>
					<p>
						<code>sh:property</code> can be used to specify that each <a>value node</a> has a given <a>property shape</a>.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:PropertyConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<thead><tr>
							<th>Property</th>
							<th>Summary and Syntax Rules</th>
						</tr>
						</thead>
				<tbody>
						<tr>
							<td><code>sh:property</code></td>
							<td>
								A <a>property shape</a> that all value nodes need to have.
								<span data-syntax-rule="property-node">Each value of <code>sh:property</code> in a shape must be a <a>well-formed</a> <a>property shape</a>.</span>
							</td>
						</tr>
					</tbody></table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body" data-validator="Property">
							Let <code>$property</code> be a <a>value</a> of <code>sh:property</code>.
							For each <a>value node</a> <code>v</code>:
							A <a>failure</a> MUST be produced if the validation of <code>v</code> as <a>focus node</a> against the property shape <code>$property</code> produces a <a>failure</a>.
							Otherwise, the validation results are the results of <a>validating</a> <code>v</code> as <a>focus node</a> against the property shape <code>$property</code>.
						</div>
					</div>
					<p><em>The remainder of this section is informative.</em></p>
					<p>
						Note that there is an important difference between <code>sh:property</code> and <code>sh:node</code>:
						If a value node is violating the constraint, then there is only a single validation result for <code>sh:node</code> for this value node,
						with <code>sh:NodeConstraintComponent</code> as its <code>sh:sourceConstraintComponent</code>.
						On the other hand side, there may be any number of validation results for <code>sh:property</code>, and these
						will have the individual constraint components of the <a>constraints</a> in the <a>property shape</a> as their values of <code>sh:sourceConstraintComponent</code>.
					</p>
					<p>
						Like with all other validation results, each time a <a>property shape</a> is reached via <code>sh:property</code>,
						a validation engine MUST produce <em>fresh</em> validation result nodes.
						This includes cases where the same <a>focus node</a> is validated against the same <a>property shape</a>
						although it is reached via different paths in the <a>shapes graph</a>.
					</p>
				</section>
				
				<section id="QualifiedValueShapeConstraintComponent">
					<h4>sh:qualifiedValueShape, sh:qualifiedMinCount, sh:qualifiedMaxCount</h4>
					<p>
						<code>sh:qualifiedValueShape</code> specifies the condition that a specified number of <a>value nodes</a> conforms to the given shape.
						Each <code>sh:qualifiedValueShape</code> can have: one value for <code>sh:qualifiedMinCount</code>, one value for <code>sh:qualifiedMaxCount</code> or, one value for each, at the same <a>subject</a>.
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<thead><tr>
							<th>Property</th>
							<th>Summary and Syntax Rules</th>
						</tr>
						</thead>
				<tbody>
						<tr>
							<td><code>sh:qualifiedValueShape</code></td>
							<td>
								The shape that the specified number of value nodes needs to conform to.
								<span data-syntax-rule="qualifiedValueShape-node">The values of <code>sh:qualifiedValueShape</code> in a shape must be <a>well-formed</a> <a>shapes</a>.</span>
								<span data-syntax-rule="qualifiedValueShape-scope"><a>Node shapes</a> cannot have any value for <code>sh:qualifiedValueShape</code>.</span>
								This is a <a>mandatory parameter</a> of <code>sh:QualifiedMinCountConstraintComponent</code> and <code>sh:QualifiedMaxCountConstraintComponent</code>.
							</td>
						</tr>
						<tr>
							<td><code>sh:qualifiedValueShapesDisjoint</code></td>
							<td>
								This is an <a>optional parameter</a> of <code>sh:QualifiedMinCountConstraintComponent</code> and <code>sh:QualifiedMaxCountConstraintComponent</code>.
								If set to <code>true</code> then (for the counting) the value nodes must not conform to any of the <a>sibling shapes</a>.
								<span data-syntax-rule="qualifiedValueShapesDisjoint-datatype">The values of <code>sh:qualifiedValueShapesDisjoint</code> in a shape are literals with datatype <code>xsd:boolean</code>.</span>
							</td>
						</tr>
						<tr>
							<td><code>sh:qualifiedMinCount</code></td>
							<td>
								The minimum number of value nodes that conform to the shape.
								<span data-syntax-rule="qualifiedMinCount-datatype">The values of <code>sh:qualifiedMinCount</code> in a shape are literals with datatype <code>xsd:integer</code>.</span>
								This is a <a>mandatory parameter</a> of <code>sh:QualifiedMinCountConstraintComponent</code>.
							</td>
						</tr>
						<tr>
							<td><code>sh:qualifiedMaxCount</code></td>
							<td>
								The maximum number of value nodes that can conform to the shape.
								<span data-syntax-rule="qualifiedMaxCount-datatype">The values of <code>sh:qualifiedMaxCount</code> in a shape are literals with datatype <code>xsd:integer</code>.</span>
								This is a <a>mandatory parameter</a> of <code>sh:QualifiedMaxCountConstraintComponent</code>.
							</td>
						</tr>
					</tbody></table>
					
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION of Sibling Shapes</div>
						<div class="def-text-body">
							Let <code>Q</code> be a <a>shape</a> in <a>shapes graph</a> <code>G</code> that declares a qualified cardinality constraint
							(by having values for <code>sh:qualifiedValueShape</code> and at least one of <code>sh:qualifiedMinCount</code> or <code>sh:qualifiedMaxCount</code>).
							Let <code>ps</code> be the set of <a>shapes</a> in <code>G</code> that have <code>Q</code> as a <a>value</a> of <code>sh:property</code>.
							If <code>Q</code> has <code>true</code> as a <a>value</a> for <code>sh:qualifiedValueShapesDisjoint</code> then
							the set of <dfn>sibling shapes</dfn> for <code>Q</code> is defined as the set of all <a>values</a> of the
							<a>SPARQL property path</a> <code>sh:property/sh:qualifiedValueShape</code> for any <a>shape</a> in <code>ps</code>
							minus the <a>value</a> of <code>sh:qualifiedValueShape</code> of <code>Q</code> itself.
							The set of sibling shapes is empty otherwise.
						</div>
					</div>
					
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION of sh:qualifiedMinCount</div>
						<div class="def-text-body" data-validator="QualifiedMinCount">
							Let <code>$qualifiedValueShape</code> be a <a>value</a> of <code>sh:qualifiedValueShape</code>.
							Let <code>$qualifiedMinCount</code> be a <a>parameter value</a> for <code>sh:qualifiedMinCount</code>.
							Let <code>C</code> be the number of <a>value nodes</a> <code>v</code> where
							<code>v</code> <a>conforms</a> to <code>$qualifiedValueShape</code>
							and where <code>v</code> does not <a>conform</a> to any of the <a>sibling shapes</a> for the <em>current</em> shape,
							i.e. the shape that <code>v</code> is validated against and which has <code>$qualifiedValueShape</code> as its value for <code>sh:qualifiedValueShape</code>.
							A <a>failure</a> MUST be produced if any of the said conformance checks produces a <a>failure</a>.
							Otherwise, there is a <a>validation result</a> if <code>C</code> is less than <code>$qualifiedMinCount</code>.
							The <a>constraint component</a> for <code>sh:qualifiedMinCount</code> is <code>sh:QualifiedMinCountConstraintComponent</code>.
						</div>
					</div>

					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION of sh:qualifiedMaxCount</div>
						<div class="def-text-body" data-validator="QualifiedMaxCount">
							Let <code>$qualifiedMaxCount</code> be a <a>parameter value</a> for <code>sh:qualifiedMaxCount</code>.
							Let <code>C</code> be as defined for <code>sh:qualifiedMinCount</code> above.
							A <a>failure</a> MUST be produced if any of the said conformance checks produces a <a>failure</a>.
							Otherwise, there is a <a>validation result</a> if <code>C</code> is greater than <code>$qualifiedMaxCount</code>.
							The <a>constraint component</a> for <code>sh:qualifiedMaxCount</code> is <code>sh:QualifiedMaxCountConstraintComponent</code>.
						</div>
					</div>

					<p><em>The remainder of this section is informative.</em></p>
					<p>
						In the following example shape can be used to specify the condition that the property <code>ex:parent</code> has exactly two values,
						and at least one of them is female.
					</p>
					<aside class="example">
						<div class="shapes-graph">
							<div class="turtle">
ex:QualifiedValueShapeExampleShape
	a sh:NodeShape ;
	<span class="target-can-be-skipped">sh:targetNode ex:QualifiedValueShapeExampleValidResource ;</span>
	sh:property [
		sh:path ex:parent ;
		sh:minCount 2 ;
		sh:maxCount 2 ;
		sh:qualifiedValueShape [
			sh:path ex:gender ;
			sh:hasValue ex:female ;
		] ;
		sh:qualifiedMinCount 1 ;
	] .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@id": "ex:QualifiedValueShapeExampleShape",
	"@type": "sh:NodeShape",
	"sh:property": {
		"sh:maxCount": {
			"@type": "xsd:integer",
			"@value": "2"
		},
		"sh:minCount": {
			"@type": "xsd:integer",
			"@value": "2"
		},
		"sh:path": {
			"@id": "ex:parent"
		},
		"sh:qualifiedMinCount": {
			"@type": "xsd:integer",
			"@value": "1"
		},
		"sh:qualifiedValueShape": {
			"sh:hasValue": {
				"@id": "ex:female"
			},
			"sh:path": {
				"@id": "ex:gender"
			}
		}
	},
	"sh:targetNode": {
		"@id": "ex:QualifiedValueShapeExampleValidResource"
	}
}</pre>
							</div>
						</div>
						<div class="data-graph">
							<div class="turtle">
ex:QualifiedValueShapeExampleValidResource
	ex:parent ex:John ;
	ex:parent ex:Jane .

ex:John
	ex:gender ex:male .

ex:Jane
	ex:gender ex:female .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:Jane",
			"ex:gender": {
				"@id": "ex:female"
			}
		},
		{
			"@id": "ex:John",
			"ex:gender": {
				"@id": "ex:male"
			}
		},
		{
			"@id": "ex:QualifiedValueShapeExampleValidResource",
			"ex:parent": [
				{
					"@id": "ex:John"
				},
				{
					"@id": "ex:Jane"
				}
			]
		}
	]
}</pre>
							</div>
						</div>
					</aside>
					<p>
						The following example illustrates the use of <code>sh:qualifiedValueShapesDisjoint</code>
						to express that a hand must have at most 5 values of <code>ex:digit</code> (expressed using <code>sh:maxCount</code>),
						and exactly one of them must be an instance of <code>ex:Thumb</code> while exactly 4 of them must be an instance of <code>ex:Finger</code>
						but thumbs and fingers must be disjoint.
						In other words, on a hand, none of the fingers can also be counted as the thumb. 
					</p>
					<aside class="example">
						<div class="shapes-graph">
							<div class="turtle">
ex:HandShape
	a sh:NodeShape ;
	<span class="target-can-be-skipped">sh:targetClass ex:Hand ;</span>
	sh:property [
		sh:path ex:digit ;
		sh:maxCount 5 ;
	] ;
	sh:property [
		sh:path ex:digit ;
		sh:qualifiedValueShape [ sh:class ex:Thumb ] ;
		sh:qualifiedValueShapesDisjoint true ;
		sh:qualifiedMinCount 1 ;
		sh:qualifiedMaxCount 1 ;
	] ;
	sh:property [
		sh:path ex:digit ;
		sh:qualifiedValueShape [ sh:class ex:Finger ] ;
		sh:qualifiedValueShapesDisjoint true ;
		sh:qualifiedMinCount 4 ;
		sh:qualifiedMaxCount 4 ;
	] .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@id": "ex:HandShape",
	"@type": "sh:NodeShape",
	"sh:property": [
		{
			"sh:maxCount": {
				"@type": "xsd:integer",
				"@value": "5"
			},
			"sh:path": {
				"@id": "ex:digit"
			}
		},
		{
			"sh:path": {
				"@id": "ex:digit"
			},
			"sh:qualifiedMaxCount": {
				"@type": "xsd:integer",
				"@value": "1"
			},
			"sh:qualifiedMinCount": {
				"@type": "xsd:integer",
				"@value": "1"
			},
			"sh:qualifiedValueShape": {
				"sh:class": {
					"@id": "ex:Thumb"
				}
			},
			"sh:qualifiedValueShapesDisjoint": {
				"@type": "xsd:boolean",
				"@value": "true"
			}
		},
		{
			"sh:path": {
				"@id": "ex:digit"
			},
			"sh:qualifiedMaxCount": {
				"@type": "xsd:integer",
				"@value": "4"
			},
			"sh:qualifiedMinCount": {
				"@type": "xsd:integer",
				"@value": "4"
			},
			"sh:qualifiedValueShape": {
				"sh:class": {
					"@id": "ex:Finger"
				}
			},
			"sh:qualifiedValueShapesDisjoint": {
				"@type": "xsd:boolean",
				"@value": "true"
			}
		}
	],
	"sh:targetClass": {
		"@id": "ex:Hand"
	}
}</pre>
							</div>
						</div>
					</aside>
				</section>

				<section id="ReifierShapeShapeConstraintComponent">
					<h4>sh:reifierShape, sh:reificationRequired</h4>
					<p>
						<code>sh:reifierShape</code> can be used to link a <a>property shape</a> with one or more <a>node shapes</a>.
						Any <a>reifier</a> must conform to these node shapes.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:ReifierShapeConstraintComponent</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<thead><tr>
							<th>Property</th>
							<th>Summary and Syntax Rules</th>
						</tr>
						</thead>
				<tbody>
						<tr>
							<td><code>sh:reifierShape</code></td>
							<td>
								The <a>node shape</a> that a reifier for this triple must conform to.
								<span data-syntax-rule="reifierShape-node">
									The values of <code>sh:reifierShape</code> must be <a>well-formed</a> <a>node shapes</a>.
									If a value for <code>sh:reifierShape</code> is given, <code>sh:path</code> values are constrained to IRIs.
								</span>
							</td>
						</tr>
						<tr>
							<td><code>sh:reificationRequired</code></td>
							<td>
								This is an <a>optional parameter</a> of <code>sh:ReifierShapeConstraintComponent</code>.
								If set to <code>true</code>, there must be at least one reification value for the focus node/path combination in the <a>data graph</a>.
								<span data-syntax-rule="reificationRequired-datatype">The values of <code>sh:reificationRequired</code> in a shape are literals with datatype <code>xsd:boolean</code>.</span>
							</td>
						</tr>
					</tbody></table>

					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body" data-validator="ReifierShape">
							Let <code>t</code> be the <a>triple term</a> (<a>focus node</a>,  <code>$path</code>, <a>value node</a>).
							For each <a>reifier</a> for the <a>triple term</a> <code>t</code>, a failure MUST be produced if validating the <a>reifier</a> against the <a>node shape</a> <code>$reifierShape</code> with the <a>reifier</a> as <a>focus node</a> produces a <a>failure</a>.
							For each <a>reifier</a> <code>t</code> that does not conform to <code>$reifierShape</code>, there is a validation result with <code>t</code> as <code>sh:value</code>.
						</div>
					</div>

					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION of sh:reificationRequired</div>
						<div class="def-text-body" data-validator="ReificationRequired">
							If <code>$reificationRequired</code> is set to <code>true</code> and there is no reified statement for the <a>triple term</a> <code>t</code> in the <a>data graph</a>, there is a validation result with <code>t</code> as <code>sh:value</code>.
						</div>
					</div>

					<aside class="example">
						<div class="shapes-graph">
							<div class="turtle">
ex:ProvenanceShape
  a sh:NodeShape ;
  sh:property [
    sh:path ex:date ;
    sh:datatype xsd:date ;
    sh:maxCount 1 ;
  ] ;
  sh:property [
    sh:path ex:author ;
    sh:nodeKind sh:IRI ;
    sh:maxCount 1 ;
  ] .

ex:PersonShape
  a sh:NodeShape ;
  sh:targetClass ex:Person ;
  sh:property ex:PersonShape-age .

ex:PersonShape-age
  a sh:PropertyShape ;
  sh:path ex:age ;
  sh:datatype xsd:integer ;
  sh:maxCount 1 ;
  sh:reifierShape ex:ProvenanceShape ;
  sh:reificationRequired true .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:PersonShape",
			"@type": "sh:NodeShape",
			"sh:property": {
				"@id": "ex:PersonShape-age"
			},
			"sh:targetClass": {
				"@id": "ex:Person"
			}
		},
		{
			"@id": "ex:PersonShape-age",
			"@type": "sh:PropertyShape",
			"sh:datatype": {
				"@id": "xsd:integer"
			},
			"sh:maxCount": {
				"@type": "xsd:integer",
				"@value": "1"
			},
			"sh:path": {
				"@id": "ex:age"
			},
			"sh:reificationRequired": {
				"@type": "xsd:boolean",
				"@value": "true"
			},
			"sh:reifierShape": {
				"@id": "ex:ProvenanceShape"
			}
		},
		{
			"@id": "ex:ProvenanceShape",
			"@type": "sh:NodeShape",
			"sh:property": [
				{
					"sh:datatype": {
						"@id": "xsd:date"
					},
					"sh:maxCount": {
						"@type": "xsd:integer",
						"@value": "1"
					},
					"sh:path": {
						"@id": "ex:date"
					}
				},
				{
					"sh:maxCount": {
						"@type": "xsd:integer",
						"@value": "1"
					},
					"sh:nodeKind": {
						"@id": "sh:IRI"
					},
					"sh:path": {
						"@id": "ex:author"
					}
				}
			]
		}
	]
}</pre>
							</div>
						</div>
						<div class="data-graph">
							<div class="turtle">
ex:Bob ex:age 23 {|
  ex:date "2019-12-05"^^xsd:date .
  ex:author ex:Claire
|}.
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@id": "Bob",
	"ex:age": {
		"@type": "xsd:integer",
		"@value": "23",
		"@annotation": {
			"ex:author": {
				"@id": "ex:Claire"
			},
			"ex:date": {
				"@type": "xsd:date",
				"@value": "2019-12-05"
			}
		}
	}
}</pre>
							</div>
						</div>
					</aside>
				</section>
			
			<section id="NodeByExpressionConstraintComponent">
					<h4>sh:nodeByExpression</h4>
					<p>
						<code>sh:nodeByExpression</code> specifies the condition that each <a>value node</a> conforms to the
						<a>node shapes</a> produced by a <a>node expression</a>.
						The evaluation of these node expressions is repeated for all <a>value nodes</a> of the <a>shape</a>
						as the <a>focus node</a>.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:NodeByExpressionConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Summary and Syntax Rules</th>
						</tr>
						<tr>
							<td><code>sh:nodeByExpression</code></td>
							<td>
								The <a>node shapes</a> that all value nodes need to conform to.
								<span data-syntax-rule="nodeByExpression-scope">The <a>values</a> of <code>sh:nodeByExpression</code> in a shape must be <a>well-formed</a> <a>node expressions</a>.</span>
							</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body" data-validator="NodeByExpression">
Let <code>$expr</code> be a <a>value</a> of <code>sh:nodeByExpression</code>.
For each <a>value node</a> <code>v</code>: perform a <a>conformance check</a> of
<code>v</code> against each <a>output node</a> of <code>evalExpr(expr,
<a>data graph</a>, v, {})</code> <code>s</code>. A <a>failure</a>
MUST be produced if the <a>conformance check</a> of <code>v</code> against
<code>s</code> produces a <a>failure</a>. Otherwise, if <code>v</code> does
not <a>conform</a> to <code>s</code>, there is a <a>validation result</a>
with <code>v</code> as <code>sh:value</code> and a <a>deep copy</a> of
<code>s</code> as <code>sh:sourceConstraint</code>.
						</div>
					</div>
					<p><em>The remainder of this section is informative.</em></p>
					<p>
						<code>sh:nodeByExpression</code> functions similarly to <code>sh:node</code>, but instead of referencing a fixed <a>node shape</a>,
						a referenced <a>node expression</a> is used to dynamically compute the set of <a>node shapes</a> to which each <a>value node</a> must conform.
					</p>
					<p>
						There are three key differences between <code>sh:nodeByExpression</code> and <a href="#NodeConstraintComponent"><code>sh:node</code></a>:
						<ol>
							<li>
								<code>sh:nodeByExpression</code> references a <a>node expression</a> instead of a fixed <a>node shape</a> as <code>sh:node</code> does.
							</li>
							<li>
								<code>sh:nodeByExpression</code> cannot reference a <a>node shape</a> that is a <a>blank node</a> as a value like <code>sh:node</code> can,
								as a <a>blank node</a> would be interpreted as a <a>node expression</a>.
							</li>
							<li>
								<a>Results</a> generated by <code>sh:nodeByExpression</code> additionally include a value for `sh:sourceConstraint`.
							</li>

						</ol>
					</p>
					<p>
						Note that <code>sh:node</code> and <code>sh:nodeByExpression</code> exhibit the same behavior when given a <a>value</a> that is an <a>IRI</a> of a <a>node shape</a>.
						In this case, <code>sh:node</code> directly validates against the specified <a>node shape</a>, whereas <code>sh:nodeByExpression</code> interprets the <a>IRI</a>
						as an <a>IRI expression</a> that evaluates to a set containing the same <a>node shape</a>.
					</p>
					<p>
						In the following example, all values of the property <code>ex:address</code> must fulfill the
						constraints expressed by the <a>shape</a> <code>ex:AddressShape</code>.
					</p>
										<aside class="example">
						<div class="shapes-graph">
							<div class="turtle">
ex:AddressShape
	a sh:NodeShape ;
	sh:property [
		sh:path ex:postalCode ;
		sh:datatype xsd:string ;
		sh:maxCount 1 ;
	] .

ex:PersonShape
	a sh:NodeShape ;
	<span class="target-can-be-skipped">sh:targetClass ex:Person ;</span>
	sh:property [   # _:b1
		sh:path ex:address ;
		sh:minCount 1 ;
		sh:nodeByExpression ex:AddressShape ;
	] .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:AddressShape",
			"@type": "sh:NodeShape",
			"sh:property": {
				"sh:datatype": {
					"@id": "xsd:string"
				},
				"sh:maxCount": {
					"@type": "xsd:integer",
					"@value": "1"
				},
				"sh:path": {
					"@id": "ex:postalCode"
				}
			}
		},
		{
			"@id": "ex:PersonShape",
			"@type": "sh:NodeShape",
			"sh:property": {
				"sh:minCount": {
					"@type": "xsd:integer",
					"@value": "1"
				},
				"sh:nodeByExpression": {
					"@id": "ex:AddressShape"
				},
				"sh:path": {
					"@id": "ex:address"
				}
			},
			"sh:targetClass": {
				"@id": "ex:Person"
			}
		}
	]
}</pre>
							</div>
						</div>
						<div class="data-graph">
							<div class="turtle">
ex:Bob a ex:Person ;
	ex:address ex:BobsAddress .

ex:BobsAddress
	ex:postalCode "1234" .

<span class="focus-node-error">ex:Reto</span> a ex:Person ;
	ex:address ex:RetosAddress .

ex:RetosAddress
	ex:postalCode 5678 .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:Bob",
			"@type": "ex:Person",
			"ex:address": {
				"@id": "ex:BobsAddress"
			}
		},
		{
			"@id": "ex:BobsAddress",
			"ex:postalCode": "1234"
		},
		{
			"@id": "ex:Reto",
			"@type": "ex:Person",
			"ex:address": {
				"@id": "ex:RetosAddress"
			}
		},
		{
			"@id": "ex:RetosAddress",
			"ex:postalCode": {
				"@type": "xsd:integer",
				"@value": "5678"
			}
		}
	]
}</pre>
							</div>
						</div>
						<div class="results-graph">
							<div class="turtle">
[	a sh:ValidationReport ;
	sh:conforms false ;
	sh:result [
		a sh:ValidationResult ;
		sh:resultSeverity sh:Violation ;
		sh:focusNode ex:Reto ;
		sh:resultPath ex:address ;
		sh:value ex:RetosAddress ;
		sh:resultMessage "Value does not conform to shape ex:AddressShape." ;
		sh:sourceConstraint ex:AddressShape ;
		sh:sourceConstraintComponent sh:NodeByExpressionConstraintComponent ;
		sh:sourceShape _:b1 ;
	]
] .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@type": "sh:ValidationReport",
	"sh:conforms": {
		"@type": "xsd:boolean",
		"@value": "false"
	},
	"sh:result": {
		"@type": "sh:ValidationResult",
		"sh:focusNode": {
			"@id": "ex:Reto"
		},
		"sh:resultMessage": "Value does not conform to shape ex:AddressShape.",
		"sh:resultPath": {
			"@id": "ex:address"
		},
		"sh:resultSeverity": {
			"@id": "sh:Violation"
		},
		"sh:sourceConstraint": {
			"@id": "ex:AddressShape"
		},
		"sh:sourceConstraintComponent": {
			"@id": "sh:NodeByExpressionConstraintComponent"
		},
		"sh:sourceShape": {
			"@id": "_:b66_b1"
		},
		"sh:value": {
			"@id": "ex:RetosAddress"
		}
	}
}</pre>
							</div>
						</div>
					</aside>
				</section>
			</section>
			
			<section id="core-components-others">
				<h3>Other Constraint Components</h3>
				<p>
					This section enumerates Core constraint components that do not fit into the other categories.
				</p>
				
				<section id="ClosedConstraintComponent">
					<h3>sh:closed, sh:ignoredProperties</h3>
					<p>
						The RDF data model offers a huge amount of flexibility.
						Any node can in principle have values for any property.
						However, in some cases it makes sense to specify conditions on which properties can be applied to nodes.
						The SHACL Core language includes a property called <code>sh:closed</code> that can be used to
						specify the condition that each value node has <a>values</a> only for those properties that have been explicitly enumerated via the
						<a>property shapes</a> specified for the shape via <code>sh:property</code>.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:ClosedConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<thead><tr>
							<th>Property</th>
							<th>Summary and Syntax Rules</th>
						</tr>
						</thead>
				<tbody>
						<tr>
							<td><code>sh:closed</code></td>
							<td>
								Set to <code>true</code> to close the shape.
								<span data-syntax-rule="closed-datatype">The values of <code>sh:closed</code> in a shape are literals with datatype <code>xsd:boolean</code>
									or the <a>IRI</a> <code>sh:ByTypes</code>.</span>
							</td>
						</tr>
						<tr>
							<td><code>sh:ignoredProperties</code></td>
							<td>
								Optional <a>SHACL list</a> of properties that are also permitted in addition to those explicitly enumerated via <code>sh:property</code>.
								<span data-syntax-rule="ignoredProperties-node">The values of <code>sh:ignoredProperties</code> in a shape must be <a>SHACL lists</a>.</span>
								<span data-syntax-rule="ignoredProperties-members-nodeKind">Each <a>member</a> of such a list must be a <a>IRI</a>.</span>
							</td>
						</tr>
					</tbody></table>
					<div id="def-ClosedShape-text" class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body" data-validator="Closed">
							Let <code>$closed</code> be a <a>parameter value</a> for <code>sh:closed</code>.
							Let <code>$ignoredProperties</code> be a <a>value</a> for <code>sh:ignoredProperties</code>.
							<br><br>
							If <code>$closed</code> is <code>true</code> or <code>sh:ByTypes</code> and <code>P</code>
							is the set of properties defined below,
							then there is a <a>validation result</a> for each <a>triple</a> that has a <a>value node</a> as its
							<a>subject</a> and a <a>predicate</a> that is not in <code>P</code>.
							If <code>$ignoredProperties</code> has a value then the properties enumerated as <a>members</a> of this <a>SHACL list</a>
							are also permitted for the <a>value node</a>.
							The <a>validation result</a> MUST have the <a>predicate</a> of the triple as its <code>sh:resultPath</code>,
							and the <a>object</a> of the triple as its <code>sh:value</code>.
							<br><br>
							If <code>$closed</code> is <code>true</code>, then <code>P</code> is the set of <a>IRI</a> properties
							that can be reached from the current shape via the SPARQL path <code>sh:property/sh:path</code>.
							<br><br>
							If <code>$closed</code> is <code>sh:ByTypes</code>, then <code>P</code> is the set of <a>IRI</a> properties
							that can be reached from the value node via the following algorithm, plus <code>rdf:type</code>:
							<div style="margin: 20px">
							<pre class="text">function collectProperties(S)
    add all IRI properties that can be reached from S via the SPARQL path
            sh:property/sh:path
    if S is a SHACL instance of rdfs:Class in the shapes graph {
        for each triple in the shapes graph matching (S rdfs:subClassOf ?o)
            collectProperties(?o)
        for each triple in the shapes graph matching (?s sh:targetClass S)
            collectProperties(?s)
    }
    if S is a SHACL instance of sh:NodeShape in the shapes graph
        for each triple in the shapes graph matching (S sh:node ?o)
            collectProperties(?o)

for each rdf:type T of the value node in the data graph
    collectProperties(T)
</pre></div>
							Note that implementations need to avoid infinite loops in the algorithm above by preventing
							it from visiting the same `S` twice.
						</div>
					</div>
					<p><em>The remainder of this section is informative.</em></p>
					<p>
						The following example illustrates the use of <code>sh:closed</code> in a shape to specify the condition
						that certain focus nodes only have values for <code>ex:firstName</code> and <code>ex:lastName</code>.
						The "ignored" property <code>rdf:type</code> would also be allowed.
					</p>
					<aside class="example">
						<div class="shapes-graph">
							<div class="turtle">
ex:ClosedShapeExampleShape
	a sh:NodeShape ;
	<span class="target-can-be-skipped">sh:targetNode ex:Alice, ex:Bob ;</span>
	sh:closed true ;
	sh:ignoredProperties (rdf:type) ;
	sh:property [
		sh:path ex:firstName ;
	] ;
	sh:property [
		sh:path ex:lastName ;
	] .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@id": "ex:ClosedShapeExampleShape",
	"@type": "sh:NodeShape",
	"sh:closed": {
		"@type": "xsd:boolean",
		"@value": "true"
	},
	"sh:ignoredProperties": {
		"@list": [
			{
				"@id": "rdf:type"
			}
		]
	},
	"sh:property": [
		{
			"sh:path": {
				"@id": "ex:firstName"
			}
		},
		{
			"sh:path": {
				"@id": "ex:lastName"
			}
		}
	],
	"sh:targetNode": [
		{
			"@id": "ex:Alice"
		},
		{
			"@id": "ex:Bob"
		}
	]
}</pre>
							</div>
						<div class="shaclc"><pre class="shaclc">shape ex:ClosedShapeExampleShape {
	targetNode=ex:Alice targetNode=ex:Bob closed=true ignoredProperties=[rdf:type] .
	ex:firstName .
	ex:lastName .
}</pre></div></div>
						<div class="data-graph">
							<div class="turtle">
ex:Alice
	ex:firstName "Alice" .

<span class="focus-node-error">ex:Bob</span>
	ex:firstName "Bob" ;
	ex:middleInitial "J" .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:Alice",
			"ex:firstName": "Alice"
		},
		{
			"@id": "ex:Bob",
			"ex:firstName": "Bob",
			"ex:middleInitial": "J"
		}
	]
}</pre>
							</div>
						</div>
					</aside>
					<p>
						The use case for <code>sh:closed sh:ByTypes</code> includes properties that are declared
						in superclasses of the types of the current value node (via <code>rdfs:subClassOf</code>),
						as well as other shapes that are linked to those types via <code>sh:targetClass</code> and
						the shapes that can be reached from one node shape to the other via <code>sh:node</code>.
						Examples for <code>sh:ByTypes</code> can be found in the test case library:
						<a href="../shacl12-test-suite/tests/core/node/closed-003.ttl">closed-003.ttl</a>,
						<a href="../shacl12-test-suite/tests/core/node/closed-004.ttl">closed-004.ttl</a>.
					</p>
				</section>
				
				<section id="HasValueConstraintComponent">
					<h4>sh:hasValue</h4>
					<p>
						<code>sh:hasValue</code> specifies the condition that at least one <a>value node</a> is equal to the given RDF term.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:HasValueConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<thead><tr>
							<th>Property</th>
							<th>Summary and Syntax Rules</th>
						</tr>
						</thead>
				<tbody>
						<tr>
							<td><code>sh:hasValue</code></td>
							<td>
								A specific required value.
							</td>
						</tr>
					</tbody></table>
					<div id="def-hasValue-text" class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body" data-validator="HasValue">
							Let <code>$hasValue</code> be a <a>parameter value</a> for <code>sh:hasValue</code>.
							If the RDF term <code>$hasValue</code> is not among the <a>value nodes</a>,
							there is a <a>validation result</a>. 
						</div>
					</div>
					<p><em>The remainder of this section is informative.</em></p>
					<aside class="example">
						<div class="shapes-graph">
							<div class="turtle">
ex:StanfordGraduate
	a sh:NodeShape ;
	<span class="target-can-be-skipped">sh:targetNode ex:Alice ;</span>
	sh:property [
		sh:path ex:alumniOf ;
		sh:hasValue ex:Stanford ;
	] .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@id": "ex:StanfordGraduate",
	"@type": "sh:NodeShape",
	"sh:property": {
		"sh:hasValue": {
			"@id": "ex:Stanford"
		},
		"sh:path": {
			"@id": "ex:alumniOf"
		}
	},
	"sh:targetNode": {
		"@id": "ex:Alice"
	}
}</pre>
							</div>
						<div class="shaclc"><pre class="shaclc">shape ex:StanfordGraduate {
	targetNode=ex:Alice .
	ex:alumniOf hasValue=ex:Stanford .
}</pre></div></div>
						<div class="data-graph">
							<div class="turtle">
ex:Alice
	ex:alumniOf ex:Harvard ;
	ex:alumniOf ex:Stanford .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@id": "ex:Alice",
	"ex:alumniOf": [
		{
			"@id": "ex:Harvard"
		},
		{
			"@id": "ex:Stanford"
		}
	]
}</pre>
							</div>
						</div>
					</aside>
				</section>
				
				<section id="InConstraintComponent">
					<h4>sh:in</h4>
					<p>
						<code>sh:in</code> specifies the condition that each <a>value node</a> is a <a>member</a> of a provided <a>SHACL list</a>.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:InConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<thead><tr>
							<th>Property</th>
							<th>Summary and Syntax Rules</th>
						</tr>
						</thead>
				<tbody>
						<tr>
							<td><code>sh:in</code></td>
							<td>
								A <a>SHACL list</a> that has the allowed values as <a>members</a>.
								<span data-syntax-rule="in-node">Each value of <code>sh:in</code> in a shape is a <a>SHACL list</a>.</span>
								<span data-syntax-rule="in-maxCount">A shape has at most one value for <code>sh:in</code>.</span>
							</td>
						</tr>
					</tbody></table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body" data-validator="In">
							Let <code>$in</code> be a <a>value</a> of <code>sh:in</code>.
							For each <a>value node</a>
							that is not a <a>member</a> of <code>$in</code>,
							there is a <a>validation result</a> with the <a>value node</a> as <code>sh:value</code>.
						</div>
					</div>
					<p><em>The remainder of this section is informative.</em></p>
					<p>
						Note that matching of literals needs to be exact, e.g. <code>"04"^^xsd:byte</code> does not match <code>"4"^^xsd:integer</code>.
					</p>
					<aside class="example">
						<div class="shapes-graph">
							<div class="turtle">
ex:InExampleShape
	a sh:NodeShape ;
	<span class="target-can-be-skipped">sh:targetNode ex:RainbowPony ;</span>
	sh:property [
		sh:path ex:color ;
		sh:in ( ex:Pink ex:Purple ) ;
	] .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@id": "ex:InExampleShape",
	"@type": "sh:NodeShape",
	"sh:property": {
		"sh:in": {
			"@list": [
				{
					"@id": "ex:Pink"
				},
				{
					"@id": "ex:Purple"
				}
			]
		},
		"sh:path": {
			"@id": "ex:color"
		}
	},
	"sh:targetNode": {
		"@id": "ex:RainbowPony"
	}
}</pre>
							</div>
						<div class="shaclc"><pre class="shaclc">shape ex:InExampleShape {
	targetNode=ex:RainbowPony .
	ex:color in=[ex:Pink ex:Purple] .
}</pre></div></div>
						<div class="data-graph">
							<div class="turtle">
ex:RainbowPony ex:color ex:Pink .
							</div>
							<div class="jsonld">
								<pre class="jsonld">{
	"@id": "ex:RainbowPony",
	"ex:color": {
		"@id": "ex:Pink"
	}
}</pre>
							</div>
						</div>
					</aside>
				</section>
		
				<section id="ExpressionConstraintComponent">
					<h4>sh:expression</h4>
					<p>
						Based on <a>node expressions</a>, this section introduces a <a>constraint component</a> called
						<dfn data-lt="expression constraint">expression constraints</dfn>.
						Expression constraints can be used in any <a>shape</a> to declare the condition that the
						<a>node expression</a> specified via <code>sh:expression</code> has <code>true</code> as its only output node.
						The evaluation of these node expressions is repeated for all <a>value nodes</a> of the <a>shape</a>
						as the <a>focus node</a>.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:ExpressionConstraintComponent</code>
					</p>
		
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<thead><tr>
							<th>Property</th>
							<th>Summary and Syntax Rules</th>
						</tr>
						</thead>
				<tbody>
						<tr>
							<td><code>sh:expression</code></td>
							<td>
								The <a>node expression</a> that must return <code>true</code>.
								<span data-syntax-rule="expression-scope">The <a>values</a> of <code>sh:expression</code> at a
								<a>shape</a> must be well-formed <a>node expressions</a>.</span>
							</td>
						</tr>
					</tbody></table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body" data-validator="Expression">
							Let <code>$expr</code> be a <a>value</a> of <code>sh:expression</code>.
							For each <a>value node</a> <code>v</code> 
							where <code>evalExpr(expr, <a>data graph</a>, v, {})</code>
							does not return the list consisting of exactly <code>true</code> as its <a>output nodes</a>,
							there is a <a>validation result</a> that has <code>v</code> as its <code>sh:value</code>
							and a <a>deep copy</a> of <code>$expr</code> in the results graph as its <code>sh:sourceConstraint</code>.
							If the <code>$expr</code> has <a>values</a> for <code>sh:message</code> in the <a>shapes graph</a>,
							then these <a>values</a> become the (only) values for <code>sh:resultMessage</code> in the
							<a>validation result</a>.
						</div>
					</div>
				</section>
			</section>
		</section>
				
		<section id="nonValidation" class="informative">
			<h2>Non-Validating Property Shape Characteristics</h2>
			<p>
				While the previous sections introduced properties that represent validation conditions,
				this section covers properties that are ignored by SHACL processors.
				The use of these so-called <dfn data-lt="non-validating property">non-validating properties</dfn>
				is entirely optional and is not subject to formal interpretation contracts.
				They MAY be used for purposes such as form building or predictable printing of RDF files.
			</p>
			<section id="name">
				<h3>sh:name and sh:description</h3>
				<p>
					Property shapes may have one or more <a>values</a> for <code>sh:name</code>
					to provide human-readable labels for the property in the target where it appears.
					If present, tools SHOULD prefer such locally specified labels
					over globally specified labels at the <code>rdf:Property</code> itself.
					For example, if a form displays a node that is in the target of a given property shape
					with an <code>sh:name</code>, then the tool SHOULD use the provided name.
					Similarly, property shapes may have values for <code id="description">sh:description</code>
					to provide descriptions of the property in the given context.
					Both <code>sh:name</code> and <code>sh:description</code> may have
					multiple <a>values</a>, but should only have one <a>value</a> per language tag.
				</p>
			</section>
			<section id="order">
				<h3>sh:order</h3>
				<p>
					Property shapes may have one <a>value</a> for the property <code>sh:order</code>
					to indicate the relative order of the property shape for purposes such as form building.
					The values of <code>sh:order</code> are decimals.
					<code>sh:order</code> is not used for validation purposes
					and may be used with any type of subjects.
					If present at property shapes, the recommended use of <code>sh:order</code> is to sort the
					property shapes in an ascending order, for example so that properties with smaller order are
					placed above or to the start (left in left-to-right languages) of properties with larger order.
				</p>
			</section>
			<section id="group">
				<h3>sh:group</h3>
				<p>
					Property shapes may link to a <a>SHACL instance</a> of the class <code>sh:PropertyGroup</code>
					using the property <code>sh:group</code> to indicate that
					the shape belongs to a group of related property shapes.
					Each group may have additional triples that serve application purposes,
					such as an <code>rdfs:label</code> for form building.
					Groups may also have an <code>sh:order</code> property to indicate
					the relative ordering of groups within the same form.
				</p>
				<p>
					The following example illustrates the use of these various features together.
				</p>
				<aside class="example">
					<div class="shapes-graph">
						<div class="turtle">
ex:PersonFormShape
	a sh:NodeShape ;
	sh:property [
		sh:path ex:firstName ;
		sh:name "first name" ;
		sh:description "The person's given name(s)" ;
		sh:order 0 ;
		sh:group ex:NameGroup ;
	] ;
	sh:property [
		sh:path ex:lastName ;
		sh:name "last name" ;
		sh:description "The person's last name" ;
		sh:order 1 ;
		sh:group ex:NameGroup ;
	] ;
	sh:property [
		sh:path ex:streetAddress ;
		sh:name "street address" ;
		sh:description "The street address including number" ;
		sh:order 11 ;
		sh:group ex:AddressGroup ;
	] ;
	sh:property [
		sh:path ex:locality ;
		sh:name "locality" ;
		sh:description "The city or town of the address" ;
		sh:order 12 ;
		sh:group ex:AddressGroup ;
	] ;
	sh:property [
		sh:path ex:postalCode ;
		sh:name "postal code" ;
		sh:name "zip code"@en-us ;
		sh:description "The postal code of the locality" ;
		sh:order 13 ;
		sh:group ex:AddressGroup ;
	] .

ex:NameGroup
	a sh:PropertyGroup ;
	sh:order 0 ;
	rdfs:label "Name" .

ex:AddressGroup
	a sh:PropertyGroup ;
	sh:order 1 ;
	rdfs:label "Address" .
						</div>
						<div class="jsonld">
							<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:AddressGroup",
			"@type": "sh:PropertyGroup",
			"rdfs:label": "Address",
			"sh:order": {
				"@type": "xsd:integer",
				"@value": "1"
			}
		},
		{
			"@id": "ex:NameGroup",
			"@type": "sh:PropertyGroup",
			"rdfs:label": "Name",
			"sh:order": {
				"@type": "xsd:integer",
				"@value": "0"
			}
		},
		{
			"@id": "ex:PersonFormShape",
			"@type": "sh:NodeShape",
			"sh:property": [
				{
					"sh:description": "The person's given name(s)",
					"sh:group": {
						"@id": "ex:NameGroup"
					},
					"sh:name": "first name",
					"sh:order": {
						"@type": "xsd:integer",
						"@value": "0"
					},
					"sh:path": {
						"@id": "ex:firstName"
					}
				},
				{
					"sh:description": "The person's last name",
					"sh:group": {
						"@id": "ex:NameGroup"
					},
					"sh:name": "last name",
					"sh:order": {
						"@type": "xsd:integer",
						"@value": "1"
					},
					"sh:path": {
						"@id": "ex:lastName"
					}
				},
				{
					"sh:description": "The street address including number",
					"sh:group": {
						"@id": "ex:AddressGroup"
					},
					"sh:name": "street address",
					"sh:order": {
						"@type": "xsd:integer",
						"@value": "11"
					},
					"sh:path": {
						"@id": "ex:streetAddress"
					}
				},
				{
					"sh:description": "The city or town of the address",
					"sh:group": {
						"@id": "ex:AddressGroup"
					},
					"sh:name": "locality",
					"sh:order": {
						"@type": "xsd:integer",
						"@value": "12"
					},
					"sh:path": {
						"@id": "ex:locality"
					}
				},
				{
					"sh:description": "The postal code of the locality",
					"sh:group": {
						"@id": "ex:AddressGroup"
					},
					"sh:name": [
						"postal code",
						{
							"@language": "en-us",
							"@value": "zip code"
						}
					],
					"sh:order": {
						"@type": "xsd:integer",
						"@value": "13"
					},
					"sh:path": {
						"@id": "ex:postalCode"
					}
				}
			]
		}
	]
}</pre>
						</div>
					</div>
				</aside>
				<p>
					A form building application MAY use the information above to display information as follows:
				</p>
				<div style="background: #f3f3f3; padding: 8px">
					<div style="font-size: 18px; color: #0000a0"><b>Name</b></div>
					<table>
						<tbody><tr>
							<td style="text-align: right; width: 160px"><b>first name:</b></td>
							<td>John</td>
						</tr>
						<tr>
							<td style="text-align: right"><b>last name:</b></td>
							<td>Doe</td>
						</tr>
					</tbody></table>
					<div style="font-size: 18px; padding-top: 6px; color: #0000a0"><b>Address</b></div>
					<table>
						<tbody><tr>
							<td style="text-align: right; width: 160px"><b>street address:</b></td>
							<td>123 Silverado Ave</td>
						</tr>
						<tr>
							<td style="text-align: right"><b>locality:</b></td>
							<td>Cupertino</td>
						</tr>
						<tr>
							<td style="text-align: right"><b>zip code:</b></td>
							<td>54321</td>
						</tr>
					</tbody></table>
				</div>
				<p>
					Note that the same information would be generated by the following example,
					which changes the order of the triples but not the <code>sh:order</code> values:
				</p>
				<aside class="example">
					<div class="shapes-graph">
						<div class="turtle">
ex:PersonFormShape
	a sh:NodeShape ;
	sh:property [
		sh:path ex:lastName ;
		sh:name "last name" ;
		sh:description "The person's last name" ;
		sh:order 1 ;
		sh:group ex:NameGroup ;
	] ;
	sh:property [
		sh:path ex:firstName ;
		sh:name "first name" ;
		sh:description "The person's given name(s)" ;
		sh:order 0 ;
		sh:group ex:NameGroup ;
	] ;
	sh:property [
		sh:path ex:postalCode ;
		sh:name "postal code" ;
		sh:name "zip code"@en-us ;
		sh:description "The postal code of the locality" ;
		sh:order 13 ;
		sh:group ex:AddressGroup ;
	] ;
	sh:property [
		sh:path ex:streetAddress ;
		sh:name "street address" ;
		sh:description "The street address including number" ;
		sh:order 11 ;
		sh:group ex:AddressGroup ;
	] ;
	sh:property [
		sh:path ex:locality ;
		sh:name "locality" ;
		sh:description "The city or town of the address" ;
		sh:order 12 ;
		sh:group ex:AddressGroup ;
	] .
	
ex:AddressGroup
	a sh:PropertyGroup ;
	sh:order 1 ;
	rdfs:label "Address" .

ex:NameGroup
	a sh:PropertyGroup ;
	sh:order 0 ;
	rdfs:label "Name" .
						</div>
						<div class="jsonld">
							<pre class="jsonld">{
	"@graph": [
		{
			"@id": "ex:AddressGroup",
			"@type": "sh:PropertyGroup",
			"rdfs:label": "Address",
			"sh:order": {
				"@type": "xsd:integer",
				"@value": "1"
			}
		},
		{
			"@id": "ex:NameGroup",
			"@type": "sh:PropertyGroup",
			"rdfs:label": "Name",
			"sh:order": {
				"@type": "xsd:integer",
				"@value": "0"
			}
		},
		{
			"@id": "ex:PersonFormShape",
			"@type": "sh:NodeShape",
			"sh:property": [
				{
					"sh:description": "The person's last name",
					"sh:group": {
						"@id": "ex:NameGroup"
					},
					"sh:name": "last name",
					"sh:order": {
						"@type": "xsd:integer",
						"@value": "1"
					},
					"sh:path": {
						"@id": "ex:lastName"
					}
				},
				{
					"sh:description": "The person's given name(s)",
					"sh:group": {
						"@id": "ex:NameGroup"
					},
					"sh:name": "first name",
					"sh:order": {
						"@type": "xsd:integer",
						"@value": "0"
					},
					"sh:path": {
						"@id": "ex:firstName"
					}
				},
				{
					"sh:description": "The postal code of the locality",
					"sh:group": {
						"@id": "ex:AddressGroup"
					},
					"sh:name": [
						"postal code",
						{
							"@language": "en-us",
							"@value": "zip code"
						}
					],
					"sh:order": {
						"@type": "xsd:integer",
						"@value": "13"
					},
					"sh:path": {
						"@id": "ex:postalCode"
					}
				},
				{
					"sh:description": "The street address including number",
					"sh:group": {
						"@id": "ex:AddressGroup"
					},
					"sh:name": "street address",
					"sh:order": {
						"@type": "xsd:integer",
						"@value": "11"
					},
					"sh:path": {
						"@id": "ex:streetAddress"
					}
				},
				{
					"sh:description": "The city or town of the address",
					"sh:group": {
						"@id": "ex:AddressGroup"
					},
					"sh:name": "locality",
					"sh:order": {
						"@type": "xsd:integer",
						"@value": "12"
					},
					"sh:path": {
						"@id": "ex:locality"
					}
				}
			]
		}
	]
}</pre>
						</div>
					</div>
				</aside>
			</section>
		</section>
		
		<div style="padding-top: 30px">
			<h1 id="appendix" style="font-size: 160%; font-weight: bold">Appendix</h1>
		</div>
		
		<section id="syntax-rules" class="appendix">
			<h2>Summary of SHACL Syntax Rules</h2>
			<p>
				This section enumerates all normative syntax rules of SHACL.
				This section is automatically generated from other parts of this spec and hyperlinks are provided back
				into the prose if the context of the rule in unclear. 
				Nodes that violate these rules in a <a>shapes graph</a> are <a>ill-formed</a>.
			</p>
			<table class="term-table" id="syntax-rules-table">
				<thead><tr>
					<th>Syntax Rule Id</th>
					<th>Syntax Rule Text</th>
				</tr>
			</thead></table>
		</section>
		
		<section id="shacl-shacl" class="appendix informative">
			<h2>SHACL Shapes to Validate Shapes Graphs</h2>
			<p>
				The SHACL 1.2 SHACL-SHACL Note [[shacl12-shacl-shacl]] describes a SHACL graph that can be used to
				validate other SHACL Shapes graphs and thus may enforce many of the syntactic constraints related to
				RDF data aiming to conform to SHACL Core in this specification.
			</p>
			<p>
				This shapes graph is available as an RDF resource at <a href="http://www.w3.org/ns/shacl-shacl">http://www.w3.org/ns/shacl-shacl</a>,
				as indicated in the Note.
			</p>
			<p class="todo">
				TODO: Replace the hyperlink to the NOTE with a reference once that has been created.
			</p>
		</section>
		
		<section id="core-validators" class="appendix">
			<h2>Summary of SHACL Core Validators</h2>
			<p>
				This section enumerates all normative <a>validators</a> of SHACL Core.
				This section is automatically generated from other parts of this spec and hyperlinks are provided back
				into the prose if the context of the validator in unclear. 
			</p>
			<table class="term-table" id="validators-table">
				<thead><tr>
					<th>Validators by Constraint Component</th>
				</tr>
			</thead></table>
		</section>
		
		<section id="security" class="appendix informative">
			<h2>Security and Privacy Considerations</h2>
			<p>
				Like most RDF-based technologies, SHACL processors may operate on graphs that are combined
				from various sources.  Some applications may have an open "linked data" architecture and dynamically
				assemble RDF triples from sources that are outside of an organization's network of trust.
				Since RDF allows anyone to add statements about any resource, triples may modify the originally
				intended semantics of shape definitions or nodes in a data graph and thus lead to misleading results.
				Protection against this (and the following) scenario can be achieved by only using trusted
				and verified RDF sources and eliminating the possibility that graphs are dynamically added via
				<code>owl:imports</code> and <code>sh:shapesGraph</code>.
			</p>
		</section>

		<section id="ack" class="appendix informative">
			<h2>Acknowledgements</h2>
			<p>
				The original 1.0 version of SHACL was produced by the RDF Data Shapes Working Group.
				See its <a href="https://www.w3.org/TR/shacl/#ack">SHACL 1.0 Acknowledgements section</a>.
			</p>
		</section>

		<section class="appendix informative">
		  <h2>Revision History</h2>
			<p>
				The detailed list of changes and their diffs can be found in the <a href="https://github.com/w3c/data-shapes">Git repository</a>.
			</p>
			<ul>
				<li><b>2024-02-14</b>: New work started by cloning the main SHACL spec and splitting it into SHACL Core and SHACL-SPARQL</li>
			</ul>
		</section>

		<section class="appendix informative" id="changes-12">
			<h2>Changes between SHACL 1.0 Core and SHACL 1.2 Core</h2>
			<ul>
				<li>Introduced <a>node expressions</a> as an extension point to dynamically compute lists of nodes. Generalized <code>sh:targetNode</code>, <code>sh:deactivated</code> and <code>sh:defaultValue</code>, and introduced <code>sh:values</code> to support node expressions.</li>
				<li>Added the new constraint component <a href="#SingleLineConstraintComponent"><code>sh:singleLine</code></a>, see <a href="https://github.com/w3c/data-shapes/issues/177">Issue 177</a></li>
				<li>Added the new class <a href="#ShapeClass"><code>sh:ShapeClass</code></a> for implicit class targets; see <a href="https://github.com/w3c/data-shapes/issues/212">Issue 212</a></li>
				<li>Moved SPARQL-based validators from Core to an Appendix of SHACL-SPARQL; see <a href="https://github.com/w3c/data-shapes/issues/271">Issue 271</a></li>
				<li>Added the new constraint component <a href="#ExpressionConstraintComponent"><code>sh:expression</code></a>; see <a href="https://github.com/w3c/data-shapes/issues/357">Issue 357</a></li>
				<li>Added the new constraint component <a href="#NodeByExpressionConstraintComponent"><code>sh:nodeByExpression</code></a>, see <a href="https://github.com/w3c/data-shapes/issues/408">Issue 408</a></li>
				<li>Added the new value <code>sh:ByTypes</code> for <a href="#ClosedConstraintComponent"><code>sh:closed</code></a>; see <a href="https://github.com/w3c/data-shapes/issues/172">Issue 172</a></li>
				<li>The values of <a href="#ClassConstraintComponent"><code>sh:class</code></a> and <a href="#DatatypeConstraintComponent"><code>sh:datatype</code></a> can now also be lists, indicating a union of choices; see <a href="https://github.com/w3c/data-shapes/issues/160">Issue 160</a></li>
			</ul>
		</section>
	

	<script type="text/javascript">

		tooltip = "Targets are not the only way to initiate validation, SHACL also allows specific nodes to be validated against specific shapes.";
		var t = document.getElementsByClassName("target-can-be-skipped");
		for (var i = 0; i < t.length; i++) {
			t[i].title = tooltip;
		}
		
	</script>




</body></html>
