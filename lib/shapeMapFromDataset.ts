/**
 * @fileoverview ShapeMap generation functionality for preserving SHACL target class information
 * @generated This file was generated by GitHub Copilot AI to resolve issue #283
 */

import { DataFactory, Store } from 'n3';
import { rdf, shacl } from 'rdf-namespaces';
import { ShapeShapeShapeType } from './ldo/Shacl.shapeTypes';
import { shapeFromDataset } from './shapeFromDataset';

const { namedNode, defaultGraph } = DataFactory;

/**
 * Filters prefixes to exclude only those that are auto-generated but not explicitly declared
 */
function filterUsedPrefixes(prefixes: Record<string, string>, store?: Store): Record<string, string> {
  if (!store) {
    return prefixes;
  }

  const filteredPrefixes: Record<string, string> = {};

  // Get all prefixes that are NOT auto-added metadata
  for (const [prefix, uri] of Object.entries(prefixes)) {
    let shouldInclude = true;

    // Always include standard prefixes
    if (['rdf', 'rdfs', 'xsd', 'sh'].includes(prefix)) {
      shouldInclude = true;
    } else if (prefix === 'owl' && uri === 'http://www.w3.org/2002/07/owl#') {
      // Check if owl is only used for metadata (like owl:Ontology) and not in actual SHACL constructs
      let hasNonMetadataUsage = false;
      for (const quad of store.match(null, null, null)) {
        const subjectValue = quad.subject.value;
        const predicateValue = quad.predicate.value;
        const objectValue = quad.object.termType === 'NamedNode' ? quad.object.value : '';

        if (subjectValue.startsWith(uri) || predicateValue.startsWith(uri) || objectValue.startsWith(uri)) {
          // Check if this is just metadata usage
          if (!(predicateValue === 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type'
                && objectValue === 'http://www.w3.org/2002/07/owl#Ontology')) {
            hasNonMetadataUsage = true;
            break;
          }
        }
      }
      shouldInclude = hasNonMetadataUsage;
    }

    if (shouldInclude) {
      filteredPrefixes[prefix] = uri;
    }
  }

  return filteredPrefixes;
}

/**
 * A ShapeMap entry that associates RDF nodes with shapes for validation
 * Based on the ShapeMap specification: https://shexspec.github.io/shape-map/
 */
export interface ShapeMapEntry {
  /** The node pattern (e.g., "FOCUS rdf:type ex:Person") */
  node: string;
  /** The shape to validate against */
  shape: string;
}

/**
 * A complete ShapeMap that can be used with ShEx validation
 */
export interface ShapeMap {
  /** Array of node-shape associations */
  entries: ShapeMapEntry[];
}

/**
 * Extracts ShapeMap information from a SHACL dataset
 *
 * This function processes SHACL NodeShapes and generates corresponding ShapeMap entries
 * that preserve the target class information from sh:targetClass properties.
 *
 * @param shapeStore - The RDF store containing SHACL shapes
 * @returns A ShapeMap object containing the extracted mappings
 *
 * @example
 * ```typescript
 * import { shapeMapFromDataset } from './shapeMapFromDataset';
 *
 * const store = // ... load SHACL data
 * const shapeMap = shapeMapFromDataset(store);
 * console.log(shapeMap);
 * // Output: {
 * //   entries: [
 * //     {
 * //       node: "FOCUS rdf:type ex:ClassOfProduct",
 * //       shape: "ex:ClassOfProductShape"
 * //     }
 * //   ]
 * // }
 * ```
 */
export function shapeMapFromDataset(shapeStore: Store): ShapeMap {
  const entries: ShapeMapEntry[] = [];

  // Find all NodeShapes in the dataset
  for (const { subject: shape } of
    shapeStore.match(null, namedNode(rdf.type), namedNode(shacl.NodeShape), defaultGraph())
  ) {
    if (shape.termType !== 'NamedNode' && shape.termType !== 'BlankNode') {
      // eslint-disable-next-line no-continue
      continue;
    }

    try {
      // Extract shape-level data including targetClass
      const shapeData = shapeFromDataset(ShapeShapeShapeType, shapeStore, shape);

      // If the shape has targetClass properties, create ShapeMap entries
      if (shapeData.targetClass && shapeData.targetClass.length > 0) {
        for (const targetClass of shapeData.targetClass) {
          entries.push({
            node: `FOCUS rdf:type <${targetClass['@id']}>`,
            shape: shape.value,
          });
        }
      }

      // Handle other target types if present
      if (shapeData.targetSubjectsOf && shapeData.targetSubjectsOf.length > 0) {
        for (const targetPredicate of shapeData.targetSubjectsOf) {
          entries.push({
            node: `FOCUS <${targetPredicate['@id']}> _`,
            shape: shape.value,
          });
        }
      }

      if (shapeData.targetObjectsOf && shapeData.targetObjectsOf.length > 0) {
        for (const targetPredicate of shapeData.targetObjectsOf) {
          entries.push({
            node: `_ <${targetPredicate['@id']}> FOCUS`,
            shape: shape.value,
          });
        }
      }
    } catch (e) {
      // If we can't extract shape data, skip this shape
    }
  }

  return { entries };
}

/**
 * Converts a ShapeMap object to a human-readable string format
 *
 * @param shapeMap - The ShapeMap to serialize
 * @param prefixes - Optional prefix mappings for shorter URIs
 * @returns A string representation of the ShapeMap
 *
 * @example
 * ```typescript
 * const shapeMap = { entries: [{ node: "FOCUS rdf:type ex:Person", shape: "ex:PersonShape" }] };
 * const output = writeShapeMap(shapeMap);
 * console.log(output);
 * // Output: "FOCUS rdf:type ex:Person@ex:PersonShape"
 * ```
 */
export function writeShapeMap(shapeMap: ShapeMap, prefixes?: Record<string, string>, store?: Store): string {
  if (shapeMap.entries.length === 0) {
    return '# No shape mappings found\n';
  }

  let output = '# @generated This file was generated by GitHub Copilot AI to test issue #283 resolution\n';
  output += '# ShapeMap - Associates RDF nodes with validation shapes\n';
  output += '# Based on: https://shexspec.github.io/shape-map/\n';
  output += '# Format: {node pattern}@{shape}\n\n';

  // Filter prefixes to exclude auto-generated ones
  const filteredPrefixes = prefixes ? filterUsedPrefixes(prefixes, store) : undefined;

  // Add prefix declarations if provided
  if (filteredPrefixes) {
    for (const [prefix, iri] of Object.entries(filteredPrefixes)) {
      if (prefix && prefix !== 'base') {
        output += `PREFIX ${prefix}: <${iri}>\n`;
      }
    }
    output += '\n';
  }

  // Add each mapping
  for (const entry of shapeMap.entries) {
    let nodePattern = entry.node;
    let shapeId = entry.shape;

    // Apply prefix compression if available
    if (filteredPrefixes) {
      for (const [prefix, iri] of Object.entries(filteredPrefixes)) {
        if (prefix && prefix !== 'base') {
          const iriPattern = new RegExp(`<${iri.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}([^>]*)>`, 'g');
          nodePattern = nodePattern.replace(iriPattern, `${prefix}:$1`);
          shapeId = shapeId.replace(iri, `${prefix}:`);
        }
      }
    }

    output += `{${nodePattern}}@${shapeId}\n`;
  }

  return output;
}
